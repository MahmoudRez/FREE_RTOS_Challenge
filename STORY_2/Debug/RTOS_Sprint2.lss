
RTOS_Sprint2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ba8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000a8  00800060  00006ba8  00006c3c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000666  00800108  00800108  00006ce4  2**0
                  ALLOC
  3 .stab         0000a554  00000000  00000000  00006ce4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000054f0  00000000  00000000  00011238  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 11 08 	jmp	0x1022	; 0x1022 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ea       	ldi	r30, 0xA8	; 168
      68:	fb e6       	ldi	r31, 0x6B	; 107
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a8 30       	cpi	r26, 0x08	; 8
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	a8 e0       	ldi	r26, 0x08	; 8
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ae 36       	cpi	r26, 0x6E	; 110
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 6e 35 	call	0x6adc	; 0x6adc <main>
      8a:	0c 94 d2 35 	jmp	0x6ba4	; 0x6ba4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <xEventGroupCreate>:
      92:	df 93       	push	r29
      94:	cf 93       	push	r28
      96:	00 d0       	rcall	.+0      	; 0x98 <xEventGroupCreate+0x6>
      98:	cd b7       	in	r28, 0x3d	; 61
      9a:	de b7       	in	r29, 0x3e	; 62
      9c:	8b e0       	ldi	r24, 0x0B	; 11
      9e:	90 e0       	ldi	r25, 0x00	; 0
      a0:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
      a4:	9a 83       	std	Y+2, r25	; 0x02
      a6:	89 83       	std	Y+1, r24	; 0x01
      a8:	89 81       	ldd	r24, Y+1	; 0x01
      aa:	9a 81       	ldd	r25, Y+2	; 0x02
      ac:	00 97       	sbiw	r24, 0x00	; 0
      ae:	49 f0       	breq	.+18     	; 0xc2 <xEventGroupCreate+0x30>
      b0:	e9 81       	ldd	r30, Y+1	; 0x01
      b2:	fa 81       	ldd	r31, Y+2	; 0x02
      b4:	11 82       	std	Z+1, r1	; 0x01
      b6:	10 82       	st	Z, r1
      b8:	89 81       	ldd	r24, Y+1	; 0x01
      ba:	9a 81       	ldd	r25, Y+2	; 0x02
      bc:	02 96       	adiw	r24, 0x02	; 2
      be:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
      c2:	89 81       	ldd	r24, Y+1	; 0x01
      c4:	9a 81       	ldd	r25, Y+2	; 0x02
      c6:	0f 90       	pop	r0
      c8:	0f 90       	pop	r0
      ca:	cf 91       	pop	r28
      cc:	df 91       	pop	r29
      ce:	08 95       	ret

000000d0 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
      d0:	df 93       	push	r29
      d2:	cf 93       	push	r28
      d4:	cd b7       	in	r28, 0x3d	; 61
      d6:	de b7       	in	r29, 0x3e	; 62
      d8:	60 97       	sbiw	r28, 0x10	; 16
      da:	0f b6       	in	r0, 0x3f	; 63
      dc:	f8 94       	cli
      de:	de bf       	out	0x3e, r29	; 62
      e0:	0f be       	out	0x3f, r0	; 63
      e2:	cd bf       	out	0x3d, r28	; 61
      e4:	9a 87       	std	Y+10, r25	; 0x0a
      e6:	89 87       	std	Y+9, r24	; 0x09
      e8:	7c 87       	std	Y+12, r23	; 0x0c
      ea:	6b 87       	std	Y+11, r22	; 0x0b
      ec:	5e 87       	std	Y+14, r21	; 0x0e
      ee:	4d 87       	std	Y+13, r20	; 0x0d
      f0:	38 8b       	std	Y+16, r19	; 0x10
      f2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
      f4:	89 85       	ldd	r24, Y+9	; 0x09
      f6:	9a 85       	ldd	r25, Y+10	; 0x0a
      f8:	9c 83       	std	Y+4, r25	; 0x04
      fa:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
      fc:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
      fe:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     102:	eb 81       	ldd	r30, Y+3	; 0x03
     104:	fc 81       	ldd	r31, Y+4	; 0x04
     106:	80 81       	ld	r24, Z
     108:	91 81       	ldd	r25, Z+1	; 0x01
     10a:	98 87       	std	Y+8, r25	; 0x08
     10c:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     10e:	89 85       	ldd	r24, Y+9	; 0x09
     110:	9a 85       	ldd	r25, Y+10	; 0x0a
     112:	2b 85       	ldd	r18, Y+11	; 0x0b
     114:	3c 85       	ldd	r19, Y+12	; 0x0c
     116:	b9 01       	movw	r22, r18
     118:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     11c:	2f 81       	ldd	r18, Y+7	; 0x07
     11e:	38 85       	ldd	r19, Y+8	; 0x08
     120:	8b 85       	ldd	r24, Y+11	; 0x0b
     122:	9c 85       	ldd	r25, Y+12	; 0x0c
     124:	28 2b       	or	r18, r24
     126:	39 2b       	or	r19, r25
     128:	8d 85       	ldd	r24, Y+13	; 0x0d
     12a:	9e 85       	ldd	r25, Y+14	; 0x0e
     12c:	28 23       	and	r18, r24
     12e:	39 23       	and	r19, r25
     130:	8d 85       	ldd	r24, Y+13	; 0x0d
     132:	9e 85       	ldd	r25, Y+14	; 0x0e
     134:	28 17       	cp	r18, r24
     136:	39 07       	cpc	r19, r25
     138:	c9 f4       	brne	.+50     	; 0x16c <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     13a:	2f 81       	ldd	r18, Y+7	; 0x07
     13c:	38 85       	ldd	r19, Y+8	; 0x08
     13e:	8b 85       	ldd	r24, Y+11	; 0x0b
     140:	9c 85       	ldd	r25, Y+12	; 0x0c
     142:	82 2b       	or	r24, r18
     144:	93 2b       	or	r25, r19
     146:	9e 83       	std	Y+6, r25	; 0x06
     148:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     14a:	eb 81       	ldd	r30, Y+3	; 0x03
     14c:	fc 81       	ldd	r31, Y+4	; 0x04
     14e:	20 81       	ld	r18, Z
     150:	31 81       	ldd	r19, Z+1	; 0x01
     152:	8d 85       	ldd	r24, Y+13	; 0x0d
     154:	9e 85       	ldd	r25, Y+14	; 0x0e
     156:	80 95       	com	r24
     158:	90 95       	com	r25
     15a:	82 23       	and	r24, r18
     15c:	93 23       	and	r25, r19
     15e:	eb 81       	ldd	r30, Y+3	; 0x03
     160:	fc 81       	ldd	r31, Y+4	; 0x04
     162:	91 83       	std	Z+1, r25	; 0x01
     164:	80 83       	st	Z, r24

			xTicksToWait = 0;
     166:	18 8a       	std	Y+16, r1	; 0x10
     168:	1f 86       	std	Y+15, r1	; 0x0f
     16a:	1e c0       	rjmp	.+60     	; 0x1a8 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     16c:	8f 85       	ldd	r24, Y+15	; 0x0f
     16e:	98 89       	ldd	r25, Y+16	; 0x10
     170:	00 97       	sbiw	r24, 0x00	; 0
     172:	91 f0       	breq	.+36     	; 0x198 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     174:	8b 81       	ldd	r24, Y+3	; 0x03
     176:	9c 81       	ldd	r25, Y+4	; 0x04
     178:	bc 01       	movw	r22, r24
     17a:	6e 5f       	subi	r22, 0xFE	; 254
     17c:	7f 4f       	sbci	r23, 0xFF	; 255
     17e:	8d 85       	ldd	r24, Y+13	; 0x0d
     180:	9e 85       	ldd	r25, Y+14	; 0x0e
     182:	9c 01       	movw	r18, r24
     184:	35 60       	ori	r19, 0x05	; 5
     186:	4f 85       	ldd	r20, Y+15	; 0x0f
     188:	58 89       	ldd	r21, Y+16	; 0x10
     18a:	cb 01       	movw	r24, r22
     18c:	b9 01       	movw	r22, r18
     18e:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     192:	1e 82       	std	Y+6, r1	; 0x06
     194:	1d 82       	std	Y+5, r1	; 0x05
     196:	08 c0       	rjmp	.+16     	; 0x1a8 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     198:	eb 81       	ldd	r30, Y+3	; 0x03
     19a:	fc 81       	ldd	r31, Y+4	; 0x04
     19c:	80 81       	ld	r24, Z
     19e:	91 81       	ldd	r25, Z+1	; 0x01
     1a0:	9e 83       	std	Y+6, r25	; 0x06
     1a2:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     1a4:	81 e0       	ldi	r24, 0x01	; 1
     1a6:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     1a8:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
     1ac:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     1ae:	8f 85       	ldd	r24, Y+15	; 0x0f
     1b0:	98 89       	ldd	r25, Y+16	; 0x10
     1b2:	00 97       	sbiw	r24, 0x00	; 0
     1b4:	09 f4       	brne	.+2      	; 0x1b8 <xEventGroupSync+0xe8>
     1b6:	3a c0       	rjmp	.+116    	; 0x22c <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     1b8:	8a 81       	ldd	r24, Y+2	; 0x02
     1ba:	88 23       	and	r24, r24
     1bc:	11 f4       	brne	.+4      	; 0x1c2 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     1be:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     1c2:	0e 94 ee 21 	call	0x43dc	; 0x43dc <uxTaskResetEventItemValue>
     1c6:	9e 83       	std	Y+6, r25	; 0x06
     1c8:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     1ca:	8d 81       	ldd	r24, Y+5	; 0x05
     1cc:	9e 81       	ldd	r25, Y+6	; 0x06
     1ce:	80 70       	andi	r24, 0x00	; 0
     1d0:	92 70       	andi	r25, 0x02	; 2
     1d2:	00 97       	sbiw	r24, 0x00	; 0
     1d4:	31 f5       	brne	.+76     	; 0x222 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     1d6:	0f b6       	in	r0, 0x3f	; 63
     1d8:	f8 94       	cli
     1da:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     1dc:	eb 81       	ldd	r30, Y+3	; 0x03
     1de:	fc 81       	ldd	r31, Y+4	; 0x04
     1e0:	80 81       	ld	r24, Z
     1e2:	91 81       	ldd	r25, Z+1	; 0x01
     1e4:	9e 83       	std	Y+6, r25	; 0x06
     1e6:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     1e8:	2d 81       	ldd	r18, Y+5	; 0x05
     1ea:	3e 81       	ldd	r19, Y+6	; 0x06
     1ec:	8d 85       	ldd	r24, Y+13	; 0x0d
     1ee:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f0:	28 23       	and	r18, r24
     1f2:	39 23       	and	r19, r25
     1f4:	8d 85       	ldd	r24, Y+13	; 0x0d
     1f6:	9e 85       	ldd	r25, Y+14	; 0x0e
     1f8:	28 17       	cp	r18, r24
     1fa:	39 07       	cpc	r19, r25
     1fc:	71 f4       	brne	.+28     	; 0x21a <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     1fe:	eb 81       	ldd	r30, Y+3	; 0x03
     200:	fc 81       	ldd	r31, Y+4	; 0x04
     202:	20 81       	ld	r18, Z
     204:	31 81       	ldd	r19, Z+1	; 0x01
     206:	8d 85       	ldd	r24, Y+13	; 0x0d
     208:	9e 85       	ldd	r25, Y+14	; 0x0e
     20a:	80 95       	com	r24
     20c:	90 95       	com	r25
     20e:	82 23       	and	r24, r18
     210:	93 23       	and	r25, r19
     212:	eb 81       	ldd	r30, Y+3	; 0x03
     214:	fc 81       	ldd	r31, Y+4	; 0x04
     216:	91 83       	std	Z+1, r25	; 0x01
     218:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     21a:	0f 90       	pop	r0
     21c:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     222:	8d 81       	ldd	r24, Y+5	; 0x05
     224:	9e 81       	ldd	r25, Y+6	; 0x06
     226:	90 70       	andi	r25, 0x00	; 0
     228:	9e 83       	std	Y+6, r25	; 0x06
     22a:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     22c:	8d 81       	ldd	r24, Y+5	; 0x05
     22e:	9e 81       	ldd	r25, Y+6	; 0x06
}
     230:	60 96       	adiw	r28, 0x10	; 16
     232:	0f b6       	in	r0, 0x3f	; 63
     234:	f8 94       	cli
     236:	de bf       	out	0x3e, r29	; 62
     238:	0f be       	out	0x3f, r0	; 63
     23a:	cd bf       	out	0x3d, r28	; 61
     23c:	cf 91       	pop	r28
     23e:	df 91       	pop	r29
     240:	08 95       	ret

00000242 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     242:	0f 93       	push	r16
     244:	1f 93       	push	r17
     246:	df 93       	push	r29
     248:	cf 93       	push	r28
     24a:	cd b7       	in	r28, 0x3d	; 61
     24c:	de b7       	in	r29, 0x3e	; 62
     24e:	63 97       	sbiw	r28, 0x13	; 19
     250:	0f b6       	in	r0, 0x3f	; 63
     252:	f8 94       	cli
     254:	de bf       	out	0x3e, r29	; 62
     256:	0f be       	out	0x3f, r0	; 63
     258:	cd bf       	out	0x3d, r28	; 61
     25a:	9d 87       	std	Y+13, r25	; 0x0d
     25c:	8c 87       	std	Y+12, r24	; 0x0c
     25e:	7f 87       	std	Y+15, r23	; 0x0f
     260:	6e 87       	std	Y+14, r22	; 0x0e
     262:	48 8b       	std	Y+16, r20	; 0x10
     264:	29 8b       	std	Y+17, r18	; 0x11
     266:	1b 8b       	std	Y+19, r17	; 0x13
     268:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     26a:	8c 85       	ldd	r24, Y+12	; 0x0c
     26c:	9d 85       	ldd	r25, Y+13	; 0x0d
     26e:	9b 87       	std	Y+11, r25	; 0x0b
     270:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     272:	1f 82       	std	Y+7, r1	; 0x07
     274:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     276:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     278:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     27c:	ea 85       	ldd	r30, Y+10	; 0x0a
     27e:	fb 85       	ldd	r31, Y+11	; 0x0b
     280:	80 81       	ld	r24, Z
     282:	91 81       	ldd	r25, Z+1	; 0x01
     284:	9a 83       	std	Y+2, r25	; 0x02
     286:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     288:	89 81       	ldd	r24, Y+1	; 0x01
     28a:	9a 81       	ldd	r25, Y+2	; 0x02
     28c:	2e 85       	ldd	r18, Y+14	; 0x0e
     28e:	3f 85       	ldd	r19, Y+15	; 0x0f
     290:	b9 01       	movw	r22, r18
     292:	49 89       	ldd	r20, Y+17	; 0x11
     294:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     298:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     29a:	8d 81       	ldd	r24, Y+5	; 0x05
     29c:	88 23       	and	r24, r24
     29e:	c1 f0       	breq	.+48     	; 0x2d0 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	99 87       	std	Y+9, r25	; 0x09
     2a6:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     2a8:	1b 8a       	std	Y+19, r1	; 0x13
     2aa:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     2ac:	88 89       	ldd	r24, Y+16	; 0x10
     2ae:	88 23       	and	r24, r24
     2b0:	e9 f1       	breq	.+122    	; 0x32c <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     2b2:	ea 85       	ldd	r30, Y+10	; 0x0a
     2b4:	fb 85       	ldd	r31, Y+11	; 0x0b
     2b6:	20 81       	ld	r18, Z
     2b8:	31 81       	ldd	r19, Z+1	; 0x01
     2ba:	8e 85       	ldd	r24, Y+14	; 0x0e
     2bc:	9f 85       	ldd	r25, Y+15	; 0x0f
     2be:	80 95       	com	r24
     2c0:	90 95       	com	r25
     2c2:	82 23       	and	r24, r18
     2c4:	93 23       	and	r25, r19
     2c6:	ea 85       	ldd	r30, Y+10	; 0x0a
     2c8:	fb 85       	ldd	r31, Y+11	; 0x0b
     2ca:	91 83       	std	Z+1, r25	; 0x01
     2cc:	80 83       	st	Z, r24
     2ce:	2e c0       	rjmp	.+92     	; 0x32c <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     2d0:	8a 89       	ldd	r24, Y+18	; 0x12
     2d2:	9b 89       	ldd	r25, Y+19	; 0x13
     2d4:	00 97       	sbiw	r24, 0x00	; 0
     2d6:	39 f4       	brne	.+14     	; 0x2e6 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     2d8:	89 81       	ldd	r24, Y+1	; 0x01
     2da:	9a 81       	ldd	r25, Y+2	; 0x02
     2dc:	99 87       	std	Y+9, r25	; 0x09
     2de:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     2e0:	81 e0       	ldi	r24, 0x01	; 1
     2e2:	8b 83       	std	Y+3, r24	; 0x03
     2e4:	23 c0       	rjmp	.+70     	; 0x32c <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     2e6:	88 89       	ldd	r24, Y+16	; 0x10
     2e8:	88 23       	and	r24, r24
     2ea:	29 f0       	breq	.+10     	; 0x2f6 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     2ec:	8e 81       	ldd	r24, Y+6	; 0x06
     2ee:	9f 81       	ldd	r25, Y+7	; 0x07
     2f0:	91 60       	ori	r25, 0x01	; 1
     2f2:	9f 83       	std	Y+7, r25	; 0x07
     2f4:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     2f6:	89 89       	ldd	r24, Y+17	; 0x11
     2f8:	88 23       	and	r24, r24
     2fa:	29 f0       	breq	.+10     	; 0x306 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     2fc:	8e 81       	ldd	r24, Y+6	; 0x06
     2fe:	9f 81       	ldd	r25, Y+7	; 0x07
     300:	94 60       	ori	r25, 0x04	; 4
     302:	9f 83       	std	Y+7, r25	; 0x07
     304:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     306:	8a 85       	ldd	r24, Y+10	; 0x0a
     308:	9b 85       	ldd	r25, Y+11	; 0x0b
     30a:	bc 01       	movw	r22, r24
     30c:	6e 5f       	subi	r22, 0xFE	; 254
     30e:	7f 4f       	sbci	r23, 0xFF	; 255
     310:	2e 85       	ldd	r18, Y+14	; 0x0e
     312:	3f 85       	ldd	r19, Y+15	; 0x0f
     314:	8e 81       	ldd	r24, Y+6	; 0x06
     316:	9f 81       	ldd	r25, Y+7	; 0x07
     318:	28 2b       	or	r18, r24
     31a:	39 2b       	or	r19, r25
     31c:	4a 89       	ldd	r20, Y+18	; 0x12
     31e:	5b 89       	ldd	r21, Y+19	; 0x13
     320:	cb 01       	movw	r24, r22
     322:	b9 01       	movw	r22, r18
     324:	0e 94 d6 1d 	call	0x3bac	; 0x3bac <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     328:	19 86       	std	Y+9, r1	; 0x09
     32a:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     32c:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
     330:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     332:	8a 89       	ldd	r24, Y+18	; 0x12
     334:	9b 89       	ldd	r25, Y+19	; 0x13
     336:	00 97       	sbiw	r24, 0x00	; 0
     338:	09 f4       	brne	.+2      	; 0x33c <xEventGroupWaitBits+0xfa>
     33a:	3c c0       	rjmp	.+120    	; 0x3b4 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	88 23       	and	r24, r24
     340:	11 f4       	brne	.+4      	; 0x346 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
     342:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     346:	0e 94 ee 21 	call	0x43dc	; 0x43dc <uxTaskResetEventItemValue>
     34a:	99 87       	std	Y+9, r25	; 0x09
     34c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     34e:	88 85       	ldd	r24, Y+8	; 0x08
     350:	99 85       	ldd	r25, Y+9	; 0x09
     352:	80 70       	andi	r24, 0x00	; 0
     354:	92 70       	andi	r25, 0x02	; 2
     356:	00 97       	sbiw	r24, 0x00	; 0
     358:	41 f5       	brne	.+80     	; 0x3aa <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
     35a:	0f b6       	in	r0, 0x3f	; 63
     35c:	f8 94       	cli
     35e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     360:	ea 85       	ldd	r30, Y+10	; 0x0a
     362:	fb 85       	ldd	r31, Y+11	; 0x0b
     364:	80 81       	ld	r24, Z
     366:	91 81       	ldd	r25, Z+1	; 0x01
     368:	99 87       	std	Y+9, r25	; 0x09
     36a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
     36c:	88 85       	ldd	r24, Y+8	; 0x08
     36e:	99 85       	ldd	r25, Y+9	; 0x09
     370:	2e 85       	ldd	r18, Y+14	; 0x0e
     372:	3f 85       	ldd	r19, Y+15	; 0x0f
     374:	b9 01       	movw	r22, r18
     376:	49 89       	ldd	r20, Y+17	; 0x11
     378:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <prvTestWaitCondition>
     37c:	88 23       	and	r24, r24
     37e:	89 f0       	breq	.+34     	; 0x3a2 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
     380:	88 89       	ldd	r24, Y+16	; 0x10
     382:	88 23       	and	r24, r24
     384:	71 f0       	breq	.+28     	; 0x3a2 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     386:	ea 85       	ldd	r30, Y+10	; 0x0a
     388:	fb 85       	ldd	r31, Y+11	; 0x0b
     38a:	20 81       	ld	r18, Z
     38c:	31 81       	ldd	r19, Z+1	; 0x01
     38e:	8e 85       	ldd	r24, Y+14	; 0x0e
     390:	9f 85       	ldd	r25, Y+15	; 0x0f
     392:	80 95       	com	r24
     394:	90 95       	com	r25
     396:	82 23       	and	r24, r18
     398:	93 23       	and	r25, r19
     39a:	ea 85       	ldd	r30, Y+10	; 0x0a
     39c:	fb 85       	ldd	r31, Y+11	; 0x0b
     39e:	91 83       	std	Z+1, r25	; 0x01
     3a0:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
     3a6:	0f 90       	pop	r0
     3a8:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     3aa:	88 85       	ldd	r24, Y+8	; 0x08
     3ac:	99 85       	ldd	r25, Y+9	; 0x09
     3ae:	90 70       	andi	r25, 0x00	; 0
     3b0:	99 87       	std	Y+9, r25	; 0x09
     3b2:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     3b4:	88 85       	ldd	r24, Y+8	; 0x08
     3b6:	99 85       	ldd	r25, Y+9	; 0x09
}
     3b8:	63 96       	adiw	r28, 0x13	; 19
     3ba:	0f b6       	in	r0, 0x3f	; 63
     3bc:	f8 94       	cli
     3be:	de bf       	out	0x3e, r29	; 62
     3c0:	0f be       	out	0x3f, r0	; 63
     3c2:	cd bf       	out	0x3d, r28	; 61
     3c4:	cf 91       	pop	r28
     3c6:	df 91       	pop	r29
     3c8:	1f 91       	pop	r17
     3ca:	0f 91       	pop	r16
     3cc:	08 95       	ret

000003ce <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
     3ce:	df 93       	push	r29
     3d0:	cf 93       	push	r28
     3d2:	cd b7       	in	r28, 0x3d	; 61
     3d4:	de b7       	in	r29, 0x3e	; 62
     3d6:	28 97       	sbiw	r28, 0x08	; 8
     3d8:	0f b6       	in	r0, 0x3f	; 63
     3da:	f8 94       	cli
     3dc:	de bf       	out	0x3e, r29	; 62
     3de:	0f be       	out	0x3f, r0	; 63
     3e0:	cd bf       	out	0x3d, r28	; 61
     3e2:	9e 83       	std	Y+6, r25	; 0x06
     3e4:	8d 83       	std	Y+5, r24	; 0x05
     3e6:	78 87       	std	Y+8, r23	; 0x08
     3e8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
     3ea:	8d 81       	ldd	r24, Y+5	; 0x05
     3ec:	9e 81       	ldd	r25, Y+6	; 0x06
     3ee:	9c 83       	std	Y+4, r25	; 0x04
     3f0:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
     3f2:	0f b6       	in	r0, 0x3f	; 63
     3f4:	f8 94       	cli
     3f6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
     3f8:	eb 81       	ldd	r30, Y+3	; 0x03
     3fa:	fc 81       	ldd	r31, Y+4	; 0x04
     3fc:	80 81       	ld	r24, Z
     3fe:	91 81       	ldd	r25, Z+1	; 0x01
     400:	9a 83       	std	Y+2, r25	; 0x02
     402:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     404:	eb 81       	ldd	r30, Y+3	; 0x03
     406:	fc 81       	ldd	r31, Y+4	; 0x04
     408:	20 81       	ld	r18, Z
     40a:	31 81       	ldd	r19, Z+1	; 0x01
     40c:	8f 81       	ldd	r24, Y+7	; 0x07
     40e:	98 85       	ldd	r25, Y+8	; 0x08
     410:	80 95       	com	r24
     412:	90 95       	com	r25
     414:	82 23       	and	r24, r18
     416:	93 23       	and	r25, r19
     418:	eb 81       	ldd	r30, Y+3	; 0x03
     41a:	fc 81       	ldd	r31, Y+4	; 0x04
     41c:	91 83       	std	Z+1, r25	; 0x01
     41e:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
     420:	0f 90       	pop	r0
     422:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
     424:	89 81       	ldd	r24, Y+1	; 0x01
     426:	9a 81       	ldd	r25, Y+2	; 0x02
}
     428:	28 96       	adiw	r28, 0x08	; 8
     42a:	0f b6       	in	r0, 0x3f	; 63
     42c:	f8 94       	cli
     42e:	de bf       	out	0x3e, r29	; 62
     430:	0f be       	out	0x3f, r0	; 63
     432:	cd bf       	out	0x3d, r28	; 61
     434:	cf 91       	pop	r28
     436:	df 91       	pop	r29
     438:	08 95       	ret

0000043a <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
     43a:	df 93       	push	r29
     43c:	cf 93       	push	r28
     43e:	cd b7       	in	r28, 0x3d	; 61
     440:	de b7       	in	r29, 0x3e	; 62
     442:	27 97       	sbiw	r28, 0x07	; 7
     444:	0f b6       	in	r0, 0x3f	; 63
     446:	f8 94       	cli
     448:	de bf       	out	0x3e, r29	; 62
     44a:	0f be       	out	0x3f, r0	; 63
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	9f 83       	std	Y+7, r25	; 0x07
     450:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
     452:	8e 81       	ldd	r24, Y+6	; 0x06
     454:	9f 81       	ldd	r25, Y+7	; 0x07
     456:	9c 83       	std	Y+4, r25	; 0x04
     458:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
     45a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
     45c:	eb 81       	ldd	r30, Y+3	; 0x03
     45e:	fc 81       	ldd	r31, Y+4	; 0x04
     460:	80 81       	ld	r24, Z
     462:	91 81       	ldd	r25, Z+1	; 0x01
     464:	9a 83       	std	Y+2, r25	; 0x02
     466:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
     468:	89 81       	ldd	r24, Y+1	; 0x01
     46a:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
     46c:	27 96       	adiw	r28, 0x07	; 7
     46e:	0f b6       	in	r0, 0x3f	; 63
     470:	f8 94       	cli
     472:	de bf       	out	0x3e, r29	; 62
     474:	0f be       	out	0x3f, r0	; 63
     476:	cd bf       	out	0x3d, r28	; 61
     478:	cf 91       	pop	r28
     47a:	df 91       	pop	r29
     47c:	08 95       	ret

0000047e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
     47e:	df 93       	push	r29
     480:	cf 93       	push	r28
     482:	cd b7       	in	r28, 0x3d	; 61
     484:	de b7       	in	r29, 0x3e	; 62
     486:	65 97       	sbiw	r28, 0x15	; 21
     488:	0f b6       	in	r0, 0x3f	; 63
     48a:	f8 94       	cli
     48c:	de bf       	out	0x3e, r29	; 62
     48e:	0f be       	out	0x3f, r0	; 63
     490:	cd bf       	out	0x3d, r28	; 61
     492:	9b 8b       	std	Y+19, r25	; 0x13
     494:	8a 8b       	std	Y+18, r24	; 0x12
     496:	7d 8b       	std	Y+21, r23	; 0x15
     498:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
     49a:	19 86       	std	Y+9, r1	; 0x09
     49c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
     49e:	8a 89       	ldd	r24, Y+18	; 0x12
     4a0:	9b 89       	ldd	r25, Y+19	; 0x13
     4a2:	9b 83       	std	Y+3, r25	; 0x03
     4a4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
     4a6:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
     4a8:	8a 81       	ldd	r24, Y+2	; 0x02
     4aa:	9b 81       	ldd	r25, Y+3	; 0x03
     4ac:	02 96       	adiw	r24, 0x02	; 2
     4ae:	9b 87       	std	Y+11, r25	; 0x0b
     4b0:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     4b2:	8a 85       	ldd	r24, Y+10	; 0x0a
     4b4:	9b 85       	ldd	r25, Y+11	; 0x0b
     4b6:	03 96       	adiw	r24, 0x03	; 3
     4b8:	9d 87       	std	Y+13, r25	; 0x0d
     4ba:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
     4bc:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
     4c0:	ea 85       	ldd	r30, Y+10	; 0x0a
     4c2:	fb 85       	ldd	r31, Y+11	; 0x0b
     4c4:	85 81       	ldd	r24, Z+5	; 0x05
     4c6:	96 81       	ldd	r25, Z+6	; 0x06
     4c8:	99 8b       	std	Y+17, r25	; 0x11
     4ca:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
     4cc:	ea 81       	ldd	r30, Y+2	; 0x02
     4ce:	fb 81       	ldd	r31, Y+3	; 0x03
     4d0:	20 81       	ld	r18, Z
     4d2:	31 81       	ldd	r19, Z+1	; 0x01
     4d4:	8c 89       	ldd	r24, Y+20	; 0x14
     4d6:	9d 89       	ldd	r25, Y+21	; 0x15
     4d8:	82 2b       	or	r24, r18
     4da:	93 2b       	or	r25, r19
     4dc:	ea 81       	ldd	r30, Y+2	; 0x02
     4de:	fb 81       	ldd	r31, Y+3	; 0x03
     4e0:	91 83       	std	Z+1, r25	; 0x01
     4e2:	80 83       	st	Z, r24
     4e4:	59 c0       	rjmp	.+178    	; 0x598 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
     4e6:	e8 89       	ldd	r30, Y+16	; 0x10
     4e8:	f9 89       	ldd	r31, Y+17	; 0x11
     4ea:	82 81       	ldd	r24, Z+2	; 0x02
     4ec:	93 81       	ldd	r25, Z+3	; 0x03
     4ee:	9f 87       	std	Y+15, r25	; 0x0f
     4f0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
     4f2:	e8 89       	ldd	r30, Y+16	; 0x10
     4f4:	f9 89       	ldd	r31, Y+17	; 0x11
     4f6:	80 81       	ld	r24, Z
     4f8:	91 81       	ldd	r25, Z+1	; 0x01
     4fa:	9f 83       	std	Y+7, r25	; 0x07
     4fc:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
     4fe:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
     500:	8e 81       	ldd	r24, Y+6	; 0x06
     502:	9f 81       	ldd	r25, Y+7	; 0x07
     504:	80 70       	andi	r24, 0x00	; 0
     506:	9d 83       	std	Y+5, r25	; 0x05
     508:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
     50a:	8e 81       	ldd	r24, Y+6	; 0x06
     50c:	9f 81       	ldd	r25, Y+7	; 0x07
     50e:	90 70       	andi	r25, 0x00	; 0
     510:	9f 83       	std	Y+7, r25	; 0x07
     512:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
     514:	8c 81       	ldd	r24, Y+4	; 0x04
     516:	9d 81       	ldd	r25, Y+5	; 0x05
     518:	80 70       	andi	r24, 0x00	; 0
     51a:	94 70       	andi	r25, 0x04	; 4
     51c:	00 97       	sbiw	r24, 0x00	; 0
     51e:	69 f4       	brne	.+26     	; 0x53a <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
     520:	ea 81       	ldd	r30, Y+2	; 0x02
     522:	fb 81       	ldd	r31, Y+3	; 0x03
     524:	20 81       	ld	r18, Z
     526:	31 81       	ldd	r19, Z+1	; 0x01
     528:	8e 81       	ldd	r24, Y+6	; 0x06
     52a:	9f 81       	ldd	r25, Y+7	; 0x07
     52c:	82 23       	and	r24, r18
     52e:	93 23       	and	r25, r19
     530:	00 97       	sbiw	r24, 0x00	; 0
     532:	91 f0       	breq	.+36     	; 0x558 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	89 83       	std	Y+1, r24	; 0x01
     538:	0f c0       	rjmp	.+30     	; 0x558 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
     53a:	ea 81       	ldd	r30, Y+2	; 0x02
     53c:	fb 81       	ldd	r31, Y+3	; 0x03
     53e:	20 81       	ld	r18, Z
     540:	31 81       	ldd	r19, Z+1	; 0x01
     542:	8e 81       	ldd	r24, Y+6	; 0x06
     544:	9f 81       	ldd	r25, Y+7	; 0x07
     546:	28 23       	and	r18, r24
     548:	39 23       	and	r19, r25
     54a:	8e 81       	ldd	r24, Y+6	; 0x06
     54c:	9f 81       	ldd	r25, Y+7	; 0x07
     54e:	28 17       	cp	r18, r24
     550:	39 07       	cpc	r19, r25
     552:	11 f4       	brne	.+4      	; 0x558 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
     554:	81 e0       	ldi	r24, 0x01	; 1
     556:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
     558:	89 81       	ldd	r24, Y+1	; 0x01
     55a:	88 23       	and	r24, r24
     55c:	c9 f0       	breq	.+50     	; 0x590 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
     55e:	8c 81       	ldd	r24, Y+4	; 0x04
     560:	9d 81       	ldd	r25, Y+5	; 0x05
     562:	80 70       	andi	r24, 0x00	; 0
     564:	91 70       	andi	r25, 0x01	; 1
     566:	00 97       	sbiw	r24, 0x00	; 0
     568:	41 f0       	breq	.+16     	; 0x57a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
     56a:	88 85       	ldd	r24, Y+8	; 0x08
     56c:	99 85       	ldd	r25, Y+9	; 0x09
     56e:	2e 81       	ldd	r18, Y+6	; 0x06
     570:	3f 81       	ldd	r19, Y+7	; 0x07
     572:	82 2b       	or	r24, r18
     574:	93 2b       	or	r25, r19
     576:	99 87       	std	Y+9, r25	; 0x09
     578:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
     57a:	ea 81       	ldd	r30, Y+2	; 0x02
     57c:	fb 81       	ldd	r31, Y+3	; 0x03
     57e:	80 81       	ld	r24, Z
     580:	91 81       	ldd	r25, Z+1	; 0x01
     582:	9c 01       	movw	r18, r24
     584:	32 60       	ori	r19, 0x02	; 2
     586:	88 89       	ldd	r24, Y+16	; 0x10
     588:	99 89       	ldd	r25, Y+17	; 0x11
     58a:	b9 01       	movw	r22, r18
     58c:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
     590:	8e 85       	ldd	r24, Y+14	; 0x0e
     592:	9f 85       	ldd	r25, Y+15	; 0x0f
     594:	99 8b       	std	Y+17, r25	; 0x11
     596:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
     598:	28 89       	ldd	r18, Y+16	; 0x10
     59a:	39 89       	ldd	r19, Y+17	; 0x11
     59c:	8c 85       	ldd	r24, Y+12	; 0x0c
     59e:	9d 85       	ldd	r25, Y+13	; 0x0d
     5a0:	28 17       	cp	r18, r24
     5a2:	39 07       	cpc	r19, r25
     5a4:	09 f0       	breq	.+2      	; 0x5a8 <xEventGroupSetBits+0x12a>
     5a6:	9f cf       	rjmp	.-194    	; 0x4e6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
     5a8:	ea 81       	ldd	r30, Y+2	; 0x02
     5aa:	fb 81       	ldd	r31, Y+3	; 0x03
     5ac:	20 81       	ld	r18, Z
     5ae:	31 81       	ldd	r19, Z+1	; 0x01
     5b0:	88 85       	ldd	r24, Y+8	; 0x08
     5b2:	99 85       	ldd	r25, Y+9	; 0x09
     5b4:	80 95       	com	r24
     5b6:	90 95       	com	r25
     5b8:	82 23       	and	r24, r18
     5ba:	93 23       	and	r25, r19
     5bc:	ea 81       	ldd	r30, Y+2	; 0x02
     5be:	fb 81       	ldd	r31, Y+3	; 0x03
     5c0:	91 83       	std	Z+1, r25	; 0x01
     5c2:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
     5c4:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
     5c8:	ea 81       	ldd	r30, Y+2	; 0x02
     5ca:	fb 81       	ldd	r31, Y+3	; 0x03
     5cc:	80 81       	ld	r24, Z
     5ce:	91 81       	ldd	r25, Z+1	; 0x01
}
     5d0:	65 96       	adiw	r28, 0x15	; 21
     5d2:	0f b6       	in	r0, 0x3f	; 63
     5d4:	f8 94       	cli
     5d6:	de bf       	out	0x3e, r29	; 62
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	cd bf       	out	0x3d, r28	; 61
     5dc:	cf 91       	pop	r28
     5de:	df 91       	pop	r29
     5e0:	08 95       	ret

000005e2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
     5e2:	df 93       	push	r29
     5e4:	cf 93       	push	r28
     5e6:	00 d0       	rcall	.+0      	; 0x5e8 <vEventGroupDelete+0x6>
     5e8:	00 d0       	rcall	.+0      	; 0x5ea <vEventGroupDelete+0x8>
     5ea:	00 d0       	rcall	.+0      	; 0x5ec <vEventGroupDelete+0xa>
     5ec:	cd b7       	in	r28, 0x3d	; 61
     5ee:	de b7       	in	r29, 0x3e	; 62
     5f0:	9e 83       	std	Y+6, r25	; 0x06
     5f2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
     5f4:	8d 81       	ldd	r24, Y+5	; 0x05
     5f6:	9e 81       	ldd	r25, Y+6	; 0x06
     5f8:	9c 83       	std	Y+4, r25	; 0x04
     5fa:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
     5fc:	8b 81       	ldd	r24, Y+3	; 0x03
     5fe:	9c 81       	ldd	r25, Y+4	; 0x04
     600:	02 96       	adiw	r24, 0x02	; 2
     602:	9a 83       	std	Y+2, r25	; 0x02
     604:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
     606:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
     60a:	08 c0       	rjmp	.+16     	; 0x61c <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
     60c:	e9 81       	ldd	r30, Y+1	; 0x01
     60e:	fa 81       	ldd	r31, Y+2	; 0x02
     610:	85 81       	ldd	r24, Z+5	; 0x05
     612:	96 81       	ldd	r25, Z+6	; 0x06
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	72 e0       	ldi	r23, 0x02	; 2
     618:	0e 94 71 1e 	call	0x3ce2	; 0x3ce2 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
     61c:	e9 81       	ldd	r30, Y+1	; 0x01
     61e:	fa 81       	ldd	r31, Y+2	; 0x02
     620:	80 81       	ld	r24, Z
     622:	88 23       	and	r24, r24
     624:	99 f7       	brne	.-26     	; 0x60c <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
     626:	8b 81       	ldd	r24, Y+3	; 0x03
     628:	9c 81       	ldd	r25, Y+4	; 0x04
     62a:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
     62e:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
}
     632:	26 96       	adiw	r28, 0x06	; 6
     634:	0f b6       	in	r0, 0x3f	; 63
     636:	f8 94       	cli
     638:	de bf       	out	0x3e, r29	; 62
     63a:	0f be       	out	0x3f, r0	; 63
     63c:	cd bf       	out	0x3d, r28	; 61
     63e:	cf 91       	pop	r28
     640:	df 91       	pop	r29
     642:	08 95       	ret

00000644 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
     644:	df 93       	push	r29
     646:	cf 93       	push	r28
     648:	00 d0       	rcall	.+0      	; 0x64a <vEventGroupSetBitsCallback+0x6>
     64a:	00 d0       	rcall	.+0      	; 0x64c <vEventGroupSetBitsCallback+0x8>
     64c:	00 d0       	rcall	.+0      	; 0x64e <vEventGroupSetBitsCallback+0xa>
     64e:	cd b7       	in	r28, 0x3d	; 61
     650:	de b7       	in	r29, 0x3e	; 62
     652:	9a 83       	std	Y+2, r25	; 0x02
     654:	89 83       	std	Y+1, r24	; 0x01
     656:	4b 83       	std	Y+3, r20	; 0x03
     658:	5c 83       	std	Y+4, r21	; 0x04
     65a:	6d 83       	std	Y+5, r22	; 0x05
     65c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     65e:	89 81       	ldd	r24, Y+1	; 0x01
     660:	9a 81       	ldd	r25, Y+2	; 0x02
     662:	2b 81       	ldd	r18, Y+3	; 0x03
     664:	3c 81       	ldd	r19, Y+4	; 0x04
     666:	b9 01       	movw	r22, r18
     668:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
}
     66c:	26 96       	adiw	r28, 0x06	; 6
     66e:	0f b6       	in	r0, 0x3f	; 63
     670:	f8 94       	cli
     672:	de bf       	out	0x3e, r29	; 62
     674:	0f be       	out	0x3f, r0	; 63
     676:	cd bf       	out	0x3d, r28	; 61
     678:	cf 91       	pop	r28
     67a:	df 91       	pop	r29
     67c:	08 95       	ret

0000067e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
     67e:	df 93       	push	r29
     680:	cf 93       	push	r28
     682:	00 d0       	rcall	.+0      	; 0x684 <vEventGroupClearBitsCallback+0x6>
     684:	00 d0       	rcall	.+0      	; 0x686 <vEventGroupClearBitsCallback+0x8>
     686:	00 d0       	rcall	.+0      	; 0x688 <vEventGroupClearBitsCallback+0xa>
     688:	cd b7       	in	r28, 0x3d	; 61
     68a:	de b7       	in	r29, 0x3e	; 62
     68c:	9a 83       	std	Y+2, r25	; 0x02
     68e:	89 83       	std	Y+1, r24	; 0x01
     690:	4b 83       	std	Y+3, r20	; 0x03
     692:	5c 83       	std	Y+4, r21	; 0x04
     694:	6d 83       	std	Y+5, r22	; 0x05
     696:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
     698:	89 81       	ldd	r24, Y+1	; 0x01
     69a:	9a 81       	ldd	r25, Y+2	; 0x02
     69c:	2b 81       	ldd	r18, Y+3	; 0x03
     69e:	3c 81       	ldd	r19, Y+4	; 0x04
     6a0:	b9 01       	movw	r22, r18
     6a2:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
}
     6a6:	26 96       	adiw	r28, 0x06	; 6
     6a8:	0f b6       	in	r0, 0x3f	; 63
     6aa:	f8 94       	cli
     6ac:	de bf       	out	0x3e, r29	; 62
     6ae:	0f be       	out	0x3f, r0	; 63
     6b0:	cd bf       	out	0x3d, r28	; 61
     6b2:	cf 91       	pop	r28
     6b4:	df 91       	pop	r29
     6b6:	08 95       	ret

000006b8 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
     6b8:	df 93       	push	r29
     6ba:	cf 93       	push	r28
     6bc:	00 d0       	rcall	.+0      	; 0x6be <prvTestWaitCondition+0x6>
     6be:	00 d0       	rcall	.+0      	; 0x6c0 <prvTestWaitCondition+0x8>
     6c0:	00 d0       	rcall	.+0      	; 0x6c2 <prvTestWaitCondition+0xa>
     6c2:	cd b7       	in	r28, 0x3d	; 61
     6c4:	de b7       	in	r29, 0x3e	; 62
     6c6:	9b 83       	std	Y+3, r25	; 0x03
     6c8:	8a 83       	std	Y+2, r24	; 0x02
     6ca:	7d 83       	std	Y+5, r23	; 0x05
     6cc:	6c 83       	std	Y+4, r22	; 0x04
     6ce:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
     6d0:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
     6d2:	8e 81       	ldd	r24, Y+6	; 0x06
     6d4:	88 23       	and	r24, r24
     6d6:	59 f4       	brne	.+22     	; 0x6ee <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
     6d8:	8a 81       	ldd	r24, Y+2	; 0x02
     6da:	9b 81       	ldd	r25, Y+3	; 0x03
     6dc:	2c 81       	ldd	r18, Y+4	; 0x04
     6de:	3d 81       	ldd	r19, Y+5	; 0x05
     6e0:	82 23       	and	r24, r18
     6e2:	93 23       	and	r25, r19
     6e4:	00 97       	sbiw	r24, 0x00	; 0
     6e6:	81 f0       	breq	.+32     	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     6e8:	81 e0       	ldi	r24, 0x01	; 1
     6ea:	89 83       	std	Y+1, r24	; 0x01
     6ec:	0d c0       	rjmp	.+26     	; 0x708 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
     6ee:	2a 81       	ldd	r18, Y+2	; 0x02
     6f0:	3b 81       	ldd	r19, Y+3	; 0x03
     6f2:	8c 81       	ldd	r24, Y+4	; 0x04
     6f4:	9d 81       	ldd	r25, Y+5	; 0x05
     6f6:	28 23       	and	r18, r24
     6f8:	39 23       	and	r19, r25
     6fa:	8c 81       	ldd	r24, Y+4	; 0x04
     6fc:	9d 81       	ldd	r25, Y+5	; 0x05
     6fe:	28 17       	cp	r18, r24
     700:	39 07       	cpc	r19, r25
     702:	11 f4       	brne	.+4      	; 0x708 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
     708:	89 81       	ldd	r24, Y+1	; 0x01
}
     70a:	26 96       	adiw	r28, 0x06	; 6
     70c:	0f b6       	in	r0, 0x3f	; 63
     70e:	f8 94       	cli
     710:	de bf       	out	0x3e, r29	; 62
     712:	0f be       	out	0x3f, r0	; 63
     714:	cd bf       	out	0x3d, r28	; 61
     716:	cf 91       	pop	r28
     718:	df 91       	pop	r29
     71a:	08 95       	ret

0000071c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     71c:	df 93       	push	r29
     71e:	cf 93       	push	r28
     720:	00 d0       	rcall	.+0      	; 0x722 <pvPortMalloc+0x6>
     722:	00 d0       	rcall	.+0      	; 0x724 <pvPortMalloc+0x8>
     724:	cd b7       	in	r28, 0x3d	; 61
     726:	de b7       	in	r29, 0x3e	; 62
     728:	9c 83       	std	Y+4, r25	; 0x04
     72a:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
     72c:	1a 82       	std	Y+2, r1	; 0x02
     72e:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
     730:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     734:	80 91 0a 01 	lds	r24, 0x010A
     738:	90 91 0b 01 	lds	r25, 0x010B
     73c:	00 97       	sbiw	r24, 0x00	; 0
     73e:	31 f4       	brne	.+12     	; 0x74c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     740:	8d e0       	ldi	r24, 0x0D	; 13
     742:	91 e0       	ldi	r25, 0x01	; 1
     744:	90 93 0b 01 	sts	0x010B, r25
     748:	80 93 0a 01 	sts	0x010A, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     74c:	80 91 08 01 	lds	r24, 0x0108
     750:	90 91 09 01 	lds	r25, 0x0109
     754:	2b 81       	ldd	r18, Y+3	; 0x03
     756:	3c 81       	ldd	r19, Y+4	; 0x04
     758:	82 0f       	add	r24, r18
     75a:	93 1f       	adc	r25, r19
     75c:	25 e0       	ldi	r18, 0x05	; 5
     75e:	8b 3d       	cpi	r24, 0xDB	; 219
     760:	92 07       	cpc	r25, r18
     762:	38 f5       	brcc	.+78     	; 0x7b2 <pvPortMalloc+0x96>
     764:	20 91 08 01 	lds	r18, 0x0108
     768:	30 91 09 01 	lds	r19, 0x0109
     76c:	8b 81       	ldd	r24, Y+3	; 0x03
     76e:	9c 81       	ldd	r25, Y+4	; 0x04
     770:	28 0f       	add	r18, r24
     772:	39 1f       	adc	r19, r25
     774:	80 91 08 01 	lds	r24, 0x0108
     778:	90 91 09 01 	lds	r25, 0x0109
     77c:	82 17       	cp	r24, r18
     77e:	93 07       	cpc	r25, r19
     780:	c0 f4       	brcc	.+48     	; 0x7b2 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     782:	20 91 0a 01 	lds	r18, 0x010A
     786:	30 91 0b 01 	lds	r19, 0x010B
     78a:	80 91 08 01 	lds	r24, 0x0108
     78e:	90 91 09 01 	lds	r25, 0x0109
     792:	82 0f       	add	r24, r18
     794:	93 1f       	adc	r25, r19
     796:	9a 83       	std	Y+2, r25	; 0x02
     798:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
     79a:	20 91 08 01 	lds	r18, 0x0108
     79e:	30 91 09 01 	lds	r19, 0x0109
     7a2:	8b 81       	ldd	r24, Y+3	; 0x03
     7a4:	9c 81       	ldd	r25, Y+4	; 0x04
     7a6:	82 0f       	add	r24, r18
     7a8:	93 1f       	adc	r25, r19
     7aa:	90 93 09 01 	sts	0x0109, r25
     7ae:	80 93 08 01 	sts	0x0108, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     7b2:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
     7b6:	89 81       	ldd	r24, Y+1	; 0x01
     7b8:	9a 81       	ldd	r25, Y+2	; 0x02
}
     7ba:	0f 90       	pop	r0
     7bc:	0f 90       	pop	r0
     7be:	0f 90       	pop	r0
     7c0:	0f 90       	pop	r0
     7c2:	cf 91       	pop	r28
     7c4:	df 91       	pop	r29
     7c6:	08 95       	ret

000007c8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7c8:	df 93       	push	r29
     7ca:	cf 93       	push	r28
     7cc:	00 d0       	rcall	.+0      	; 0x7ce <vPortFree+0x6>
     7ce:	cd b7       	in	r28, 0x3d	; 61
     7d0:	de b7       	in	r29, 0x3e	; 62
     7d2:	9a 83       	std	Y+2, r25	; 0x02
     7d4:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     7d6:	0f 90       	pop	r0
     7d8:	0f 90       	pop	r0
     7da:	cf 91       	pop	r28
     7dc:	df 91       	pop	r29
     7de:	08 95       	ret

000007e0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
     7e0:	df 93       	push	r29
     7e2:	cf 93       	push	r28
     7e4:	cd b7       	in	r28, 0x3d	; 61
     7e6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     7e8:	10 92 09 01 	sts	0x0109, r1
     7ec:	10 92 08 01 	sts	0x0108, r1
}
     7f0:	cf 91       	pop	r28
     7f2:	df 91       	pop	r29
     7f4:	08 95       	ret

000007f6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
     7f6:	df 93       	push	r29
     7f8:	cf 93       	push	r28
     7fa:	cd b7       	in	r28, 0x3d	; 61
     7fc:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     7fe:	20 91 08 01 	lds	r18, 0x0108
     802:	30 91 09 01 	lds	r19, 0x0109
     806:	8b ed       	ldi	r24, 0xDB	; 219
     808:	95 e0       	ldi	r25, 0x05	; 5
     80a:	82 1b       	sub	r24, r18
     80c:	93 0b       	sbc	r25, r19
}
     80e:	cf 91       	pop	r28
     810:	df 91       	pop	r29
     812:	08 95       	ret

00000814 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     814:	df 93       	push	r29
     816:	cf 93       	push	r28
     818:	00 d0       	rcall	.+0      	; 0x81a <vListInitialise+0x6>
     81a:	cd b7       	in	r28, 0x3d	; 61
     81c:	de b7       	in	r29, 0x3e	; 62
     81e:	9a 83       	std	Y+2, r25	; 0x02
     820:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     822:	89 81       	ldd	r24, Y+1	; 0x01
     824:	9a 81       	ldd	r25, Y+2	; 0x02
     826:	03 96       	adiw	r24, 0x03	; 3
     828:	e9 81       	ldd	r30, Y+1	; 0x01
     82a:	fa 81       	ldd	r31, Y+2	; 0x02
     82c:	92 83       	std	Z+2, r25	; 0x02
     82e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     830:	e9 81       	ldd	r30, Y+1	; 0x01
     832:	fa 81       	ldd	r31, Y+2	; 0x02
     834:	8f ef       	ldi	r24, 0xFF	; 255
     836:	9f ef       	ldi	r25, 0xFF	; 255
     838:	94 83       	std	Z+4, r25	; 0x04
     83a:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     83c:	89 81       	ldd	r24, Y+1	; 0x01
     83e:	9a 81       	ldd	r25, Y+2	; 0x02
     840:	03 96       	adiw	r24, 0x03	; 3
     842:	e9 81       	ldd	r30, Y+1	; 0x01
     844:	fa 81       	ldd	r31, Y+2	; 0x02
     846:	96 83       	std	Z+6, r25	; 0x06
     848:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     84a:	89 81       	ldd	r24, Y+1	; 0x01
     84c:	9a 81       	ldd	r25, Y+2	; 0x02
     84e:	03 96       	adiw	r24, 0x03	; 3
     850:	e9 81       	ldd	r30, Y+1	; 0x01
     852:	fa 81       	ldd	r31, Y+2	; 0x02
     854:	90 87       	std	Z+8, r25	; 0x08
     856:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     858:	e9 81       	ldd	r30, Y+1	; 0x01
     85a:	fa 81       	ldd	r31, Y+2	; 0x02
     85c:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
     85e:	0f 90       	pop	r0
     860:	0f 90       	pop	r0
     862:	cf 91       	pop	r28
     864:	df 91       	pop	r29
     866:	08 95       	ret

00000868 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
     868:	df 93       	push	r29
     86a:	cf 93       	push	r28
     86c:	00 d0       	rcall	.+0      	; 0x86e <vListInitialiseItem+0x6>
     86e:	cd b7       	in	r28, 0x3d	; 61
     870:	de b7       	in	r29, 0x3e	; 62
     872:	9a 83       	std	Y+2, r25	; 0x02
     874:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     876:	e9 81       	ldd	r30, Y+1	; 0x01
     878:	fa 81       	ldd	r31, Y+2	; 0x02
     87a:	11 86       	std	Z+9, r1	; 0x09
     87c:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
     87e:	0f 90       	pop	r0
     880:	0f 90       	pop	r0
     882:	cf 91       	pop	r28
     884:	df 91       	pop	r29
     886:	08 95       	ret

00000888 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     888:	df 93       	push	r29
     88a:	cf 93       	push	r28
     88c:	00 d0       	rcall	.+0      	; 0x88e <vListInsertEnd+0x6>
     88e:	00 d0       	rcall	.+0      	; 0x890 <vListInsertEnd+0x8>
     890:	00 d0       	rcall	.+0      	; 0x892 <vListInsertEnd+0xa>
     892:	cd b7       	in	r28, 0x3d	; 61
     894:	de b7       	in	r29, 0x3e	; 62
     896:	9c 83       	std	Y+4, r25	; 0x04
     898:	8b 83       	std	Y+3, r24	; 0x03
     89a:	7e 83       	std	Y+6, r23	; 0x06
     89c:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
     89e:	eb 81       	ldd	r30, Y+3	; 0x03
     8a0:	fc 81       	ldd	r31, Y+4	; 0x04
     8a2:	81 81       	ldd	r24, Z+1	; 0x01
     8a4:	92 81       	ldd	r25, Z+2	; 0x02
     8a6:	9a 83       	std	Y+2, r25	; 0x02
     8a8:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     8aa:	ed 81       	ldd	r30, Y+5	; 0x05
     8ac:	fe 81       	ldd	r31, Y+6	; 0x06
     8ae:	89 81       	ldd	r24, Y+1	; 0x01
     8b0:	9a 81       	ldd	r25, Y+2	; 0x02
     8b2:	93 83       	std	Z+3, r25	; 0x03
     8b4:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     8b6:	e9 81       	ldd	r30, Y+1	; 0x01
     8b8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ba:	84 81       	ldd	r24, Z+4	; 0x04
     8bc:	95 81       	ldd	r25, Z+5	; 0x05
     8be:	ed 81       	ldd	r30, Y+5	; 0x05
     8c0:	fe 81       	ldd	r31, Y+6	; 0x06
     8c2:	95 83       	std	Z+5, r25	; 0x05
     8c4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     8c6:	e9 81       	ldd	r30, Y+1	; 0x01
     8c8:	fa 81       	ldd	r31, Y+2	; 0x02
     8ca:	04 80       	ldd	r0, Z+4	; 0x04
     8cc:	f5 81       	ldd	r31, Z+5	; 0x05
     8ce:	e0 2d       	mov	r30, r0
     8d0:	8d 81       	ldd	r24, Y+5	; 0x05
     8d2:	9e 81       	ldd	r25, Y+6	; 0x06
     8d4:	93 83       	std	Z+3, r25	; 0x03
     8d6:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
     8d8:	e9 81       	ldd	r30, Y+1	; 0x01
     8da:	fa 81       	ldd	r31, Y+2	; 0x02
     8dc:	8d 81       	ldd	r24, Y+5	; 0x05
     8de:	9e 81       	ldd	r25, Y+6	; 0x06
     8e0:	95 83       	std	Z+5, r25	; 0x05
     8e2:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     8e4:	ed 81       	ldd	r30, Y+5	; 0x05
     8e6:	fe 81       	ldd	r31, Y+6	; 0x06
     8e8:	8b 81       	ldd	r24, Y+3	; 0x03
     8ea:	9c 81       	ldd	r25, Y+4	; 0x04
     8ec:	91 87       	std	Z+9, r25	; 0x09
     8ee:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     8f0:	eb 81       	ldd	r30, Y+3	; 0x03
     8f2:	fc 81       	ldd	r31, Y+4	; 0x04
     8f4:	80 81       	ld	r24, Z
     8f6:	8f 5f       	subi	r24, 0xFF	; 255
     8f8:	eb 81       	ldd	r30, Y+3	; 0x03
     8fa:	fc 81       	ldd	r31, Y+4	; 0x04
     8fc:	80 83       	st	Z, r24
}
     8fe:	26 96       	adiw	r28, 0x06	; 6
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	f8 94       	cli
     904:	de bf       	out	0x3e, r29	; 62
     906:	0f be       	out	0x3f, r0	; 63
     908:	cd bf       	out	0x3d, r28	; 61
     90a:	cf 91       	pop	r28
     90c:	df 91       	pop	r29
     90e:	08 95       	ret

00000910 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     910:	df 93       	push	r29
     912:	cf 93       	push	r28
     914:	cd b7       	in	r28, 0x3d	; 61
     916:	de b7       	in	r29, 0x3e	; 62
     918:	28 97       	sbiw	r28, 0x08	; 8
     91a:	0f b6       	in	r0, 0x3f	; 63
     91c:	f8 94       	cli
     91e:	de bf       	out	0x3e, r29	; 62
     920:	0f be       	out	0x3f, r0	; 63
     922:	cd bf       	out	0x3d, r28	; 61
     924:	9e 83       	std	Y+6, r25	; 0x06
     926:	8d 83       	std	Y+5, r24	; 0x05
     928:	78 87       	std	Y+8, r23	; 0x08
     92a:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     92c:	ef 81       	ldd	r30, Y+7	; 0x07
     92e:	f8 85       	ldd	r31, Y+8	; 0x08
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	9a 83       	std	Y+2, r25	; 0x02
     936:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     938:	89 81       	ldd	r24, Y+1	; 0x01
     93a:	9a 81       	ldd	r25, Y+2	; 0x02
     93c:	2f ef       	ldi	r18, 0xFF	; 255
     93e:	8f 3f       	cpi	r24, 0xFF	; 255
     940:	92 07       	cpc	r25, r18
     942:	39 f4       	brne	.+14     	; 0x952 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     944:	ed 81       	ldd	r30, Y+5	; 0x05
     946:	fe 81       	ldd	r31, Y+6	; 0x06
     948:	87 81       	ldd	r24, Z+7	; 0x07
     94a:	90 85       	ldd	r25, Z+8	; 0x08
     94c:	9c 83       	std	Y+4, r25	; 0x04
     94e:	8b 83       	std	Y+3, r24	; 0x03
     950:	18 c0       	rjmp	.+48     	; 0x982 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     952:	8d 81       	ldd	r24, Y+5	; 0x05
     954:	9e 81       	ldd	r25, Y+6	; 0x06
     956:	03 96       	adiw	r24, 0x03	; 3
     958:	9c 83       	std	Y+4, r25	; 0x04
     95a:	8b 83       	std	Y+3, r24	; 0x03
     95c:	06 c0       	rjmp	.+12     	; 0x96a <vListInsert+0x5a>
     95e:	eb 81       	ldd	r30, Y+3	; 0x03
     960:	fc 81       	ldd	r31, Y+4	; 0x04
     962:	82 81       	ldd	r24, Z+2	; 0x02
     964:	93 81       	ldd	r25, Z+3	; 0x03
     966:	9c 83       	std	Y+4, r25	; 0x04
     968:	8b 83       	std	Y+3, r24	; 0x03
     96a:	eb 81       	ldd	r30, Y+3	; 0x03
     96c:	fc 81       	ldd	r31, Y+4	; 0x04
     96e:	02 80       	ldd	r0, Z+2	; 0x02
     970:	f3 81       	ldd	r31, Z+3	; 0x03
     972:	e0 2d       	mov	r30, r0
     974:	20 81       	ld	r18, Z
     976:	31 81       	ldd	r19, Z+1	; 0x01
     978:	89 81       	ldd	r24, Y+1	; 0x01
     97a:	9a 81       	ldd	r25, Y+2	; 0x02
     97c:	82 17       	cp	r24, r18
     97e:	93 07       	cpc	r25, r19
     980:	70 f7       	brcc	.-36     	; 0x95e <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     982:	eb 81       	ldd	r30, Y+3	; 0x03
     984:	fc 81       	ldd	r31, Y+4	; 0x04
     986:	82 81       	ldd	r24, Z+2	; 0x02
     988:	93 81       	ldd	r25, Z+3	; 0x03
     98a:	ef 81       	ldd	r30, Y+7	; 0x07
     98c:	f8 85       	ldd	r31, Y+8	; 0x08
     98e:	93 83       	std	Z+3, r25	; 0x03
     990:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     992:	ef 81       	ldd	r30, Y+7	; 0x07
     994:	f8 85       	ldd	r31, Y+8	; 0x08
     996:	02 80       	ldd	r0, Z+2	; 0x02
     998:	f3 81       	ldd	r31, Z+3	; 0x03
     99a:	e0 2d       	mov	r30, r0
     99c:	8f 81       	ldd	r24, Y+7	; 0x07
     99e:	98 85       	ldd	r25, Y+8	; 0x08
     9a0:	95 83       	std	Z+5, r25	; 0x05
     9a2:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     9a4:	ef 81       	ldd	r30, Y+7	; 0x07
     9a6:	f8 85       	ldd	r31, Y+8	; 0x08
     9a8:	8b 81       	ldd	r24, Y+3	; 0x03
     9aa:	9c 81       	ldd	r25, Y+4	; 0x04
     9ac:	95 83       	std	Z+5, r25	; 0x05
     9ae:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
     9b0:	eb 81       	ldd	r30, Y+3	; 0x03
     9b2:	fc 81       	ldd	r31, Y+4	; 0x04
     9b4:	8f 81       	ldd	r24, Y+7	; 0x07
     9b6:	98 85       	ldd	r25, Y+8	; 0x08
     9b8:	93 83       	std	Z+3, r25	; 0x03
     9ba:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
     9bc:	ef 81       	ldd	r30, Y+7	; 0x07
     9be:	f8 85       	ldd	r31, Y+8	; 0x08
     9c0:	8d 81       	ldd	r24, Y+5	; 0x05
     9c2:	9e 81       	ldd	r25, Y+6	; 0x06
     9c4:	91 87       	std	Z+9, r25	; 0x09
     9c6:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     9c8:	ed 81       	ldd	r30, Y+5	; 0x05
     9ca:	fe 81       	ldd	r31, Y+6	; 0x06
     9cc:	80 81       	ld	r24, Z
     9ce:	8f 5f       	subi	r24, 0xFF	; 255
     9d0:	ed 81       	ldd	r30, Y+5	; 0x05
     9d2:	fe 81       	ldd	r31, Y+6	; 0x06
     9d4:	80 83       	st	Z, r24
}
     9d6:	28 96       	adiw	r28, 0x08	; 8
     9d8:	0f b6       	in	r0, 0x3f	; 63
     9da:	f8 94       	cli
     9dc:	de bf       	out	0x3e, r29	; 62
     9de:	0f be       	out	0x3f, r0	; 63
     9e0:	cd bf       	out	0x3d, r28	; 61
     9e2:	cf 91       	pop	r28
     9e4:	df 91       	pop	r29
     9e6:	08 95       	ret

000009e8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     9e8:	df 93       	push	r29
     9ea:	cf 93       	push	r28
     9ec:	00 d0       	rcall	.+0      	; 0x9ee <uxListRemove+0x6>
     9ee:	00 d0       	rcall	.+0      	; 0x9f0 <uxListRemove+0x8>
     9f0:	cd b7       	in	r28, 0x3d	; 61
     9f2:	de b7       	in	r29, 0x3e	; 62
     9f4:	9c 83       	std	Y+4, r25	; 0x04
     9f6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
     9f8:	eb 81       	ldd	r30, Y+3	; 0x03
     9fa:	fc 81       	ldd	r31, Y+4	; 0x04
     9fc:	80 85       	ldd	r24, Z+8	; 0x08
     9fe:	91 85       	ldd	r25, Z+9	; 0x09
     a00:	9a 83       	std	Y+2, r25	; 0x02
     a02:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     a04:	eb 81       	ldd	r30, Y+3	; 0x03
     a06:	fc 81       	ldd	r31, Y+4	; 0x04
     a08:	a2 81       	ldd	r26, Z+2	; 0x02
     a0a:	b3 81       	ldd	r27, Z+3	; 0x03
     a0c:	eb 81       	ldd	r30, Y+3	; 0x03
     a0e:	fc 81       	ldd	r31, Y+4	; 0x04
     a10:	84 81       	ldd	r24, Z+4	; 0x04
     a12:	95 81       	ldd	r25, Z+5	; 0x05
     a14:	15 96       	adiw	r26, 0x05	; 5
     a16:	9c 93       	st	X, r25
     a18:	8e 93       	st	-X, r24
     a1a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     a1c:	eb 81       	ldd	r30, Y+3	; 0x03
     a1e:	fc 81       	ldd	r31, Y+4	; 0x04
     a20:	a4 81       	ldd	r26, Z+4	; 0x04
     a22:	b5 81       	ldd	r27, Z+5	; 0x05
     a24:	eb 81       	ldd	r30, Y+3	; 0x03
     a26:	fc 81       	ldd	r31, Y+4	; 0x04
     a28:	82 81       	ldd	r24, Z+2	; 0x02
     a2a:	93 81       	ldd	r25, Z+3	; 0x03
     a2c:	13 96       	adiw	r26, 0x03	; 3
     a2e:	9c 93       	st	X, r25
     a30:	8e 93       	st	-X, r24
     a32:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     a34:	e9 81       	ldd	r30, Y+1	; 0x01
     a36:	fa 81       	ldd	r31, Y+2	; 0x02
     a38:	21 81       	ldd	r18, Z+1	; 0x01
     a3a:	32 81       	ldd	r19, Z+2	; 0x02
     a3c:	8b 81       	ldd	r24, Y+3	; 0x03
     a3e:	9c 81       	ldd	r25, Y+4	; 0x04
     a40:	28 17       	cp	r18, r24
     a42:	39 07       	cpc	r19, r25
     a44:	41 f4       	brne	.+16     	; 0xa56 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     a46:	eb 81       	ldd	r30, Y+3	; 0x03
     a48:	fc 81       	ldd	r31, Y+4	; 0x04
     a4a:	84 81       	ldd	r24, Z+4	; 0x04
     a4c:	95 81       	ldd	r25, Z+5	; 0x05
     a4e:	e9 81       	ldd	r30, Y+1	; 0x01
     a50:	fa 81       	ldd	r31, Y+2	; 0x02
     a52:	92 83       	std	Z+2, r25	; 0x02
     a54:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
     a56:	eb 81       	ldd	r30, Y+3	; 0x03
     a58:	fc 81       	ldd	r31, Y+4	; 0x04
     a5a:	11 86       	std	Z+9, r1	; 0x09
     a5c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     a5e:	e9 81       	ldd	r30, Y+1	; 0x01
     a60:	fa 81       	ldd	r31, Y+2	; 0x02
     a62:	80 81       	ld	r24, Z
     a64:	81 50       	subi	r24, 0x01	; 1
     a66:	e9 81       	ldd	r30, Y+1	; 0x01
     a68:	fa 81       	ldd	r31, Y+2	; 0x02
     a6a:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
     a6c:	e9 81       	ldd	r30, Y+1	; 0x01
     a6e:	fa 81       	ldd	r31, Y+2	; 0x02
     a70:	80 81       	ld	r24, Z
}
     a72:	0f 90       	pop	r0
     a74:	0f 90       	pop	r0
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	cf 91       	pop	r28
     a7c:	df 91       	pop	r29
     a7e:	08 95       	ret

00000a80 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
     a80:	df 93       	push	r29
     a82:	cf 93       	push	r28
     a84:	cd b7       	in	r28, 0x3d	; 61
     a86:	de b7       	in	r29, 0x3e	; 62
     a88:	28 97       	sbiw	r28, 0x08	; 8
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	de bf       	out	0x3e, r29	; 62
     a90:	0f be       	out	0x3f, r0	; 63
     a92:	cd bf       	out	0x3d, r28	; 61
     a94:	9c 83       	std	Y+4, r25	; 0x04
     a96:	8b 83       	std	Y+3, r24	; 0x03
     a98:	7e 83       	std	Y+6, r23	; 0x06
     a9a:	6d 83       	std	Y+5, r22	; 0x05
     a9c:	58 87       	std	Y+8, r21	; 0x08
     a9e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     aa0:	eb 81       	ldd	r30, Y+3	; 0x03
     aa2:	fc 81       	ldd	r31, Y+4	; 0x04
     aa4:	81 e1       	ldi	r24, 0x11	; 17
     aa6:	80 83       	st	Z, r24
	pxTopOfStack--;
     aa8:	8b 81       	ldd	r24, Y+3	; 0x03
     aaa:	9c 81       	ldd	r25, Y+4	; 0x04
     aac:	01 97       	sbiw	r24, 0x01	; 1
     aae:	9c 83       	std	Y+4, r25	; 0x04
     ab0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
     ab2:	eb 81       	ldd	r30, Y+3	; 0x03
     ab4:	fc 81       	ldd	r31, Y+4	; 0x04
     ab6:	82 e2       	ldi	r24, 0x22	; 34
     ab8:	80 83       	st	Z, r24
	pxTopOfStack--;
     aba:	8b 81       	ldd	r24, Y+3	; 0x03
     abc:	9c 81       	ldd	r25, Y+4	; 0x04
     abe:	01 97       	sbiw	r24, 0x01	; 1
     ac0:	9c 83       	std	Y+4, r25	; 0x04
     ac2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
     ac4:	eb 81       	ldd	r30, Y+3	; 0x03
     ac6:	fc 81       	ldd	r31, Y+4	; 0x04
     ac8:	83 e3       	ldi	r24, 0x33	; 51
     aca:	80 83       	st	Z, r24
	pxTopOfStack--;
     acc:	8b 81       	ldd	r24, Y+3	; 0x03
     ace:	9c 81       	ldd	r25, Y+4	; 0x04
     ad0:	01 97       	sbiw	r24, 0x01	; 1
     ad2:	9c 83       	std	Y+4, r25	; 0x04
     ad4:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
     ad6:	8d 81       	ldd	r24, Y+5	; 0x05
     ad8:	9e 81       	ldd	r25, Y+6	; 0x06
     ada:	9a 83       	std	Y+2, r25	; 0x02
     adc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     ade:	89 81       	ldd	r24, Y+1	; 0x01
     ae0:	eb 81       	ldd	r30, Y+3	; 0x03
     ae2:	fc 81       	ldd	r31, Y+4	; 0x04
     ae4:	80 83       	st	Z, r24
	pxTopOfStack--;
     ae6:	8b 81       	ldd	r24, Y+3	; 0x03
     ae8:	9c 81       	ldd	r25, Y+4	; 0x04
     aea:	01 97       	sbiw	r24, 0x01	; 1
     aec:	9c 83       	std	Y+4, r25	; 0x04
     aee:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	9a 81       	ldd	r25, Y+2	; 0x02
     af4:	89 2f       	mov	r24, r25
     af6:	99 27       	eor	r25, r25
     af8:	9a 83       	std	Y+2, r25	; 0x02
     afa:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     afc:	89 81       	ldd	r24, Y+1	; 0x01
     afe:	eb 81       	ldd	r30, Y+3	; 0x03
     b00:	fc 81       	ldd	r31, Y+4	; 0x04
     b02:	80 83       	st	Z, r24
	pxTopOfStack--;
     b04:	8b 81       	ldd	r24, Y+3	; 0x03
     b06:	9c 81       	ldd	r25, Y+4	; 0x04
     b08:	01 97       	sbiw	r24, 0x01	; 1
     b0a:	9c 83       	std	Y+4, r25	; 0x04
     b0c:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     b0e:	eb 81       	ldd	r30, Y+3	; 0x03
     b10:	fc 81       	ldd	r31, Y+4	; 0x04
     b12:	10 82       	st	Z, r1
	pxTopOfStack--;
     b14:	8b 81       	ldd	r24, Y+3	; 0x03
     b16:	9c 81       	ldd	r25, Y+4	; 0x04
     b18:	01 97       	sbiw	r24, 0x01	; 1
     b1a:	9c 83       	std	Y+4, r25	; 0x04
     b1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     b1e:	eb 81       	ldd	r30, Y+3	; 0x03
     b20:	fc 81       	ldd	r31, Y+4	; 0x04
     b22:	80 e8       	ldi	r24, 0x80	; 128
     b24:	80 83       	st	Z, r24
	pxTopOfStack--;
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	9c 81       	ldd	r25, Y+4	; 0x04
     b2a:	01 97       	sbiw	r24, 0x01	; 1
     b2c:	9c 83       	std	Y+4, r25	; 0x04
     b2e:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     b30:	eb 81       	ldd	r30, Y+3	; 0x03
     b32:	fc 81       	ldd	r31, Y+4	; 0x04
     b34:	10 82       	st	Z, r1
	pxTopOfStack--;
     b36:	8b 81       	ldd	r24, Y+3	; 0x03
     b38:	9c 81       	ldd	r25, Y+4	; 0x04
     b3a:	01 97       	sbiw	r24, 0x01	; 1
     b3c:	9c 83       	std	Y+4, r25	; 0x04
     b3e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     b40:	eb 81       	ldd	r30, Y+3	; 0x03
     b42:	fc 81       	ldd	r31, Y+4	; 0x04
     b44:	82 e0       	ldi	r24, 0x02	; 2
     b46:	80 83       	st	Z, r24
	pxTopOfStack--;
     b48:	8b 81       	ldd	r24, Y+3	; 0x03
     b4a:	9c 81       	ldd	r25, Y+4	; 0x04
     b4c:	01 97       	sbiw	r24, 0x01	; 1
     b4e:	9c 83       	std	Y+4, r25	; 0x04
     b50:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     b52:	eb 81       	ldd	r30, Y+3	; 0x03
     b54:	fc 81       	ldd	r31, Y+4	; 0x04
     b56:	83 e0       	ldi	r24, 0x03	; 3
     b58:	80 83       	st	Z, r24
	pxTopOfStack--;
     b5a:	8b 81       	ldd	r24, Y+3	; 0x03
     b5c:	9c 81       	ldd	r25, Y+4	; 0x04
     b5e:	01 97       	sbiw	r24, 0x01	; 1
     b60:	9c 83       	std	Y+4, r25	; 0x04
     b62:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     b64:	eb 81       	ldd	r30, Y+3	; 0x03
     b66:	fc 81       	ldd	r31, Y+4	; 0x04
     b68:	84 e0       	ldi	r24, 0x04	; 4
     b6a:	80 83       	st	Z, r24
	pxTopOfStack--;
     b6c:	8b 81       	ldd	r24, Y+3	; 0x03
     b6e:	9c 81       	ldd	r25, Y+4	; 0x04
     b70:	01 97       	sbiw	r24, 0x01	; 1
     b72:	9c 83       	std	Y+4, r25	; 0x04
     b74:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     b76:	eb 81       	ldd	r30, Y+3	; 0x03
     b78:	fc 81       	ldd	r31, Y+4	; 0x04
     b7a:	85 e0       	ldi	r24, 0x05	; 5
     b7c:	80 83       	st	Z, r24
	pxTopOfStack--;
     b7e:	8b 81       	ldd	r24, Y+3	; 0x03
     b80:	9c 81       	ldd	r25, Y+4	; 0x04
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	9c 83       	std	Y+4, r25	; 0x04
     b86:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     b88:	eb 81       	ldd	r30, Y+3	; 0x03
     b8a:	fc 81       	ldd	r31, Y+4	; 0x04
     b8c:	86 e0       	ldi	r24, 0x06	; 6
     b8e:	80 83       	st	Z, r24
	pxTopOfStack--;
     b90:	8b 81       	ldd	r24, Y+3	; 0x03
     b92:	9c 81       	ldd	r25, Y+4	; 0x04
     b94:	01 97       	sbiw	r24, 0x01	; 1
     b96:	9c 83       	std	Y+4, r25	; 0x04
     b98:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     b9a:	eb 81       	ldd	r30, Y+3	; 0x03
     b9c:	fc 81       	ldd	r31, Y+4	; 0x04
     b9e:	87 e0       	ldi	r24, 0x07	; 7
     ba0:	80 83       	st	Z, r24
	pxTopOfStack--;
     ba2:	8b 81       	ldd	r24, Y+3	; 0x03
     ba4:	9c 81       	ldd	r25, Y+4	; 0x04
     ba6:	01 97       	sbiw	r24, 0x01	; 1
     ba8:	9c 83       	std	Y+4, r25	; 0x04
     baa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     bac:	eb 81       	ldd	r30, Y+3	; 0x03
     bae:	fc 81       	ldd	r31, Y+4	; 0x04
     bb0:	88 e0       	ldi	r24, 0x08	; 8
     bb2:	80 83       	st	Z, r24
	pxTopOfStack--;
     bb4:	8b 81       	ldd	r24, Y+3	; 0x03
     bb6:	9c 81       	ldd	r25, Y+4	; 0x04
     bb8:	01 97       	sbiw	r24, 0x01	; 1
     bba:	9c 83       	std	Y+4, r25	; 0x04
     bbc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     bbe:	eb 81       	ldd	r30, Y+3	; 0x03
     bc0:	fc 81       	ldd	r31, Y+4	; 0x04
     bc2:	89 e0       	ldi	r24, 0x09	; 9
     bc4:	80 83       	st	Z, r24
	pxTopOfStack--;
     bc6:	8b 81       	ldd	r24, Y+3	; 0x03
     bc8:	9c 81       	ldd	r25, Y+4	; 0x04
     bca:	01 97       	sbiw	r24, 0x01	; 1
     bcc:	9c 83       	std	Y+4, r25	; 0x04
     bce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     bd0:	eb 81       	ldd	r30, Y+3	; 0x03
     bd2:	fc 81       	ldd	r31, Y+4	; 0x04
     bd4:	80 e1       	ldi	r24, 0x10	; 16
     bd6:	80 83       	st	Z, r24
	pxTopOfStack--;
     bd8:	8b 81       	ldd	r24, Y+3	; 0x03
     bda:	9c 81       	ldd	r25, Y+4	; 0x04
     bdc:	01 97       	sbiw	r24, 0x01	; 1
     bde:	9c 83       	std	Y+4, r25	; 0x04
     be0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     be2:	eb 81       	ldd	r30, Y+3	; 0x03
     be4:	fc 81       	ldd	r31, Y+4	; 0x04
     be6:	81 e1       	ldi	r24, 0x11	; 17
     be8:	80 83       	st	Z, r24
	pxTopOfStack--;
     bea:	8b 81       	ldd	r24, Y+3	; 0x03
     bec:	9c 81       	ldd	r25, Y+4	; 0x04
     bee:	01 97       	sbiw	r24, 0x01	; 1
     bf0:	9c 83       	std	Y+4, r25	; 0x04
     bf2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     bf4:	eb 81       	ldd	r30, Y+3	; 0x03
     bf6:	fc 81       	ldd	r31, Y+4	; 0x04
     bf8:	82 e1       	ldi	r24, 0x12	; 18
     bfa:	80 83       	st	Z, r24
	pxTopOfStack--;
     bfc:	8b 81       	ldd	r24, Y+3	; 0x03
     bfe:	9c 81       	ldd	r25, Y+4	; 0x04
     c00:	01 97       	sbiw	r24, 0x01	; 1
     c02:	9c 83       	std	Y+4, r25	; 0x04
     c04:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     c06:	eb 81       	ldd	r30, Y+3	; 0x03
     c08:	fc 81       	ldd	r31, Y+4	; 0x04
     c0a:	83 e1       	ldi	r24, 0x13	; 19
     c0c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c0e:	8b 81       	ldd	r24, Y+3	; 0x03
     c10:	9c 81       	ldd	r25, Y+4	; 0x04
     c12:	01 97       	sbiw	r24, 0x01	; 1
     c14:	9c 83       	std	Y+4, r25	; 0x04
     c16:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     c18:	eb 81       	ldd	r30, Y+3	; 0x03
     c1a:	fc 81       	ldd	r31, Y+4	; 0x04
     c1c:	84 e1       	ldi	r24, 0x14	; 20
     c1e:	80 83       	st	Z, r24
	pxTopOfStack--;
     c20:	8b 81       	ldd	r24, Y+3	; 0x03
     c22:	9c 81       	ldd	r25, Y+4	; 0x04
     c24:	01 97       	sbiw	r24, 0x01	; 1
     c26:	9c 83       	std	Y+4, r25	; 0x04
     c28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     c2a:	eb 81       	ldd	r30, Y+3	; 0x03
     c2c:	fc 81       	ldd	r31, Y+4	; 0x04
     c2e:	85 e1       	ldi	r24, 0x15	; 21
     c30:	80 83       	st	Z, r24
	pxTopOfStack--;
     c32:	8b 81       	ldd	r24, Y+3	; 0x03
     c34:	9c 81       	ldd	r25, Y+4	; 0x04
     c36:	01 97       	sbiw	r24, 0x01	; 1
     c38:	9c 83       	std	Y+4, r25	; 0x04
     c3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     c3c:	eb 81       	ldd	r30, Y+3	; 0x03
     c3e:	fc 81       	ldd	r31, Y+4	; 0x04
     c40:	86 e1       	ldi	r24, 0x16	; 22
     c42:	80 83       	st	Z, r24
	pxTopOfStack--;
     c44:	8b 81       	ldd	r24, Y+3	; 0x03
     c46:	9c 81       	ldd	r25, Y+4	; 0x04
     c48:	01 97       	sbiw	r24, 0x01	; 1
     c4a:	9c 83       	std	Y+4, r25	; 0x04
     c4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     c4e:	eb 81       	ldd	r30, Y+3	; 0x03
     c50:	fc 81       	ldd	r31, Y+4	; 0x04
     c52:	87 e1       	ldi	r24, 0x17	; 23
     c54:	80 83       	st	Z, r24
	pxTopOfStack--;
     c56:	8b 81       	ldd	r24, Y+3	; 0x03
     c58:	9c 81       	ldd	r25, Y+4	; 0x04
     c5a:	01 97       	sbiw	r24, 0x01	; 1
     c5c:	9c 83       	std	Y+4, r25	; 0x04
     c5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     c60:	eb 81       	ldd	r30, Y+3	; 0x03
     c62:	fc 81       	ldd	r31, Y+4	; 0x04
     c64:	88 e1       	ldi	r24, 0x18	; 24
     c66:	80 83       	st	Z, r24
	pxTopOfStack--;
     c68:	8b 81       	ldd	r24, Y+3	; 0x03
     c6a:	9c 81       	ldd	r25, Y+4	; 0x04
     c6c:	01 97       	sbiw	r24, 0x01	; 1
     c6e:	9c 83       	std	Y+4, r25	; 0x04
     c70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     c72:	eb 81       	ldd	r30, Y+3	; 0x03
     c74:	fc 81       	ldd	r31, Y+4	; 0x04
     c76:	89 e1       	ldi	r24, 0x19	; 25
     c78:	80 83       	st	Z, r24
	pxTopOfStack--;
     c7a:	8b 81       	ldd	r24, Y+3	; 0x03
     c7c:	9c 81       	ldd	r25, Y+4	; 0x04
     c7e:	01 97       	sbiw	r24, 0x01	; 1
     c80:	9c 83       	std	Y+4, r25	; 0x04
     c82:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     c84:	eb 81       	ldd	r30, Y+3	; 0x03
     c86:	fc 81       	ldd	r31, Y+4	; 0x04
     c88:	80 e2       	ldi	r24, 0x20	; 32
     c8a:	80 83       	st	Z, r24
	pxTopOfStack--;
     c8c:	8b 81       	ldd	r24, Y+3	; 0x03
     c8e:	9c 81       	ldd	r25, Y+4	; 0x04
     c90:	01 97       	sbiw	r24, 0x01	; 1
     c92:	9c 83       	std	Y+4, r25	; 0x04
     c94:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     c96:	eb 81       	ldd	r30, Y+3	; 0x03
     c98:	fc 81       	ldd	r31, Y+4	; 0x04
     c9a:	81 e2       	ldi	r24, 0x21	; 33
     c9c:	80 83       	st	Z, r24
	pxTopOfStack--;
     c9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ca0:	9c 81       	ldd	r25, Y+4	; 0x04
     ca2:	01 97       	sbiw	r24, 0x01	; 1
     ca4:	9c 83       	std	Y+4, r25	; 0x04
     ca6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     ca8:	eb 81       	ldd	r30, Y+3	; 0x03
     caa:	fc 81       	ldd	r31, Y+4	; 0x04
     cac:	82 e2       	ldi	r24, 0x22	; 34
     cae:	80 83       	st	Z, r24
	pxTopOfStack--;
     cb0:	8b 81       	ldd	r24, Y+3	; 0x03
     cb2:	9c 81       	ldd	r25, Y+4	; 0x04
     cb4:	01 97       	sbiw	r24, 0x01	; 1
     cb6:	9c 83       	std	Y+4, r25	; 0x04
     cb8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     cba:	eb 81       	ldd	r30, Y+3	; 0x03
     cbc:	fc 81       	ldd	r31, Y+4	; 0x04
     cbe:	83 e2       	ldi	r24, 0x23	; 35
     cc0:	80 83       	st	Z, r24
	pxTopOfStack--;
     cc2:	8b 81       	ldd	r24, Y+3	; 0x03
     cc4:	9c 81       	ldd	r25, Y+4	; 0x04
     cc6:	01 97       	sbiw	r24, 0x01	; 1
     cc8:	9c 83       	std	Y+4, r25	; 0x04
     cca:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
     ccc:	8f 81       	ldd	r24, Y+7	; 0x07
     cce:	98 85       	ldd	r25, Y+8	; 0x08
     cd0:	9a 83       	std	Y+2, r25	; 0x02
     cd2:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
     cd6:	eb 81       	ldd	r30, Y+3	; 0x03
     cd8:	fc 81       	ldd	r31, Y+4	; 0x04
     cda:	80 83       	st	Z, r24
	pxTopOfStack--;
     cdc:	8b 81       	ldd	r24, Y+3	; 0x03
     cde:	9c 81       	ldd	r25, Y+4	; 0x04
     ce0:	01 97       	sbiw	r24, 0x01	; 1
     ce2:	9c 83       	std	Y+4, r25	; 0x04
     ce4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
     ce6:	89 81       	ldd	r24, Y+1	; 0x01
     ce8:	9a 81       	ldd	r25, Y+2	; 0x02
     cea:	89 2f       	mov	r24, r25
     cec:	99 27       	eor	r25, r25
     cee:	9a 83       	std	Y+2, r25	; 0x02
     cf0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     cf2:	89 81       	ldd	r24, Y+1	; 0x01
     cf4:	eb 81       	ldd	r30, Y+3	; 0x03
     cf6:	fc 81       	ldd	r31, Y+4	; 0x04
     cf8:	80 83       	st	Z, r24
	pxTopOfStack--;
     cfa:	8b 81       	ldd	r24, Y+3	; 0x03
     cfc:	9c 81       	ldd	r25, Y+4	; 0x04
     cfe:	01 97       	sbiw	r24, 0x01	; 1
     d00:	9c 83       	std	Y+4, r25	; 0x04
     d02:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     d04:	eb 81       	ldd	r30, Y+3	; 0x03
     d06:	fc 81       	ldd	r31, Y+4	; 0x04
     d08:	86 e2       	ldi	r24, 0x26	; 38
     d0a:	80 83       	st	Z, r24
	pxTopOfStack--;
     d0c:	8b 81       	ldd	r24, Y+3	; 0x03
     d0e:	9c 81       	ldd	r25, Y+4	; 0x04
     d10:	01 97       	sbiw	r24, 0x01	; 1
     d12:	9c 83       	std	Y+4, r25	; 0x04
     d14:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     d16:	eb 81       	ldd	r30, Y+3	; 0x03
     d18:	fc 81       	ldd	r31, Y+4	; 0x04
     d1a:	87 e2       	ldi	r24, 0x27	; 39
     d1c:	80 83       	st	Z, r24
	pxTopOfStack--;
     d1e:	8b 81       	ldd	r24, Y+3	; 0x03
     d20:	9c 81       	ldd	r25, Y+4	; 0x04
     d22:	01 97       	sbiw	r24, 0x01	; 1
     d24:	9c 83       	std	Y+4, r25	; 0x04
     d26:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     d28:	eb 81       	ldd	r30, Y+3	; 0x03
     d2a:	fc 81       	ldd	r31, Y+4	; 0x04
     d2c:	88 e2       	ldi	r24, 0x28	; 40
     d2e:	80 83       	st	Z, r24
	pxTopOfStack--;
     d30:	8b 81       	ldd	r24, Y+3	; 0x03
     d32:	9c 81       	ldd	r25, Y+4	; 0x04
     d34:	01 97       	sbiw	r24, 0x01	; 1
     d36:	9c 83       	std	Y+4, r25	; 0x04
     d38:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     d3a:	eb 81       	ldd	r30, Y+3	; 0x03
     d3c:	fc 81       	ldd	r31, Y+4	; 0x04
     d3e:	89 e2       	ldi	r24, 0x29	; 41
     d40:	80 83       	st	Z, r24
	pxTopOfStack--;
     d42:	8b 81       	ldd	r24, Y+3	; 0x03
     d44:	9c 81       	ldd	r25, Y+4	; 0x04
     d46:	01 97       	sbiw	r24, 0x01	; 1
     d48:	9c 83       	std	Y+4, r25	; 0x04
     d4a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     d4c:	eb 81       	ldd	r30, Y+3	; 0x03
     d4e:	fc 81       	ldd	r31, Y+4	; 0x04
     d50:	80 e3       	ldi	r24, 0x30	; 48
     d52:	80 83       	st	Z, r24
	pxTopOfStack--;
     d54:	8b 81       	ldd	r24, Y+3	; 0x03
     d56:	9c 81       	ldd	r25, Y+4	; 0x04
     d58:	01 97       	sbiw	r24, 0x01	; 1
     d5a:	9c 83       	std	Y+4, r25	; 0x04
     d5c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     d5e:	eb 81       	ldd	r30, Y+3	; 0x03
     d60:	fc 81       	ldd	r31, Y+4	; 0x04
     d62:	81 e3       	ldi	r24, 0x31	; 49
     d64:	80 83       	st	Z, r24
	pxTopOfStack--;
     d66:	8b 81       	ldd	r24, Y+3	; 0x03
     d68:	9c 81       	ldd	r25, Y+4	; 0x04
     d6a:	01 97       	sbiw	r24, 0x01	; 1
     d6c:	9c 83       	std	Y+4, r25	; 0x04
     d6e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     d70:	8b 81       	ldd	r24, Y+3	; 0x03
     d72:	9c 81       	ldd	r25, Y+4	; 0x04
}
     d74:	28 96       	adiw	r28, 0x08	; 8
     d76:	0f b6       	in	r0, 0x3f	; 63
     d78:	f8 94       	cli
     d7a:	de bf       	out	0x3e, r29	; 62
     d7c:	0f be       	out	0x3f, r0	; 63
     d7e:	cd bf       	out	0x3d, r28	; 61
     d80:	cf 91       	pop	r28
     d82:	df 91       	pop	r29
     d84:	08 95       	ret

00000d86 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
     d86:	df 93       	push	r29
     d88:	cf 93       	push	r28
     d8a:	cd b7       	in	r28, 0x3d	; 61
     d8c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
     d8e:	0e 94 b5 07 	call	0xf6a	; 0xf6a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     d92:	a0 91 e8 06 	lds	r26, 0x06E8
     d96:	b0 91 e9 06 	lds	r27, 0x06E9
     d9a:	cd 91       	ld	r28, X+
     d9c:	cd bf       	out	0x3d, r28	; 61
     d9e:	dd 91       	ld	r29, X+
     da0:	de bf       	out	0x3e, r29	; 62
     da2:	ff 91       	pop	r31
     da4:	ef 91       	pop	r30
     da6:	df 91       	pop	r29
     da8:	cf 91       	pop	r28
     daa:	bf 91       	pop	r27
     dac:	af 91       	pop	r26
     dae:	9f 91       	pop	r25
     db0:	8f 91       	pop	r24
     db2:	7f 91       	pop	r23
     db4:	6f 91       	pop	r22
     db6:	5f 91       	pop	r21
     db8:	4f 91       	pop	r20
     dba:	3f 91       	pop	r19
     dbc:	2f 91       	pop	r18
     dbe:	1f 91       	pop	r17
     dc0:	0f 91       	pop	r16
     dc2:	ff 90       	pop	r15
     dc4:	ef 90       	pop	r14
     dc6:	df 90       	pop	r13
     dc8:	cf 90       	pop	r12
     dca:	bf 90       	pop	r11
     dcc:	af 90       	pop	r10
     dce:	9f 90       	pop	r9
     dd0:	8f 90       	pop	r8
     dd2:	7f 90       	pop	r7
     dd4:	6f 90       	pop	r6
     dd6:	5f 90       	pop	r5
     dd8:	4f 90       	pop	r4
     dda:	3f 90       	pop	r3
     ddc:	2f 90       	pop	r2
     dde:	1f 90       	pop	r1
     de0:	0f 90       	pop	r0
     de2:	0f be       	out	0x3f, r0	; 63
     de4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     de6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
     de8:	81 e0       	ldi	r24, 0x01	; 1
}
     dea:	cf 91       	pop	r28
     dec:	df 91       	pop	r29
     dee:	08 95       	ret

00000df0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     df0:	df 93       	push	r29
     df2:	cf 93       	push	r28
     df4:	cd b7       	in	r28, 0x3d	; 61
     df6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     df8:	cf 91       	pop	r28
     dfa:	df 91       	pop	r29
     dfc:	08 95       	ret

00000dfe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     dfe:	0f 92       	push	r0
     e00:	0f b6       	in	r0, 0x3f	; 63
     e02:	f8 94       	cli
     e04:	0f 92       	push	r0
     e06:	1f 92       	push	r1
     e08:	11 24       	eor	r1, r1
     e0a:	2f 92       	push	r2
     e0c:	3f 92       	push	r3
     e0e:	4f 92       	push	r4
     e10:	5f 92       	push	r5
     e12:	6f 92       	push	r6
     e14:	7f 92       	push	r7
     e16:	8f 92       	push	r8
     e18:	9f 92       	push	r9
     e1a:	af 92       	push	r10
     e1c:	bf 92       	push	r11
     e1e:	cf 92       	push	r12
     e20:	df 92       	push	r13
     e22:	ef 92       	push	r14
     e24:	ff 92       	push	r15
     e26:	0f 93       	push	r16
     e28:	1f 93       	push	r17
     e2a:	2f 93       	push	r18
     e2c:	3f 93       	push	r19
     e2e:	4f 93       	push	r20
     e30:	5f 93       	push	r21
     e32:	6f 93       	push	r22
     e34:	7f 93       	push	r23
     e36:	8f 93       	push	r24
     e38:	9f 93       	push	r25
     e3a:	af 93       	push	r26
     e3c:	bf 93       	push	r27
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
     e42:	ef 93       	push	r30
     e44:	ff 93       	push	r31
     e46:	a0 91 e8 06 	lds	r26, 0x06E8
     e4a:	b0 91 e9 06 	lds	r27, 0x06E9
     e4e:	0d b6       	in	r0, 0x3d	; 61
     e50:	0d 92       	st	X+, r0
     e52:	0e b6       	in	r0, 0x3e	; 62
     e54:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     e56:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     e5a:	a0 91 e8 06 	lds	r26, 0x06E8
     e5e:	b0 91 e9 06 	lds	r27, 0x06E9
     e62:	cd 91       	ld	r28, X+
     e64:	cd bf       	out	0x3d, r28	; 61
     e66:	dd 91       	ld	r29, X+
     e68:	de bf       	out	0x3e, r29	; 62
     e6a:	ff 91       	pop	r31
     e6c:	ef 91       	pop	r30
     e6e:	df 91       	pop	r29
     e70:	cf 91       	pop	r28
     e72:	bf 91       	pop	r27
     e74:	af 91       	pop	r26
     e76:	9f 91       	pop	r25
     e78:	8f 91       	pop	r24
     e7a:	7f 91       	pop	r23
     e7c:	6f 91       	pop	r22
     e7e:	5f 91       	pop	r21
     e80:	4f 91       	pop	r20
     e82:	3f 91       	pop	r19
     e84:	2f 91       	pop	r18
     e86:	1f 91       	pop	r17
     e88:	0f 91       	pop	r16
     e8a:	ff 90       	pop	r15
     e8c:	ef 90       	pop	r14
     e8e:	df 90       	pop	r13
     e90:	cf 90       	pop	r12
     e92:	bf 90       	pop	r11
     e94:	af 90       	pop	r10
     e96:	9f 90       	pop	r9
     e98:	8f 90       	pop	r8
     e9a:	7f 90       	pop	r7
     e9c:	6f 90       	pop	r6
     e9e:	5f 90       	pop	r5
     ea0:	4f 90       	pop	r4
     ea2:	3f 90       	pop	r3
     ea4:	2f 90       	pop	r2
     ea6:	1f 90       	pop	r1
     ea8:	0f 90       	pop	r0
     eaa:	0f be       	out	0x3f, r0	; 63
     eac:	0f 90       	pop	r0

	asm volatile ( "ret" );
     eae:	08 95       	ret

00000eb0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     eb0:	0f 92       	push	r0
     eb2:	0f b6       	in	r0, 0x3f	; 63
     eb4:	f8 94       	cli
     eb6:	0f 92       	push	r0
     eb8:	1f 92       	push	r1
     eba:	11 24       	eor	r1, r1
     ebc:	2f 92       	push	r2
     ebe:	3f 92       	push	r3
     ec0:	4f 92       	push	r4
     ec2:	5f 92       	push	r5
     ec4:	6f 92       	push	r6
     ec6:	7f 92       	push	r7
     ec8:	8f 92       	push	r8
     eca:	9f 92       	push	r9
     ecc:	af 92       	push	r10
     ece:	bf 92       	push	r11
     ed0:	cf 92       	push	r12
     ed2:	df 92       	push	r13
     ed4:	ef 92       	push	r14
     ed6:	ff 92       	push	r15
     ed8:	0f 93       	push	r16
     eda:	1f 93       	push	r17
     edc:	2f 93       	push	r18
     ede:	3f 93       	push	r19
     ee0:	4f 93       	push	r20
     ee2:	5f 93       	push	r21
     ee4:	6f 93       	push	r22
     ee6:	7f 93       	push	r23
     ee8:	8f 93       	push	r24
     eea:	9f 93       	push	r25
     eec:	af 93       	push	r26
     eee:	bf 93       	push	r27
     ef0:	cf 93       	push	r28
     ef2:	df 93       	push	r29
     ef4:	ef 93       	push	r30
     ef6:	ff 93       	push	r31
     ef8:	a0 91 e8 06 	lds	r26, 0x06E8
     efc:	b0 91 e9 06 	lds	r27, 0x06E9
     f00:	0d b6       	in	r0, 0x3d	; 61
     f02:	0d 92       	st	X+, r0
     f04:	0e b6       	in	r0, 0x3e	; 62
     f06:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     f08:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <xTaskIncrementTick>
     f0c:	88 23       	and	r24, r24
     f0e:	11 f0       	breq	.+4      	; 0xf14 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
     f10:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     f14:	a0 91 e8 06 	lds	r26, 0x06E8
     f18:	b0 91 e9 06 	lds	r27, 0x06E9
     f1c:	cd 91       	ld	r28, X+
     f1e:	cd bf       	out	0x3d, r28	; 61
     f20:	dd 91       	ld	r29, X+
     f22:	de bf       	out	0x3e, r29	; 62
     f24:	ff 91       	pop	r31
     f26:	ef 91       	pop	r30
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	bf 91       	pop	r27
     f2e:	af 91       	pop	r26
     f30:	9f 91       	pop	r25
     f32:	8f 91       	pop	r24
     f34:	7f 91       	pop	r23
     f36:	6f 91       	pop	r22
     f38:	5f 91       	pop	r21
     f3a:	4f 91       	pop	r20
     f3c:	3f 91       	pop	r19
     f3e:	2f 91       	pop	r18
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	ef 90       	pop	r14
     f48:	df 90       	pop	r13
     f4a:	cf 90       	pop	r12
     f4c:	bf 90       	pop	r11
     f4e:	af 90       	pop	r10
     f50:	9f 90       	pop	r9
     f52:	8f 90       	pop	r8
     f54:	7f 90       	pop	r7
     f56:	6f 90       	pop	r6
     f58:	5f 90       	pop	r5
     f5a:	4f 90       	pop	r4
     f5c:	3f 90       	pop	r3
     f5e:	2f 90       	pop	r2
     f60:	1f 90       	pop	r1
     f62:	0f 90       	pop	r0
     f64:	0f be       	out	0x3f, r0	; 63
     f66:	0f 90       	pop	r0

	asm volatile ( "ret" );
     f68:	08 95       	ret

00000f6a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
     f6a:	df 93       	push	r29
     f6c:	cf 93       	push	r28
     f6e:	00 d0       	rcall	.+0      	; 0xf70 <prvSetupTimerInterrupt+0x6>
     f70:	00 d0       	rcall	.+0      	; 0xf72 <prvSetupTimerInterrupt+0x8>
     f72:	00 d0       	rcall	.+0      	; 0xf74 <prvSetupTimerInterrupt+0xa>
     f74:	cd b7       	in	r28, 0x3d	; 61
     f76:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
     f78:	80 e4       	ldi	r24, 0x40	; 64
     f7a:	9f e1       	ldi	r25, 0x1F	; 31
     f7c:	a0 e0       	ldi	r26, 0x00	; 0
     f7e:	b0 e0       	ldi	r27, 0x00	; 0
     f80:	8b 83       	std	Y+3, r24	; 0x03
     f82:	9c 83       	std	Y+4, r25	; 0x04
     f84:	ad 83       	std	Y+5, r26	; 0x05
     f86:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
     f88:	8b 81       	ldd	r24, Y+3	; 0x03
     f8a:	9c 81       	ldd	r25, Y+4	; 0x04
     f8c:	ad 81       	ldd	r26, Y+5	; 0x05
     f8e:	be 81       	ldd	r27, Y+6	; 0x06
     f90:	68 94       	set
     f92:	15 f8       	bld	r1, 5
     f94:	b6 95       	lsr	r27
     f96:	a7 95       	ror	r26
     f98:	97 95       	ror	r25
     f9a:	87 95       	ror	r24
     f9c:	16 94       	lsr	r1
     f9e:	d1 f7       	brne	.-12     	; 0xf94 <prvSetupTimerInterrupt+0x2a>
     fa0:	8b 83       	std	Y+3, r24	; 0x03
     fa2:	9c 83       	std	Y+4, r25	; 0x04
     fa4:	ad 83       	std	Y+5, r26	; 0x05
     fa6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
     fa8:	8b 81       	ldd	r24, Y+3	; 0x03
     faa:	9c 81       	ldd	r25, Y+4	; 0x04
     fac:	ad 81       	ldd	r26, Y+5	; 0x05
     fae:	be 81       	ldd	r27, Y+6	; 0x06
     fb0:	01 97       	sbiw	r24, 0x01	; 1
     fb2:	a1 09       	sbc	r26, r1
     fb4:	b1 09       	sbc	r27, r1
     fb6:	8b 83       	std	Y+3, r24	; 0x03
     fb8:	9c 83       	std	Y+4, r25	; 0x04
     fba:	ad 83       	std	Y+5, r26	; 0x05
     fbc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fbe:	8b 81       	ldd	r24, Y+3	; 0x03
     fc0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
     fc2:	8b 81       	ldd	r24, Y+3	; 0x03
     fc4:	9c 81       	ldd	r25, Y+4	; 0x04
     fc6:	ad 81       	ldd	r26, Y+5	; 0x05
     fc8:	be 81       	ldd	r27, Y+6	; 0x06
     fca:	89 2f       	mov	r24, r25
     fcc:	9a 2f       	mov	r25, r26
     fce:	ab 2f       	mov	r26, r27
     fd0:	bb 27       	eor	r27, r27
     fd2:	8b 83       	std	Y+3, r24	; 0x03
     fd4:	9c 83       	std	Y+4, r25	; 0x04
     fd6:	ad 83       	std	Y+5, r26	; 0x05
     fd8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
     fda:	8b 81       	ldd	r24, Y+3	; 0x03
     fdc:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
     fde:	eb e4       	ldi	r30, 0x4B	; 75
     fe0:	f0 e0       	ldi	r31, 0x00	; 0
     fe2:	8a 81       	ldd	r24, Y+2	; 0x02
     fe4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
     fe6:	ea e4       	ldi	r30, 0x4A	; 74
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	89 81       	ldd	r24, Y+1	; 0x01
     fec:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
     fee:	8b e0       	ldi	r24, 0x0B	; 11
     ff0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
     ff2:	ee e4       	ldi	r30, 0x4E	; 78
     ff4:	f0 e0       	ldi	r31, 0x00	; 0
     ff6:	89 81       	ldd	r24, Y+1	; 0x01
     ff8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
     ffa:	e9 e5       	ldi	r30, 0x59	; 89
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	80 81       	ld	r24, Z
    1000:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1002:	89 81       	ldd	r24, Y+1	; 0x01
    1004:	80 61       	ori	r24, 0x10	; 16
    1006:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1008:	e9 e5       	ldi	r30, 0x59	; 89
    100a:	f0 e0       	ldi	r31, 0x00	; 0
    100c:	89 81       	ldd	r24, Y+1	; 0x01
    100e:	80 83       	st	Z, r24
}
    1010:	26 96       	adiw	r28, 0x06	; 6
    1012:	0f b6       	in	r0, 0x3f	; 63
    1014:	f8 94       	cli
    1016:	de bf       	out	0x3e, r29	; 62
    1018:	0f be       	out	0x3f, r0	; 63
    101a:	cd bf       	out	0x3d, r28	; 61
    101c:	cf 91       	pop	r28
    101e:	df 91       	pop	r29
    1020:	08 95       	ret

00001022 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1022:	0e 94 58 07 	call	0xeb0	; 0xeb0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1026:	18 95       	reti

00001028 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1028:	df 93       	push	r29
    102a:	cf 93       	push	r28
    102c:	00 d0       	rcall	.+0      	; 0x102e <xQueueGenericReset+0x6>
    102e:	00 d0       	rcall	.+0      	; 0x1030 <xQueueGenericReset+0x8>
    1030:	0f 92       	push	r0
    1032:	cd b7       	in	r28, 0x3d	; 61
    1034:	de b7       	in	r29, 0x3e	; 62
    1036:	9c 83       	std	Y+4, r25	; 0x04
    1038:	8b 83       	std	Y+3, r24	; 0x03
    103a:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    103c:	8b 81       	ldd	r24, Y+3	; 0x03
    103e:	9c 81       	ldd	r25, Y+4	; 0x04
    1040:	9a 83       	std	Y+2, r25	; 0x02
    1042:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1044:	0f b6       	in	r0, 0x3f	; 63
    1046:	f8 94       	cli
    1048:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    104a:	e9 81       	ldd	r30, Y+1	; 0x01
    104c:	fa 81       	ldd	r31, Y+2	; 0x02
    104e:	40 81       	ld	r20, Z
    1050:	51 81       	ldd	r21, Z+1	; 0x01
    1052:	e9 81       	ldd	r30, Y+1	; 0x01
    1054:	fa 81       	ldd	r31, Y+2	; 0x02
    1056:	83 8d       	ldd	r24, Z+27	; 0x1b
    1058:	28 2f       	mov	r18, r24
    105a:	30 e0       	ldi	r19, 0x00	; 0
    105c:	e9 81       	ldd	r30, Y+1	; 0x01
    105e:	fa 81       	ldd	r31, Y+2	; 0x02
    1060:	84 8d       	ldd	r24, Z+28	; 0x1c
    1062:	88 2f       	mov	r24, r24
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	bc 01       	movw	r22, r24
    1068:	26 9f       	mul	r18, r22
    106a:	c0 01       	movw	r24, r0
    106c:	27 9f       	mul	r18, r23
    106e:	90 0d       	add	r25, r0
    1070:	36 9f       	mul	r19, r22
    1072:	90 0d       	add	r25, r0
    1074:	11 24       	eor	r1, r1
    1076:	84 0f       	add	r24, r20
    1078:	95 1f       	adc	r25, r21
    107a:	e9 81       	ldd	r30, Y+1	; 0x01
    107c:	fa 81       	ldd	r31, Y+2	; 0x02
    107e:	95 83       	std	Z+5, r25	; 0x05
    1080:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1082:	e9 81       	ldd	r30, Y+1	; 0x01
    1084:	fa 81       	ldd	r31, Y+2	; 0x02
    1086:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1088:	e9 81       	ldd	r30, Y+1	; 0x01
    108a:	fa 81       	ldd	r31, Y+2	; 0x02
    108c:	80 81       	ld	r24, Z
    108e:	91 81       	ldd	r25, Z+1	; 0x01
    1090:	e9 81       	ldd	r30, Y+1	; 0x01
    1092:	fa 81       	ldd	r31, Y+2	; 0x02
    1094:	93 83       	std	Z+3, r25	; 0x03
    1096:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1098:	e9 81       	ldd	r30, Y+1	; 0x01
    109a:	fa 81       	ldd	r31, Y+2	; 0x02
    109c:	40 81       	ld	r20, Z
    109e:	51 81       	ldd	r21, Z+1	; 0x01
    10a0:	e9 81       	ldd	r30, Y+1	; 0x01
    10a2:	fa 81       	ldd	r31, Y+2	; 0x02
    10a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    10a6:	88 2f       	mov	r24, r24
    10a8:	90 e0       	ldi	r25, 0x00	; 0
    10aa:	9c 01       	movw	r18, r24
    10ac:	21 50       	subi	r18, 0x01	; 1
    10ae:	30 40       	sbci	r19, 0x00	; 0
    10b0:	e9 81       	ldd	r30, Y+1	; 0x01
    10b2:	fa 81       	ldd	r31, Y+2	; 0x02
    10b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    10b6:	88 2f       	mov	r24, r24
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	bc 01       	movw	r22, r24
    10bc:	26 9f       	mul	r18, r22
    10be:	c0 01       	movw	r24, r0
    10c0:	27 9f       	mul	r18, r23
    10c2:	90 0d       	add	r25, r0
    10c4:	36 9f       	mul	r19, r22
    10c6:	90 0d       	add	r25, r0
    10c8:	11 24       	eor	r1, r1
    10ca:	84 0f       	add	r24, r20
    10cc:	95 1f       	adc	r25, r21
    10ce:	e9 81       	ldd	r30, Y+1	; 0x01
    10d0:	fa 81       	ldd	r31, Y+2	; 0x02
    10d2:	97 83       	std	Z+7, r25	; 0x07
    10d4:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    10d6:	e9 81       	ldd	r30, Y+1	; 0x01
    10d8:	fa 81       	ldd	r31, Y+2	; 0x02
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    10de:	e9 81       	ldd	r30, Y+1	; 0x01
    10e0:	fa 81       	ldd	r31, Y+2	; 0x02
    10e2:	8f ef       	ldi	r24, 0xFF	; 255
    10e4:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    10e6:	8d 81       	ldd	r24, Y+5	; 0x05
    10e8:	88 23       	and	r24, r24
    10ea:	79 f4       	brne	.+30     	; 0x110a <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10ec:	e9 81       	ldd	r30, Y+1	; 0x01
    10ee:	fa 81       	ldd	r31, Y+2	; 0x02
    10f0:	80 85       	ldd	r24, Z+8	; 0x08
    10f2:	88 23       	and	r24, r24
    10f4:	a1 f0       	breq	.+40     	; 0x111e <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10f6:	89 81       	ldd	r24, Y+1	; 0x01
    10f8:	9a 81       	ldd	r25, Y+2	; 0x02
    10fa:	08 96       	adiw	r24, 0x08	; 8
    10fc:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1100:	88 23       	and	r24, r24
    1102:	69 f0       	breq	.+26     	; 0x111e <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1104:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1108:	0a c0       	rjmp	.+20     	; 0x111e <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    110a:	89 81       	ldd	r24, Y+1	; 0x01
    110c:	9a 81       	ldd	r25, Y+2	; 0x02
    110e:	08 96       	adiw	r24, 0x08	; 8
    1110:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1114:	89 81       	ldd	r24, Y+1	; 0x01
    1116:	9a 81       	ldd	r25, Y+2	; 0x02
    1118:	41 96       	adiw	r24, 0x11	; 17
    111a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    111e:	0f 90       	pop	r0
    1120:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1122:	81 e0       	ldi	r24, 0x01	; 1
}
    1124:	0f 90       	pop	r0
    1126:	0f 90       	pop	r0
    1128:	0f 90       	pop	r0
    112a:	0f 90       	pop	r0
    112c:	0f 90       	pop	r0
    112e:	cf 91       	pop	r28
    1130:	df 91       	pop	r29
    1132:	08 95       	ret

00001134 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	df 93       	push	r29
    113a:	cf 93       	push	r28
    113c:	cd b7       	in	r28, 0x3d	; 61
    113e:	de b7       	in	r29, 0x3e	; 62
    1140:	29 97       	sbiw	r28, 0x09	; 9
    1142:	0f b6       	in	r0, 0x3f	; 63
    1144:	f8 94       	cli
    1146:	de bf       	out	0x3e, r29	; 62
    1148:	0f be       	out	0x3f, r0	; 63
    114a:	cd bf       	out	0x3d, r28	; 61
    114c:	8f 83       	std	Y+7, r24	; 0x07
    114e:	68 87       	std	Y+8, r22	; 0x08
    1150:	49 87       	std	Y+9, r20	; 0x09
	size_t xQueueSizeInBytes;
	uint8_t *pucQueueStorage;

		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		if( uxItemSize == ( UBaseType_t ) 0 )
    1152:	88 85       	ldd	r24, Y+8	; 0x08
    1154:	88 23       	and	r24, r24
    1156:	19 f4       	brne	.+6      	; 0x115e <xQueueGenericCreate+0x2a>
		{
			/* There is not going to be a queue storage area. */
			xQueueSizeInBytes = ( size_t ) 0;
    1158:	1c 82       	std	Y+4, r1	; 0x04
    115a:	1b 82       	std	Y+3, r1	; 0x03
    115c:	10 c0       	rjmp	.+32     	; 0x117e <xQueueGenericCreate+0x4a>
		}
		else
		{
			/* Allocate enough space to hold the maximum number of items that
			can be in the queue at any time. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    115e:	8f 81       	ldd	r24, Y+7	; 0x07
    1160:	28 2f       	mov	r18, r24
    1162:	30 e0       	ldi	r19, 0x00	; 0
    1164:	88 85       	ldd	r24, Y+8	; 0x08
    1166:	88 2f       	mov	r24, r24
    1168:	90 e0       	ldi	r25, 0x00	; 0
    116a:	ac 01       	movw	r20, r24
    116c:	24 9f       	mul	r18, r20
    116e:	c0 01       	movw	r24, r0
    1170:	25 9f       	mul	r18, r21
    1172:	90 0d       	add	r25, r0
    1174:	34 9f       	mul	r19, r20
    1176:	90 0d       	add	r25, r0
    1178:	11 24       	eor	r1, r1
    117a:	9c 83       	std	Y+4, r25	; 0x04
    117c:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    117e:	8b 81       	ldd	r24, Y+3	; 0x03
    1180:	9c 81       	ldd	r25, Y+4	; 0x04
    1182:	4f 96       	adiw	r24, 0x1f	; 31
    1184:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    1188:	9e 83       	std	Y+6, r25	; 0x06
    118a:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    118c:	8d 81       	ldd	r24, Y+5	; 0x05
    118e:	9e 81       	ldd	r25, Y+6	; 0x06
    1190:	00 97       	sbiw	r24, 0x00	; 0
    1192:	a1 f0       	breq	.+40     	; 0x11bc <xQueueGenericCreate+0x88>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1194:	8d 81       	ldd	r24, Y+5	; 0x05
    1196:	9e 81       	ldd	r25, Y+6	; 0x06
    1198:	9a 83       	std	Y+2, r25	; 0x02
    119a:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	9a 81       	ldd	r25, Y+2	; 0x02
    11a0:	4f 96       	adiw	r24, 0x1f	; 31
    11a2:	9a 83       	std	Y+2, r25	; 0x02
    11a4:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    11a6:	29 81       	ldd	r18, Y+1	; 0x01
    11a8:	3a 81       	ldd	r19, Y+2	; 0x02
    11aa:	ed 81       	ldd	r30, Y+5	; 0x05
    11ac:	fe 81       	ldd	r31, Y+6	; 0x06
    11ae:	8f 81       	ldd	r24, Y+7	; 0x07
    11b0:	68 85       	ldd	r22, Y+8	; 0x08
    11b2:	a9 01       	movw	r20, r18
    11b4:	29 85       	ldd	r18, Y+9	; 0x09
    11b6:	8f 01       	movw	r16, r30
    11b8:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    11bc:	8d 81       	ldd	r24, Y+5	; 0x05
    11be:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    11c0:	29 96       	adiw	r28, 0x09	; 9
    11c2:	0f b6       	in	r0, 0x3f	; 63
    11c4:	f8 94       	cli
    11c6:	de bf       	out	0x3e, r29	; 62
    11c8:	0f be       	out	0x3f, r0	; 63
    11ca:	cd bf       	out	0x3d, r28	; 61
    11cc:	cf 91       	pop	r28
    11ce:	df 91       	pop	r29
    11d0:	1f 91       	pop	r17
    11d2:	0f 91       	pop	r16
    11d4:	08 95       	ret

000011d6 <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	df 93       	push	r29
    11dc:	cf 93       	push	r28
    11de:	cd b7       	in	r28, 0x3d	; 61
    11e0:	de b7       	in	r29, 0x3e	; 62
    11e2:	27 97       	sbiw	r28, 0x07	; 7
    11e4:	0f b6       	in	r0, 0x3f	; 63
    11e6:	f8 94       	cli
    11e8:	de bf       	out	0x3e, r29	; 62
    11ea:	0f be       	out	0x3f, r0	; 63
    11ec:	cd bf       	out	0x3d, r28	; 61
    11ee:	89 83       	std	Y+1, r24	; 0x01
    11f0:	6a 83       	std	Y+2, r22	; 0x02
    11f2:	5c 83       	std	Y+4, r21	; 0x04
    11f4:	4b 83       	std	Y+3, r20	; 0x03
    11f6:	2d 83       	std	Y+5, r18	; 0x05
    11f8:	1f 83       	std	Y+7, r17	; 0x07
    11fa:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    11fc:	8a 81       	ldd	r24, Y+2	; 0x02
    11fe:	88 23       	and	r24, r24
    1200:	39 f4       	brne	.+14     	; 0x1210 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1202:	8e 81       	ldd	r24, Y+6	; 0x06
    1204:	9f 81       	ldd	r25, Y+7	; 0x07
    1206:	ee 81       	ldd	r30, Y+6	; 0x06
    1208:	ff 81       	ldd	r31, Y+7	; 0x07
    120a:	91 83       	std	Z+1, r25	; 0x01
    120c:	80 83       	st	Z, r24
    120e:	06 c0       	rjmp	.+12     	; 0x121c <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1210:	8b 81       	ldd	r24, Y+3	; 0x03
    1212:	9c 81       	ldd	r25, Y+4	; 0x04
    1214:	ee 81       	ldd	r30, Y+6	; 0x06
    1216:	ff 81       	ldd	r31, Y+7	; 0x07
    1218:	91 83       	std	Z+1, r25	; 0x01
    121a:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    121c:	ee 81       	ldd	r30, Y+6	; 0x06
    121e:	ff 81       	ldd	r31, Y+7	; 0x07
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1224:	ee 81       	ldd	r30, Y+6	; 0x06
    1226:	ff 81       	ldd	r31, Y+7	; 0x07
    1228:	8a 81       	ldd	r24, Y+2	; 0x02
    122a:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    122c:	8e 81       	ldd	r24, Y+6	; 0x06
    122e:	9f 81       	ldd	r25, Y+7	; 0x07
    1230:	61 e0       	ldi	r22, 0x01	; 1
    1232:	0e 94 14 08 	call	0x1028	; 0x1028 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1236:	27 96       	adiw	r28, 0x07	; 7
    1238:	0f b6       	in	r0, 0x3f	; 63
    123a:	f8 94       	cli
    123c:	de bf       	out	0x3e, r29	; 62
    123e:	0f be       	out	0x3f, r0	; 63
    1240:	cd bf       	out	0x3d, r28	; 61
    1242:	cf 91       	pop	r28
    1244:	df 91       	pop	r29
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	08 95       	ret

0000124c <prvInitialiseMutex>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static void prvInitialiseMutex( Queue_t *pxNewQueue )
	{
    124c:	df 93       	push	r29
    124e:	cf 93       	push	r28
    1250:	00 d0       	rcall	.+0      	; 0x1252 <prvInitialiseMutex+0x6>
    1252:	cd b7       	in	r28, 0x3d	; 61
    1254:	de b7       	in	r29, 0x3e	; 62
    1256:	9a 83       	std	Y+2, r25	; 0x02
    1258:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewQueue != NULL )
    125a:	89 81       	ldd	r24, Y+1	; 0x01
    125c:	9a 81       	ldd	r25, Y+2	; 0x02
    125e:	00 97       	sbiw	r24, 0x00	; 0
    1260:	a1 f0       	breq	.+40     	; 0x128a <prvInitialiseMutex+0x3e>
		{
			/* The queue create function will set all the queue structure members
			correctly for a generic queue, but this function is creating a
			mutex.  Overwrite those members that need to be set differently -
			in particular the information required for priority inheritance. */
			pxNewQueue->u.xSemaphore.xMutexHolder = NULL;
    1262:	e9 81       	ldd	r30, Y+1	; 0x01
    1264:	fa 81       	ldd	r31, Y+2	; 0x02
    1266:	15 82       	std	Z+5, r1	; 0x05
    1268:	14 82       	std	Z+4, r1	; 0x04
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    126a:	e9 81       	ldd	r30, Y+1	; 0x01
    126c:	fa 81       	ldd	r31, Y+2	; 0x02
    126e:	11 82       	std	Z+1, r1	; 0x01
    1270:	10 82       	st	Z, r1

			/* In case this is a recursive mutex. */
			pxNewQueue->u.xSemaphore.uxRecursiveCallCount = 0;
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	16 82       	std	Z+6, r1	; 0x06

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
    1278:	89 81       	ldd	r24, Y+1	; 0x01
    127a:	9a 81       	ldd	r25, Y+2	; 0x02
    127c:	60 e0       	ldi	r22, 0x00	; 0
    127e:	70 e0       	ldi	r23, 0x00	; 0
    1280:	40 e0       	ldi	r20, 0x00	; 0
    1282:	50 e0       	ldi	r21, 0x00	; 0
    1284:	20 e0       	ldi	r18, 0x00	; 0
    1286:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xQueueGenericSend>
		}
		else
		{
			traceCREATE_MUTEX_FAILED();
		}
	}
    128a:	0f 90       	pop	r0
    128c:	0f 90       	pop	r0
    128e:	cf 91       	pop	r28
    1290:	df 91       	pop	r29
    1292:	08 95       	ret

00001294 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )

	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
	{
    1294:	df 93       	push	r29
    1296:	cf 93       	push	r28
    1298:	00 d0       	rcall	.+0      	; 0x129a <xQueueCreateMutex+0x6>
    129a:	00 d0       	rcall	.+0      	; 0x129c <xQueueCreateMutex+0x8>
    129c:	0f 92       	push	r0
    129e:	cd b7       	in	r28, 0x3d	; 61
    12a0:	de b7       	in	r29, 0x3e	; 62
    12a2:	8d 83       	std	Y+5, r24	; 0x05
	QueueHandle_t xNewQueue;
	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
    12a4:	81 e0       	ldi	r24, 0x01	; 1
    12a6:	8a 83       	std	Y+2, r24	; 0x02
    12a8:	19 82       	std	Y+1, r1	; 0x01

		xNewQueue = xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
    12aa:	8a 81       	ldd	r24, Y+2	; 0x02
    12ac:	69 81       	ldd	r22, Y+1	; 0x01
    12ae:	4d 81       	ldd	r20, Y+5	; 0x05
    12b0:	0e 94 9a 08 	call	0x1134	; 0x1134 <xQueueGenericCreate>
    12b4:	9c 83       	std	Y+4, r25	; 0x04
    12b6:	8b 83       	std	Y+3, r24	; 0x03
		prvInitialiseMutex( ( Queue_t * ) xNewQueue );
    12b8:	8b 81       	ldd	r24, Y+3	; 0x03
    12ba:	9c 81       	ldd	r25, Y+4	; 0x04
    12bc:	0e 94 26 09 	call	0x124c	; 0x124c <prvInitialiseMutex>

		return xNewQueue;
    12c0:	8b 81       	ldd	r24, Y+3	; 0x03
    12c2:	9c 81       	ldd	r25, Y+4	; 0x04
	}
    12c4:	0f 90       	pop	r0
    12c6:	0f 90       	pop	r0
    12c8:	0f 90       	pop	r0
    12ca:	0f 90       	pop	r0
    12cc:	0f 90       	pop	r0
    12ce:	cf 91       	pop	r28
    12d0:	df 91       	pop	r29
    12d2:	08 95       	ret

000012d4 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    12d4:	df 93       	push	r29
    12d6:	cf 93       	push	r28
    12d8:	cd b7       	in	r28, 0x3d	; 61
    12da:	de b7       	in	r29, 0x3e	; 62
    12dc:	2f 97       	sbiw	r28, 0x0f	; 15
    12de:	0f b6       	in	r0, 0x3f	; 63
    12e0:	f8 94       	cli
    12e2:	de bf       	out	0x3e, r29	; 62
    12e4:	0f be       	out	0x3f, r0	; 63
    12e6:	cd bf       	out	0x3d, r28	; 61
    12e8:	99 87       	std	Y+9, r25	; 0x09
    12ea:	88 87       	std	Y+8, r24	; 0x08
    12ec:	7b 87       	std	Y+11, r23	; 0x0b
    12ee:	6a 87       	std	Y+10, r22	; 0x0a
    12f0:	5d 87       	std	Y+13, r21	; 0x0d
    12f2:	4c 87       	std	Y+12, r20	; 0x0c
    12f4:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    12f6:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    12f8:	88 85       	ldd	r24, Y+8	; 0x08
    12fa:	99 85       	ldd	r25, Y+9	; 0x09
    12fc:	9a 83       	std	Y+2, r25	; 0x02
    12fe:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1306:	e9 81       	ldd	r30, Y+1	; 0x01
    1308:	fa 81       	ldd	r31, Y+2	; 0x02
    130a:	92 8d       	ldd	r25, Z+26	; 0x1a
    130c:	e9 81       	ldd	r30, Y+1	; 0x01
    130e:	fa 81       	ldd	r31, Y+2	; 0x02
    1310:	83 8d       	ldd	r24, Z+27	; 0x1b
    1312:	98 17       	cp	r25, r24
    1314:	18 f0       	brcs	.+6      	; 0x131c <xQueueGenericSend+0x48>
    1316:	8e 85       	ldd	r24, Y+14	; 0x0e
    1318:	82 30       	cpi	r24, 0x02	; 2
    131a:	11 f5       	brne	.+68     	; 0x1360 <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    131c:	89 81       	ldd	r24, Y+1	; 0x01
    131e:	9a 81       	ldd	r25, Y+2	; 0x02
    1320:	2a 85       	ldd	r18, Y+10	; 0x0a
    1322:	3b 85       	ldd	r19, Y+11	; 0x0b
    1324:	b9 01       	movw	r22, r18
    1326:	4e 85       	ldd	r20, Y+14	; 0x0e
    1328:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <prvCopyDataToQueue>
    132c:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    132e:	e9 81       	ldd	r30, Y+1	; 0x01
    1330:	fa 81       	ldd	r31, Y+2	; 0x02
    1332:	81 89       	ldd	r24, Z+17	; 0x11
    1334:	88 23       	and	r24, r24
    1336:	51 f0       	breq	.+20     	; 0x134c <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1338:	89 81       	ldd	r24, Y+1	; 0x01
    133a:	9a 81       	ldd	r25, Y+2	; 0x02
    133c:	41 96       	adiw	r24, 0x11	; 17
    133e:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1342:	88 23       	and	r24, r24
    1344:	41 f0       	breq	.+16     	; 0x1356 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1346:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    134a:	05 c0       	rjmp	.+10     	; 0x1356 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    134c:	8b 81       	ldd	r24, Y+3	; 0x03
    134e:	88 23       	and	r24, r24
    1350:	11 f0       	breq	.+4      	; 0x1356 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1352:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1356:	0f 90       	pop	r0
    1358:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    135a:	81 e0       	ldi	r24, 0x01	; 1
    135c:	8f 87       	std	Y+15, r24	; 0x0f
    135e:	5c c0       	rjmp	.+184    	; 0x1418 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1360:	8c 85       	ldd	r24, Y+12	; 0x0c
    1362:	9d 85       	ldd	r25, Y+13	; 0x0d
    1364:	00 97       	sbiw	r24, 0x00	; 0
    1366:	21 f4       	brne	.+8      	; 0x1370 <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1368:	0f 90       	pop	r0
    136a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    136c:	1f 86       	std	Y+15, r1	; 0x0f
    136e:	54 c0       	rjmp	.+168    	; 0x1418 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1370:	8c 81       	ldd	r24, Y+4	; 0x04
    1372:	88 23       	and	r24, r24
    1374:	31 f4       	brne	.+12     	; 0x1382 <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1376:	ce 01       	movw	r24, r28
    1378:	05 96       	adiw	r24, 0x05	; 5
    137a:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1382:	0f 90       	pop	r0
    1384:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1386:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	f8 94       	cli
    138e:	0f 92       	push	r0
    1390:	e9 81       	ldd	r30, Y+1	; 0x01
    1392:	fa 81       	ldd	r31, Y+2	; 0x02
    1394:	85 8d       	ldd	r24, Z+29	; 0x1d
    1396:	8f 3f       	cpi	r24, 0xFF	; 255
    1398:	19 f4       	brne	.+6      	; 0x13a0 <xQueueGenericSend+0xcc>
    139a:	e9 81       	ldd	r30, Y+1	; 0x01
    139c:	fa 81       	ldd	r31, Y+2	; 0x02
    139e:	15 8e       	std	Z+29, r1	; 0x1d
    13a0:	e9 81       	ldd	r30, Y+1	; 0x01
    13a2:	fa 81       	ldd	r31, Y+2	; 0x02
    13a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    13a6:	8f 3f       	cpi	r24, 0xFF	; 255
    13a8:	19 f4       	brne	.+6      	; 0x13b0 <xQueueGenericSend+0xdc>
    13aa:	e9 81       	ldd	r30, Y+1	; 0x01
    13ac:	fa 81       	ldd	r31, Y+2	; 0x02
    13ae:	16 8e       	std	Z+30, r1	; 0x1e
    13b0:	0f 90       	pop	r0
    13b2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    13b4:	ce 01       	movw	r24, r28
    13b6:	05 96       	adiw	r24, 0x05	; 5
    13b8:	9e 01       	movw	r18, r28
    13ba:	24 5f       	subi	r18, 0xF4	; 244
    13bc:	3f 4f       	sbci	r19, 0xFF	; 255
    13be:	b9 01       	movw	r22, r18
    13c0:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <xTaskCheckForTimeOut>
    13c4:	88 23       	and	r24, r24
    13c6:	09 f5       	brne	.+66     	; 0x140a <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
    13ca:	9a 81       	ldd	r25, Y+2	; 0x02
    13cc:	0e 94 9e 0f 	call	0x1f3c	; 0x1f3c <prvIsQueueFull>
    13d0:	88 23       	and	r24, r24
    13d2:	a1 f0       	breq	.+40     	; 0x13fc <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    13d4:	89 81       	ldd	r24, Y+1	; 0x01
    13d6:	9a 81       	ldd	r25, Y+2	; 0x02
    13d8:	08 96       	adiw	r24, 0x08	; 8
    13da:	2c 85       	ldd	r18, Y+12	; 0x0c
    13dc:	3d 85       	ldd	r19, Y+13	; 0x0d
    13de:	b9 01       	movw	r22, r18
    13e0:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    13ec:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    13f0:	88 23       	and	r24, r24
    13f2:	09 f0       	breq	.+2      	; 0x13f6 <xQueueGenericSend+0x122>
    13f4:	85 cf       	rjmp	.-246    	; 0x1300 <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    13f6:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    13fa:	82 cf       	rjmp	.-252    	; 0x1300 <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    13fc:	89 81       	ldd	r24, Y+1	; 0x01
    13fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1400:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1404:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    1408:	7b cf       	rjmp	.-266    	; 0x1300 <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    140a:	89 81       	ldd	r24, Y+1	; 0x01
    140c:	9a 81       	ldd	r25, Y+2	; 0x02
    140e:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1412:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1416:	1f 86       	std	Y+15, r1	; 0x0f
    1418:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    141a:	2f 96       	adiw	r28, 0x0f	; 15
    141c:	0f b6       	in	r0, 0x3f	; 63
    141e:	f8 94       	cli
    1420:	de bf       	out	0x3e, r29	; 62
    1422:	0f be       	out	0x3f, r0	; 63
    1424:	cd bf       	out	0x3d, r28	; 61
    1426:	cf 91       	pop	r28
    1428:	df 91       	pop	r29
    142a:	08 95       	ret

0000142c <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    142c:	df 93       	push	r29
    142e:	cf 93       	push	r28
    1430:	cd b7       	in	r28, 0x3d	; 61
    1432:	de b7       	in	r29, 0x3e	; 62
    1434:	2c 97       	sbiw	r28, 0x0c	; 12
    1436:	0f b6       	in	r0, 0x3f	; 63
    1438:	f8 94       	cli
    143a:	de bf       	out	0x3e, r29	; 62
    143c:	0f be       	out	0x3f, r0	; 63
    143e:	cd bf       	out	0x3d, r28	; 61
    1440:	9f 83       	std	Y+7, r25	; 0x07
    1442:	8e 83       	std	Y+6, r24	; 0x06
    1444:	79 87       	std	Y+9, r23	; 0x09
    1446:	68 87       	std	Y+8, r22	; 0x08
    1448:	5b 87       	std	Y+11, r21	; 0x0b
    144a:	4a 87       	std	Y+10, r20	; 0x0a
    144c:	2c 87       	std	Y+12, r18	; 0x0c
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    144e:	8e 81       	ldd	r24, Y+6	; 0x06
    1450:	9f 81       	ldd	r25, Y+7	; 0x07
    1452:	9b 83       	std	Y+3, r25	; 0x03
    1454:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1456:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1458:	ea 81       	ldd	r30, Y+2	; 0x02
    145a:	fb 81       	ldd	r31, Y+3	; 0x03
    145c:	92 8d       	ldd	r25, Z+26	; 0x1a
    145e:	ea 81       	ldd	r30, Y+2	; 0x02
    1460:	fb 81       	ldd	r31, Y+3	; 0x03
    1462:	83 8d       	ldd	r24, Z+27	; 0x1b
    1464:	98 17       	cp	r25, r24
    1466:	18 f0       	brcs	.+6      	; 0x146e <xQueueGenericSendFromISR+0x42>
    1468:	8c 85       	ldd	r24, Y+12	; 0x0c
    146a:	82 30       	cpi	r24, 0x02	; 2
    146c:	61 f5       	brne	.+88     	; 0x14c6 <xQueueGenericSendFromISR+0x9a>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    146e:	ea 81       	ldd	r30, Y+2	; 0x02
    1470:	fb 81       	ldd	r31, Y+3	; 0x03
    1472:	86 8d       	ldd	r24, Z+30	; 0x1e
    1474:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1476:	8a 81       	ldd	r24, Y+2	; 0x02
    1478:	9b 81       	ldd	r25, Y+3	; 0x03
    147a:	28 85       	ldd	r18, Y+8	; 0x08
    147c:	39 85       	ldd	r19, Y+9	; 0x09
    147e:	b9 01       	movw	r22, r18
    1480:	4c 85       	ldd	r20, Y+12	; 0x0c
    1482:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1486:	89 81       	ldd	r24, Y+1	; 0x01
    1488:	8f 3f       	cpi	r24, 0xFF	; 255
    148a:	a9 f4       	brne	.+42     	; 0x14b6 <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    148c:	ea 81       	ldd	r30, Y+2	; 0x02
    148e:	fb 81       	ldd	r31, Y+3	; 0x03
    1490:	81 89       	ldd	r24, Z+17	; 0x11
    1492:	88 23       	and	r24, r24
    1494:	a9 f0       	breq	.+42     	; 0x14c0 <xQueueGenericSendFromISR+0x94>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1496:	8a 81       	ldd	r24, Y+2	; 0x02
    1498:	9b 81       	ldd	r25, Y+3	; 0x03
    149a:	41 96       	adiw	r24, 0x11	; 17
    149c:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    14a0:	88 23       	and	r24, r24
    14a2:	71 f0       	breq	.+28     	; 0x14c0 <xQueueGenericSendFromISR+0x94>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    14a4:	8a 85       	ldd	r24, Y+10	; 0x0a
    14a6:	9b 85       	ldd	r25, Y+11	; 0x0b
    14a8:	00 97       	sbiw	r24, 0x00	; 0
    14aa:	51 f0       	breq	.+20     	; 0x14c0 <xQueueGenericSendFromISR+0x94>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    14ac:	ea 85       	ldd	r30, Y+10	; 0x0a
    14ae:	fb 85       	ldd	r31, Y+11	; 0x0b
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	80 83       	st	Z, r24
    14b4:	05 c0       	rjmp	.+10     	; 0x14c0 <xQueueGenericSendFromISR+0x94>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    14b8:	8f 5f       	subi	r24, 0xFF	; 255
    14ba:	ea 81       	ldd	r30, Y+2	; 0x02
    14bc:	fb 81       	ldd	r31, Y+3	; 0x03
    14be:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	8d 83       	std	Y+5, r24	; 0x05
    14c4:	01 c0       	rjmp	.+2      	; 0x14c8 <xQueueGenericSendFromISR+0x9c>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    14c6:	1d 82       	std	Y+5, r1	; 0x05
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    14c8:	8d 81       	ldd	r24, Y+5	; 0x05
}
    14ca:	2c 96       	adiw	r28, 0x0c	; 12
    14cc:	0f b6       	in	r0, 0x3f	; 63
    14ce:	f8 94       	cli
    14d0:	de bf       	out	0x3e, r29	; 62
    14d2:	0f be       	out	0x3f, r0	; 63
    14d4:	cd bf       	out	0x3d, r28	; 61
    14d6:	cf 91       	pop	r28
    14d8:	df 91       	pop	r29
    14da:	08 95       	ret

000014dc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    14dc:	df 93       	push	r29
    14de:	cf 93       	push	r28
    14e0:	cd b7       	in	r28, 0x3d	; 61
    14e2:	de b7       	in	r29, 0x3e	; 62
    14e4:	2a 97       	sbiw	r28, 0x0a	; 10
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	de bf       	out	0x3e, r29	; 62
    14ec:	0f be       	out	0x3f, r0	; 63
    14ee:	cd bf       	out	0x3d, r28	; 61
    14f0:	98 87       	std	Y+8, r25	; 0x08
    14f2:	8f 83       	std	Y+7, r24	; 0x07
    14f4:	7a 87       	std	Y+10, r23	; 0x0a
    14f6:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    14f8:	8f 81       	ldd	r24, Y+7	; 0x07
    14fa:	98 85       	ldd	r25, Y+8	; 0x08
    14fc:	9c 83       	std	Y+4, r25	; 0x04
    14fe:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1500:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1502:	eb 81       	ldd	r30, Y+3	; 0x03
    1504:	fc 81       	ldd	r31, Y+4	; 0x04
    1506:	82 8d       	ldd	r24, Z+26	; 0x1a
    1508:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    150a:	eb 81       	ldd	r30, Y+3	; 0x03
    150c:	fc 81       	ldd	r31, Y+4	; 0x04
    150e:	93 8d       	ldd	r25, Z+27	; 0x1b
    1510:	8a 81       	ldd	r24, Y+2	; 0x02
    1512:	89 17       	cp	r24, r25
    1514:	48 f5       	brcc	.+82     	; 0x1568 <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    1516:	eb 81       	ldd	r30, Y+3	; 0x03
    1518:	fc 81       	ldd	r31, Y+4	; 0x04
    151a:	86 8d       	ldd	r24, Z+30	; 0x1e
    151c:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    151e:	8a 81       	ldd	r24, Y+2	; 0x02
    1520:	8f 5f       	subi	r24, 0xFF	; 255
    1522:	eb 81       	ldd	r30, Y+3	; 0x03
    1524:	fc 81       	ldd	r31, Y+4	; 0x04
    1526:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    1528:	89 81       	ldd	r24, Y+1	; 0x01
    152a:	8f 3f       	cpi	r24, 0xFF	; 255
    152c:	a9 f4       	brne	.+42     	; 0x1558 <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    152e:	eb 81       	ldd	r30, Y+3	; 0x03
    1530:	fc 81       	ldd	r31, Y+4	; 0x04
    1532:	81 89       	ldd	r24, Z+17	; 0x11
    1534:	88 23       	and	r24, r24
    1536:	a9 f0       	breq	.+42     	; 0x1562 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1538:	8b 81       	ldd	r24, Y+3	; 0x03
    153a:	9c 81       	ldd	r25, Y+4	; 0x04
    153c:	41 96       	adiw	r24, 0x11	; 17
    153e:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1542:	88 23       	and	r24, r24
    1544:	71 f0       	breq	.+28     	; 0x1562 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1546:	89 85       	ldd	r24, Y+9	; 0x09
    1548:	9a 85       	ldd	r25, Y+10	; 0x0a
    154a:	00 97       	sbiw	r24, 0x00	; 0
    154c:	51 f0       	breq	.+20     	; 0x1562 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    154e:	e9 85       	ldd	r30, Y+9	; 0x09
    1550:	fa 85       	ldd	r31, Y+10	; 0x0a
    1552:	81 e0       	ldi	r24, 0x01	; 1
    1554:	80 83       	st	Z, r24
    1556:	05 c0       	rjmp	.+10     	; 0x1562 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    1558:	89 81       	ldd	r24, Y+1	; 0x01
    155a:	8f 5f       	subi	r24, 0xFF	; 255
    155c:	eb 81       	ldd	r30, Y+3	; 0x03
    155e:	fc 81       	ldd	r31, Y+4	; 0x04
    1560:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1562:	81 e0       	ldi	r24, 0x01	; 1
    1564:	8e 83       	std	Y+6, r24	; 0x06
    1566:	01 c0       	rjmp	.+2      	; 0x156a <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1568:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    156a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    156c:	2a 96       	adiw	r28, 0x0a	; 10
    156e:	0f b6       	in	r0, 0x3f	; 63
    1570:	f8 94       	cli
    1572:	de bf       	out	0x3e, r29	; 62
    1574:	0f be       	out	0x3f, r0	; 63
    1576:	cd bf       	out	0x3d, r28	; 61
    1578:	cf 91       	pop	r28
    157a:	df 91       	pop	r29
    157c:	08 95       	ret

0000157e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    157e:	df 93       	push	r29
    1580:	cf 93       	push	r28
    1582:	cd b7       	in	r28, 0x3d	; 61
    1584:	de b7       	in	r29, 0x3e	; 62
    1586:	2e 97       	sbiw	r28, 0x0e	; 14
    1588:	0f b6       	in	r0, 0x3f	; 63
    158a:	f8 94       	cli
    158c:	de bf       	out	0x3e, r29	; 62
    158e:	0f be       	out	0x3f, r0	; 63
    1590:	cd bf       	out	0x3d, r28	; 61
    1592:	99 87       	std	Y+9, r25	; 0x09
    1594:	88 87       	std	Y+8, r24	; 0x08
    1596:	7b 87       	std	Y+11, r23	; 0x0b
    1598:	6a 87       	std	Y+10, r22	; 0x0a
    159a:	5d 87       	std	Y+13, r21	; 0x0d
    159c:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    159e:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    15a0:	88 85       	ldd	r24, Y+8	; 0x08
    15a2:	99 85       	ldd	r25, Y+9	; 0x09
    15a4:	9b 83       	std	Y+3, r25	; 0x03
    15a6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    15a8:	0f b6       	in	r0, 0x3f	; 63
    15aa:	f8 94       	cli
    15ac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    15ae:	ea 81       	ldd	r30, Y+2	; 0x02
    15b0:	fb 81       	ldd	r31, Y+3	; 0x03
    15b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    15b4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    15b6:	89 81       	ldd	r24, Y+1	; 0x01
    15b8:	88 23       	and	r24, r24
    15ba:	f9 f0       	breq	.+62     	; 0x15fa <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    15bc:	8a 81       	ldd	r24, Y+2	; 0x02
    15be:	9b 81       	ldd	r25, Y+3	; 0x03
    15c0:	2a 85       	ldd	r18, Y+10	; 0x0a
    15c2:	3b 85       	ldd	r19, Y+11	; 0x0b
    15c4:	b9 01       	movw	r22, r18
    15c6:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	81 50       	subi	r24, 0x01	; 1
    15ce:	ea 81       	ldd	r30, Y+2	; 0x02
    15d0:	fb 81       	ldd	r31, Y+3	; 0x03
    15d2:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    15d4:	ea 81       	ldd	r30, Y+2	; 0x02
    15d6:	fb 81       	ldd	r31, Y+3	; 0x03
    15d8:	80 85       	ldd	r24, Z+8	; 0x08
    15da:	88 23       	and	r24, r24
    15dc:	49 f0       	breq	.+18     	; 0x15f0 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    15de:	8a 81       	ldd	r24, Y+2	; 0x02
    15e0:	9b 81       	ldd	r25, Y+3	; 0x03
    15e2:	08 96       	adiw	r24, 0x08	; 8
    15e4:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    15e8:	88 23       	and	r24, r24
    15ea:	11 f0       	breq	.+4      	; 0x15f0 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    15ec:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    15f4:	81 e0       	ldi	r24, 0x01	; 1
    15f6:	8e 87       	std	Y+14, r24	; 0x0e
    15f8:	63 c0       	rjmp	.+198    	; 0x16c0 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    15fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    15fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    15fe:	00 97       	sbiw	r24, 0x00	; 0
    1600:	21 f4       	brne	.+8      	; 0x160a <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1602:	0f 90       	pop	r0
    1604:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1606:	1e 86       	std	Y+14, r1	; 0x0e
    1608:	5b c0       	rjmp	.+182    	; 0x16c0 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    160a:	8c 81       	ldd	r24, Y+4	; 0x04
    160c:	88 23       	and	r24, r24
    160e:	31 f4       	brne	.+12     	; 0x161c <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1610:	ce 01       	movw	r24, r28
    1612:	05 96       	adiw	r24, 0x05	; 5
    1614:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1618:	81 e0       	ldi	r24, 0x01	; 1
    161a:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    161c:	0f 90       	pop	r0
    161e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1620:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1624:	0f b6       	in	r0, 0x3f	; 63
    1626:	f8 94       	cli
    1628:	0f 92       	push	r0
    162a:	ea 81       	ldd	r30, Y+2	; 0x02
    162c:	fb 81       	ldd	r31, Y+3	; 0x03
    162e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1630:	8f 3f       	cpi	r24, 0xFF	; 255
    1632:	19 f4       	brne	.+6      	; 0x163a <xQueueReceive+0xbc>
    1634:	ea 81       	ldd	r30, Y+2	; 0x02
    1636:	fb 81       	ldd	r31, Y+3	; 0x03
    1638:	15 8e       	std	Z+29, r1	; 0x1d
    163a:	ea 81       	ldd	r30, Y+2	; 0x02
    163c:	fb 81       	ldd	r31, Y+3	; 0x03
    163e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1640:	8f 3f       	cpi	r24, 0xFF	; 255
    1642:	19 f4       	brne	.+6      	; 0x164a <xQueueReceive+0xcc>
    1644:	ea 81       	ldd	r30, Y+2	; 0x02
    1646:	fb 81       	ldd	r31, Y+3	; 0x03
    1648:	16 8e       	std	Z+30, r1	; 0x1e
    164a:	0f 90       	pop	r0
    164c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    164e:	ce 01       	movw	r24, r28
    1650:	05 96       	adiw	r24, 0x05	; 5
    1652:	9e 01       	movw	r18, r28
    1654:	24 5f       	subi	r18, 0xF4	; 244
    1656:	3f 4f       	sbci	r19, 0xFF	; 255
    1658:	b9 01       	movw	r22, r18
    165a:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <xTaskCheckForTimeOut>
    165e:	88 23       	and	r24, r24
    1660:	09 f5       	brne	.+66     	; 0x16a4 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1662:	8a 81       	ldd	r24, Y+2	; 0x02
    1664:	9b 81       	ldd	r25, Y+3	; 0x03
    1666:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    166a:	88 23       	and	r24, r24
    166c:	a1 f0       	breq	.+40     	; 0x1696 <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    166e:	8a 81       	ldd	r24, Y+2	; 0x02
    1670:	9b 81       	ldd	r25, Y+3	; 0x03
    1672:	41 96       	adiw	r24, 0x11	; 17
    1674:	2c 85       	ldd	r18, Y+12	; 0x0c
    1676:	3d 85       	ldd	r19, Y+13	; 0x0d
    1678:	b9 01       	movw	r22, r18
    167a:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    167e:	8a 81       	ldd	r24, Y+2	; 0x02
    1680:	9b 81       	ldd	r25, Y+3	; 0x03
    1682:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1686:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    168a:	88 23       	and	r24, r24
    168c:	09 f0       	breq	.+2      	; 0x1690 <xQueueReceive+0x112>
    168e:	8c cf       	rjmp	.-232    	; 0x15a8 <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    1690:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1694:	89 cf       	rjmp	.-238    	; 0x15a8 <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    1696:	8a 81       	ldd	r24, Y+2	; 0x02
    1698:	9b 81       	ldd	r25, Y+3	; 0x03
    169a:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    169e:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    16a2:	82 cf       	rjmp	.-252    	; 0x15a8 <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    16a4:	8a 81       	ldd	r24, Y+2	; 0x02
    16a6:	9b 81       	ldd	r25, Y+3	; 0x03
    16a8:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16ac:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    16b0:	8a 81       	ldd	r24, Y+2	; 0x02
    16b2:	9b 81       	ldd	r25, Y+3	; 0x03
    16b4:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    16b8:	88 23       	and	r24, r24
    16ba:	09 f4       	brne	.+2      	; 0x16be <xQueueReceive+0x140>
    16bc:	75 cf       	rjmp	.-278    	; 0x15a8 <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    16be:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    16c0:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    16c2:	2e 96       	adiw	r28, 0x0e	; 14
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	de bf       	out	0x3e, r29	; 62
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	cd bf       	out	0x3d, r28	; 61
    16ce:	cf 91       	pop	r28
    16d0:	df 91       	pop	r29
    16d2:	08 95       	ret

000016d4 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    16d4:	df 93       	push	r29
    16d6:	cf 93       	push	r28
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
    16dc:	2e 97       	sbiw	r28, 0x0e	; 14
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	0f be       	out	0x3f, r0	; 63
    16e6:	cd bf       	out	0x3d, r28	; 61
    16e8:	9b 87       	std	Y+11, r25	; 0x0b
    16ea:	8a 87       	std	Y+10, r24	; 0x0a
    16ec:	7d 87       	std	Y+13, r23	; 0x0d
    16ee:	6c 87       	std	Y+12, r22	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    16f0:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    16f2:	8a 85       	ldd	r24, Y+10	; 0x0a
    16f4:	9b 85       	ldd	r25, Y+11	; 0x0b
    16f6:	9d 83       	std	Y+5, r25	; 0x05
    16f8:	8c 83       	std	Y+4, r24	; 0x04

#if( configUSE_MUTEXES == 1 )
	BaseType_t xInheritanceOccurred = pdFALSE;
    16fa:	1b 82       	std	Y+3, r1	; 0x03
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	f8 94       	cli
    1700:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    1702:	ec 81       	ldd	r30, Y+4	; 0x04
    1704:	fd 81       	ldd	r31, Y+5	; 0x05
    1706:	82 8d       	ldd	r24, Z+26	; 0x1a
    1708:	8a 83       	std	Y+2, r24	; 0x02

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    170a:	8a 81       	ldd	r24, Y+2	; 0x02
    170c:	88 23       	and	r24, r24
    170e:	21 f1       	breq	.+72     	; 0x1758 <xQueueSemaphoreTake+0x84>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    1710:	8a 81       	ldd	r24, Y+2	; 0x02
    1712:	81 50       	subi	r24, 0x01	; 1
    1714:	ec 81       	ldd	r30, Y+4	; 0x04
    1716:	fd 81       	ldd	r31, Y+5	; 0x05
    1718:	82 8f       	std	Z+26, r24	; 0x1a

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    171a:	ec 81       	ldd	r30, Y+4	; 0x04
    171c:	fd 81       	ldd	r31, Y+5	; 0x05
    171e:	80 81       	ld	r24, Z
    1720:	91 81       	ldd	r25, Z+1	; 0x01
    1722:	00 97       	sbiw	r24, 0x00	; 0
    1724:	31 f4       	brne	.+12     	; 0x1732 <xQueueSemaphoreTake+0x5e>
					{
						/* Record the information required to implement
						priority inheritance should it become necessary. */
						pxQueue->u.xSemaphore.xMutexHolder = pvTaskIncrementMutexHeldCount();
    1726:	0e 94 15 22 	call	0x442a	; 0x442a <pvTaskIncrementMutexHeldCount>
    172a:	ec 81       	ldd	r30, Y+4	; 0x04
    172c:	fd 81       	ldd	r31, Y+5	; 0x05
    172e:	95 83       	std	Z+5, r25	; 0x05
    1730:	84 83       	std	Z+4, r24	; 0x04
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1732:	ec 81       	ldd	r30, Y+4	; 0x04
    1734:	fd 81       	ldd	r31, Y+5	; 0x05
    1736:	80 85       	ldd	r24, Z+8	; 0x08
    1738:	88 23       	and	r24, r24
    173a:	49 f0       	breq	.+18     	; 0x174e <xQueueSemaphoreTake+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    173c:	8c 81       	ldd	r24, Y+4	; 0x04
    173e:	9d 81       	ldd	r25, Y+5	; 0x05
    1740:	08 96       	adiw	r24, 0x08	; 8
    1742:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1746:	88 23       	and	r24, r24
    1748:	11 f0       	breq	.+4      	; 0x174e <xQueueSemaphoreTake+0x7a>
					{
						queueYIELD_IF_USING_PREEMPTION();
    174a:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    174e:	0f 90       	pop	r0
    1750:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	8e 87       	std	Y+14, r24	; 0x0e
    1756:	89 c0       	rjmp	.+274    	; 0x186a <xQueueSemaphoreTake+0x196>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1758:	8c 85       	ldd	r24, Y+12	; 0x0c
    175a:	9d 85       	ldd	r25, Y+13	; 0x0d
    175c:	00 97       	sbiw	r24, 0x00	; 0
    175e:	21 f4       	brne	.+8      	; 0x1768 <xQueueSemaphoreTake+0x94>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    1760:	0f 90       	pop	r0
    1762:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1764:	1e 86       	std	Y+14, r1	; 0x0e
    1766:	81 c0       	rjmp	.+258    	; 0x186a <xQueueSemaphoreTake+0x196>
				}
				else if( xEntryTimeSet == pdFALSE )
    1768:	8e 81       	ldd	r24, Y+6	; 0x06
    176a:	88 23       	and	r24, r24
    176c:	31 f4       	brne	.+12     	; 0x177a <xQueueSemaphoreTake+0xa6>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    176e:	ce 01       	movw	r24, r28
    1770:	07 96       	adiw	r24, 0x07	; 7
    1772:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1776:	81 e0       	ldi	r24, 0x01	; 1
    1778:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    177a:	0f 90       	pop	r0
    177c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    177e:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1782:	0f b6       	in	r0, 0x3f	; 63
    1784:	f8 94       	cli
    1786:	0f 92       	push	r0
    1788:	ec 81       	ldd	r30, Y+4	; 0x04
    178a:	fd 81       	ldd	r31, Y+5	; 0x05
    178c:	85 8d       	ldd	r24, Z+29	; 0x1d
    178e:	8f 3f       	cpi	r24, 0xFF	; 255
    1790:	19 f4       	brne	.+6      	; 0x1798 <xQueueSemaphoreTake+0xc4>
    1792:	ec 81       	ldd	r30, Y+4	; 0x04
    1794:	fd 81       	ldd	r31, Y+5	; 0x05
    1796:	15 8e       	std	Z+29, r1	; 0x1d
    1798:	ec 81       	ldd	r30, Y+4	; 0x04
    179a:	fd 81       	ldd	r31, Y+5	; 0x05
    179c:	86 8d       	ldd	r24, Z+30	; 0x1e
    179e:	8f 3f       	cpi	r24, 0xFF	; 255
    17a0:	19 f4       	brne	.+6      	; 0x17a8 <xQueueSemaphoreTake+0xd4>
    17a2:	ec 81       	ldd	r30, Y+4	; 0x04
    17a4:	fd 81       	ldd	r31, Y+5	; 0x05
    17a6:	16 8e       	std	Z+30, r1	; 0x1e
    17a8:	0f 90       	pop	r0
    17aa:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    17ac:	ce 01       	movw	r24, r28
    17ae:	07 96       	adiw	r24, 0x07	; 7
    17b0:	9e 01       	movw	r18, r28
    17b2:	24 5f       	subi	r18, 0xF4	; 244
    17b4:	3f 4f       	sbci	r19, 0xFF	; 255
    17b6:	b9 01       	movw	r22, r18
    17b8:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <xTaskCheckForTimeOut>
    17bc:	88 23       	and	r24, r24
    17be:	99 f5       	brne	.+102    	; 0x1826 <xQueueSemaphoreTake+0x152>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    17c0:	8c 81       	ldd	r24, Y+4	; 0x04
    17c2:	9d 81       	ldd	r25, Y+5	; 0x05
    17c4:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    17c8:	88 23       	and	r24, r24
    17ca:	31 f1       	breq	.+76     	; 0x1818 <xQueueSemaphoreTake+0x144>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    17cc:	ec 81       	ldd	r30, Y+4	; 0x04
    17ce:	fd 81       	ldd	r31, Y+5	; 0x05
    17d0:	80 81       	ld	r24, Z
    17d2:	91 81       	ldd	r25, Z+1	; 0x01
    17d4:	00 97       	sbiw	r24, 0x00	; 0
    17d6:	61 f4       	brne	.+24     	; 0x17f0 <xQueueSemaphoreTake+0x11c>
					{
						taskENTER_CRITICAL();
    17d8:	0f b6       	in	r0, 0x3f	; 63
    17da:	f8 94       	cli
    17dc:	0f 92       	push	r0
						{
							xInheritanceOccurred = xTaskPriorityInherit( pxQueue->u.xSemaphore.xMutexHolder );
    17de:	ec 81       	ldd	r30, Y+4	; 0x04
    17e0:	fd 81       	ldd	r31, Y+5	; 0x05
    17e2:	84 81       	ldd	r24, Z+4	; 0x04
    17e4:	95 81       	ldd	r25, Z+5	; 0x05
    17e6:	0e 94 49 20 	call	0x4092	; 0x4092 <xTaskPriorityInherit>
    17ea:	8b 83       	std	Y+3, r24	; 0x03
						}
						taskEXIT_CRITICAL();
    17ec:	0f 90       	pop	r0
    17ee:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    17f0:	8c 81       	ldd	r24, Y+4	; 0x04
    17f2:	9d 81       	ldd	r25, Y+5	; 0x05
    17f4:	41 96       	adiw	r24, 0x11	; 17
    17f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    17f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    17fa:	b9 01       	movw	r22, r18
    17fc:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1800:	8c 81       	ldd	r24, Y+4	; 0x04
    1802:	9d 81       	ldd	r25, Y+5	; 0x05
    1804:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1808:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    180c:	88 23       	and	r24, r24
    180e:	09 f0       	breq	.+2      	; 0x1812 <xQueueSemaphoreTake+0x13e>
    1810:	75 cf       	rjmp	.-278    	; 0x16fc <xQueueSemaphoreTake+0x28>
				{
					portYIELD_WITHIN_API();
    1812:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    1816:	72 cf       	rjmp	.-284    	; 0x16fc <xQueueSemaphoreTake+0x28>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    1818:	8c 81       	ldd	r24, Y+4	; 0x04
    181a:	9d 81       	ldd	r25, Y+5	; 0x05
    181c:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1820:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    1824:	6b cf       	rjmp	.-298    	; 0x16fc <xQueueSemaphoreTake+0x28>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    1826:	8c 81       	ldd	r24, Y+4	; 0x04
    1828:	9d 81       	ldd	r25, Y+5	; 0x05
    182a:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    182e:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1832:	8c 81       	ldd	r24, Y+4	; 0x04
    1834:	9d 81       	ldd	r25, Y+5	; 0x05
    1836:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    183a:	88 23       	and	r24, r24
    183c:	09 f4       	brne	.+2      	; 0x1840 <xQueueSemaphoreTake+0x16c>
    183e:	5e cf       	rjmp	.-324    	; 0x16fc <xQueueSemaphoreTake+0x28>
				#if ( configUSE_MUTEXES == 1 )
				{
					/* xInheritanceOccurred could only have be set if
					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
					test the mutex type again to check it is actually a mutex. */
					if( xInheritanceOccurred != pdFALSE )
    1840:	8b 81       	ldd	r24, Y+3	; 0x03
    1842:	88 23       	and	r24, r24
    1844:	89 f0       	breq	.+34     	; 0x1868 <xQueueSemaphoreTake+0x194>
					{
						taskENTER_CRITICAL();
    1846:	0f b6       	in	r0, 0x3f	; 63
    1848:	f8 94       	cli
    184a:	0f 92       	push	r0
							/* This task blocking on the mutex caused another
							task to inherit this task's priority.  Now this task
							has timed out the priority should be disinherited
							again, but only as low as the next highest priority
							task that is waiting for the same mutex. */
							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
    184c:	8c 81       	ldd	r24, Y+4	; 0x04
    184e:	9d 81       	ldd	r25, Y+5	; 0x05
    1850:	0e 94 ef 0d 	call	0x1bde	; 0x1bde <prvGetDisinheritPriorityAfterTimeout>
    1854:	89 83       	std	Y+1, r24	; 0x01
							vTaskPriorityDisinheritAfterTimeout( pxQueue->u.xSemaphore.xMutexHolder, uxHighestWaitingPriority );
    1856:	ec 81       	ldd	r30, Y+4	; 0x04
    1858:	fd 81       	ldd	r31, Y+5	; 0x05
    185a:	84 81       	ldd	r24, Z+4	; 0x04
    185c:	95 81       	ldd	r25, Z+5	; 0x05
    185e:	69 81       	ldd	r22, Y+1	; 0x01
    1860:	0e 94 59 21 	call	0x42b2	; 0x42b2 <vTaskPriorityDisinheritAfterTimeout>
						}
						taskEXIT_CRITICAL();
    1864:	0f 90       	pop	r0
    1866:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    1868:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    186a:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    186c:	2e 96       	adiw	r28, 0x0e	; 14
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	de bf       	out	0x3e, r29	; 62
    1874:	0f be       	out	0x3f, r0	; 63
    1876:	cd bf       	out	0x3d, r28	; 61
    1878:	cf 91       	pop	r28
    187a:	df 91       	pop	r29
    187c:	08 95       	ret

0000187e <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    187e:	df 93       	push	r29
    1880:	cf 93       	push	r28
    1882:	cd b7       	in	r28, 0x3d	; 61
    1884:	de b7       	in	r29, 0x3e	; 62
    1886:	60 97       	sbiw	r28, 0x10	; 16
    1888:	0f b6       	in	r0, 0x3f	; 63
    188a:	f8 94       	cli
    188c:	de bf       	out	0x3e, r29	; 62
    188e:	0f be       	out	0x3f, r0	; 63
    1890:	cd bf       	out	0x3d, r28	; 61
    1892:	9b 87       	std	Y+11, r25	; 0x0b
    1894:	8a 87       	std	Y+10, r24	; 0x0a
    1896:	7d 87       	std	Y+13, r23	; 0x0d
    1898:	6c 87       	std	Y+12, r22	; 0x0c
    189a:	5f 87       	std	Y+15, r21	; 0x0f
    189c:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    189e:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    18a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    18a2:	9b 85       	ldd	r25, Y+11	; 0x0b
    18a4:	9b 83       	std	Y+3, r25	; 0x03
    18a6:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    18a8:	0f b6       	in	r0, 0x3f	; 63
    18aa:	f8 94       	cli
    18ac:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    18ae:	ea 81       	ldd	r30, Y+2	; 0x02
    18b0:	fb 81       	ldd	r31, Y+3	; 0x03
    18b2:	82 8d       	ldd	r24, Z+26	; 0x1a
    18b4:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    18b6:	89 81       	ldd	r24, Y+1	; 0x01
    18b8:	88 23       	and	r24, r24
    18ba:	31 f1       	breq	.+76     	; 0x1908 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    18bc:	ea 81       	ldd	r30, Y+2	; 0x02
    18be:	fb 81       	ldd	r31, Y+3	; 0x03
    18c0:	86 81       	ldd	r24, Z+6	; 0x06
    18c2:	97 81       	ldd	r25, Z+7	; 0x07
    18c4:	9d 83       	std	Y+5, r25	; 0x05
    18c6:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    18c8:	8a 81       	ldd	r24, Y+2	; 0x02
    18ca:	9b 81       	ldd	r25, Y+3	; 0x03
    18cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    18ce:	3d 85       	ldd	r19, Y+13	; 0x0d
    18d0:	b9 01       	movw	r22, r18
    18d2:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    18d6:	ea 81       	ldd	r30, Y+2	; 0x02
    18d8:	fb 81       	ldd	r31, Y+3	; 0x03
    18da:	8c 81       	ldd	r24, Y+4	; 0x04
    18dc:	9d 81       	ldd	r25, Y+5	; 0x05
    18de:	97 83       	std	Z+7, r25	; 0x07
    18e0:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18e2:	ea 81       	ldd	r30, Y+2	; 0x02
    18e4:	fb 81       	ldd	r31, Y+3	; 0x03
    18e6:	81 89       	ldd	r24, Z+17	; 0x11
    18e8:	88 23       	and	r24, r24
    18ea:	49 f0       	breq	.+18     	; 0x18fe <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18ec:	8a 81       	ldd	r24, Y+2	; 0x02
    18ee:	9b 81       	ldd	r25, Y+3	; 0x03
    18f0:	41 96       	adiw	r24, 0x11	; 17
    18f2:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    18f6:	88 23       	and	r24, r24
    18f8:	11 f0       	breq	.+4      	; 0x18fe <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    18fa:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    18fe:	0f 90       	pop	r0
    1900:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	88 8b       	std	Y+16, r24	; 0x10
    1906:	63 c0       	rjmp	.+198    	; 0x19ce <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1908:	8e 85       	ldd	r24, Y+14	; 0x0e
    190a:	9f 85       	ldd	r25, Y+15	; 0x0f
    190c:	00 97       	sbiw	r24, 0x00	; 0
    190e:	21 f4       	brne	.+8      	; 0x1918 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1910:	0f 90       	pop	r0
    1912:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1914:	18 8a       	std	Y+16, r1	; 0x10
    1916:	5b c0       	rjmp	.+182    	; 0x19ce <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1918:	8e 81       	ldd	r24, Y+6	; 0x06
    191a:	88 23       	and	r24, r24
    191c:	31 f4       	brne	.+12     	; 0x192a <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    191e:	ce 01       	movw	r24, r28
    1920:	07 96       	adiw	r24, 0x07	; 7
    1922:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1926:	81 e0       	ldi	r24, 0x01	; 1
    1928:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    192a:	0f 90       	pop	r0
    192c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    192e:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	0f 92       	push	r0
    1938:	ea 81       	ldd	r30, Y+2	; 0x02
    193a:	fb 81       	ldd	r31, Y+3	; 0x03
    193c:	85 8d       	ldd	r24, Z+29	; 0x1d
    193e:	8f 3f       	cpi	r24, 0xFF	; 255
    1940:	19 f4       	brne	.+6      	; 0x1948 <xQueuePeek+0xca>
    1942:	ea 81       	ldd	r30, Y+2	; 0x02
    1944:	fb 81       	ldd	r31, Y+3	; 0x03
    1946:	15 8e       	std	Z+29, r1	; 0x1d
    1948:	ea 81       	ldd	r30, Y+2	; 0x02
    194a:	fb 81       	ldd	r31, Y+3	; 0x03
    194c:	86 8d       	ldd	r24, Z+30	; 0x1e
    194e:	8f 3f       	cpi	r24, 0xFF	; 255
    1950:	19 f4       	brne	.+6      	; 0x1958 <xQueuePeek+0xda>
    1952:	ea 81       	ldd	r30, Y+2	; 0x02
    1954:	fb 81       	ldd	r31, Y+3	; 0x03
    1956:	16 8e       	std	Z+30, r1	; 0x1e
    1958:	0f 90       	pop	r0
    195a:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    195c:	ce 01       	movw	r24, r28
    195e:	07 96       	adiw	r24, 0x07	; 7
    1960:	9e 01       	movw	r18, r28
    1962:	22 5f       	subi	r18, 0xF2	; 242
    1964:	3f 4f       	sbci	r19, 0xFF	; 255
    1966:	b9 01       	movw	r22, r18
    1968:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <xTaskCheckForTimeOut>
    196c:	88 23       	and	r24, r24
    196e:	09 f5       	brne	.+66     	; 0x19b2 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1970:	8a 81       	ldd	r24, Y+2	; 0x02
    1972:	9b 81       	ldd	r25, Y+3	; 0x03
    1974:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    1978:	88 23       	and	r24, r24
    197a:	a1 f0       	breq	.+40     	; 0x19a4 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    197c:	8a 81       	ldd	r24, Y+2	; 0x02
    197e:	9b 81       	ldd	r25, Y+3	; 0x03
    1980:	41 96       	adiw	r24, 0x11	; 17
    1982:	2e 85       	ldd	r18, Y+14	; 0x0e
    1984:	3f 85       	ldd	r19, Y+15	; 0x0f
    1986:	b9 01       	movw	r22, r18
    1988:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    198c:	8a 81       	ldd	r24, Y+2	; 0x02
    198e:	9b 81       	ldd	r25, Y+3	; 0x03
    1990:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1994:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    1998:	88 23       	and	r24, r24
    199a:	09 f0       	breq	.+2      	; 0x199e <xQueuePeek+0x120>
    199c:	85 cf       	rjmp	.-246    	; 0x18a8 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    199e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    19a2:	82 cf       	rjmp	.-252    	; 0x18a8 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    19a4:	8a 81       	ldd	r24, Y+2	; 0x02
    19a6:	9b 81       	ldd	r25, Y+3	; 0x03
    19a8:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    19ac:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    19b0:	7b cf       	rjmp	.-266    	; 0x18a8 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    19b2:	8a 81       	ldd	r24, Y+2	; 0x02
    19b4:	9b 81       	ldd	r25, Y+3	; 0x03
    19b6:	0e 94 0f 0f 	call	0x1e1e	; 0x1e1e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    19ba:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    19be:	8a 81       	ldd	r24, Y+2	; 0x02
    19c0:	9b 81       	ldd	r25, Y+3	; 0x03
    19c2:	0e 94 62 0f 	call	0x1ec4	; 0x1ec4 <prvIsQueueEmpty>
    19c6:	88 23       	and	r24, r24
    19c8:	09 f4       	brne	.+2      	; 0x19cc <xQueuePeek+0x14e>
    19ca:	6e cf       	rjmp	.-292    	; 0x18a8 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    19cc:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    19ce:	88 89       	ldd	r24, Y+16	; 0x10
}
    19d0:	60 96       	adiw	r28, 0x10	; 16
    19d2:	0f b6       	in	r0, 0x3f	; 63
    19d4:	f8 94       	cli
    19d6:	de bf       	out	0x3e, r29	; 62
    19d8:	0f be       	out	0x3f, r0	; 63
    19da:	cd bf       	out	0x3d, r28	; 61
    19dc:	cf 91       	pop	r28
    19de:	df 91       	pop	r29
    19e0:	08 95       	ret

000019e2 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    19e2:	df 93       	push	r29
    19e4:	cf 93       	push	r28
    19e6:	cd b7       	in	r28, 0x3d	; 61
    19e8:	de b7       	in	r29, 0x3e	; 62
    19ea:	2c 97       	sbiw	r28, 0x0c	; 12
    19ec:	0f b6       	in	r0, 0x3f	; 63
    19ee:	f8 94       	cli
    19f0:	de bf       	out	0x3e, r29	; 62
    19f2:	0f be       	out	0x3f, r0	; 63
    19f4:	cd bf       	out	0x3d, r28	; 61
    19f6:	98 87       	std	Y+8, r25	; 0x08
    19f8:	8f 83       	std	Y+7, r24	; 0x07
    19fa:	7a 87       	std	Y+10, r23	; 0x0a
    19fc:	69 87       	std	Y+9, r22	; 0x09
    19fe:	5c 87       	std	Y+12, r21	; 0x0c
    1a00:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    1a02:	8f 81       	ldd	r24, Y+7	; 0x07
    1a04:	98 85       	ldd	r25, Y+8	; 0x08
    1a06:	9c 83       	std	Y+4, r25	; 0x04
    1a08:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1a0a:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a10:	82 8d       	ldd	r24, Z+26	; 0x1a
    1a12:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1a14:	8a 81       	ldd	r24, Y+2	; 0x02
    1a16:	88 23       	and	r24, r24
    1a18:	81 f1       	breq	.+96     	; 0x1a7a <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    1a1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a20:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a22:	8b 81       	ldd	r24, Y+3	; 0x03
    1a24:	9c 81       	ldd	r25, Y+4	; 0x04
    1a26:	29 85       	ldd	r18, Y+9	; 0x09
    1a28:	3a 85       	ldd	r19, Y+10	; 0x0a
    1a2a:	b9 01       	movw	r22, r18
    1a2c:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    1a30:	8a 81       	ldd	r24, Y+2	; 0x02
    1a32:	81 50       	subi	r24, 0x01	; 1
    1a34:	eb 81       	ldd	r30, Y+3	; 0x03
    1a36:	fc 81       	ldd	r31, Y+4	; 0x04
    1a38:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    1a3a:	89 81       	ldd	r24, Y+1	; 0x01
    1a3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a3e:	a9 f4       	brne	.+42     	; 0x1a6a <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a40:	eb 81       	ldd	r30, Y+3	; 0x03
    1a42:	fc 81       	ldd	r31, Y+4	; 0x04
    1a44:	80 85       	ldd	r24, Z+8	; 0x08
    1a46:	88 23       	and	r24, r24
    1a48:	a9 f0       	breq	.+42     	; 0x1a74 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a4e:	08 96       	adiw	r24, 0x08	; 8
    1a50:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1a54:	88 23       	and	r24, r24
    1a56:	71 f0       	breq	.+28     	; 0x1a74 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1a58:	8b 85       	ldd	r24, Y+11	; 0x0b
    1a5a:	9c 85       	ldd	r25, Y+12	; 0x0c
    1a5c:	00 97       	sbiw	r24, 0x00	; 0
    1a5e:	51 f0       	breq	.+20     	; 0x1a74 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1a60:	eb 85       	ldd	r30, Y+11	; 0x0b
    1a62:	fc 85       	ldd	r31, Y+12	; 0x0c
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	80 83       	st	Z, r24
    1a68:	05 c0       	rjmp	.+10     	; 0x1a74 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    1a6a:	89 81       	ldd	r24, Y+1	; 0x01
    1a6c:	8f 5f       	subi	r24, 0xFF	; 255
    1a6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a70:	fc 81       	ldd	r31, Y+4	; 0x04
    1a72:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1a74:	81 e0       	ldi	r24, 0x01	; 1
    1a76:	8e 83       	std	Y+6, r24	; 0x06
    1a78:	01 c0       	rjmp	.+2      	; 0x1a7c <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    1a7a:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1a7c:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1a7e:	2c 96       	adiw	r28, 0x0c	; 12
    1a80:	0f b6       	in	r0, 0x3f	; 63
    1a82:	f8 94       	cli
    1a84:	de bf       	out	0x3e, r29	; 62
    1a86:	0f be       	out	0x3f, r0	; 63
    1a88:	cd bf       	out	0x3d, r28	; 61
    1a8a:	cf 91       	pop	r28
    1a8c:	df 91       	pop	r29
    1a8e:	08 95       	ret

00001a90 <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    1a90:	df 93       	push	r29
    1a92:	cf 93       	push	r28
    1a94:	cd b7       	in	r28, 0x3d	; 61
    1a96:	de b7       	in	r29, 0x3e	; 62
    1a98:	2a 97       	sbiw	r28, 0x0a	; 10
    1a9a:	0f b6       	in	r0, 0x3f	; 63
    1a9c:	f8 94       	cli
    1a9e:	de bf       	out	0x3e, r29	; 62
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	cd bf       	out	0x3d, r28	; 61
    1aa4:	98 87       	std	Y+8, r25	; 0x08
    1aa6:	8f 83       	std	Y+7, r24	; 0x07
    1aa8:	7a 87       	std	Y+10, r23	; 0x0a
    1aaa:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    1aac:	8f 81       	ldd	r24, Y+7	; 0x07
    1aae:	98 85       	ldd	r25, Y+8	; 0x08
    1ab0:	9a 83       	std	Y+2, r25	; 0x02
    1ab2:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1ab4:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ab6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab8:	fa 81       	ldd	r31, Y+2	; 0x02
    1aba:	82 8d       	ldd	r24, Z+26	; 0x1a
    1abc:	88 23       	and	r24, r24
    1abe:	b1 f0       	breq	.+44     	; 0x1aec <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    1ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    1ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    1ac4:	86 81       	ldd	r24, Z+6	; 0x06
    1ac6:	97 81       	ldd	r25, Z+7	; 0x07
    1ac8:	9c 83       	std	Y+4, r25	; 0x04
    1aca:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1acc:	89 81       	ldd	r24, Y+1	; 0x01
    1ace:	9a 81       	ldd	r25, Y+2	; 0x02
    1ad0:	29 85       	ldd	r18, Y+9	; 0x09
    1ad2:	3a 85       	ldd	r19, Y+10	; 0x0a
    1ad4:	b9 01       	movw	r22, r18
    1ad6:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    1ada:	e9 81       	ldd	r30, Y+1	; 0x01
    1adc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ade:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ae2:	97 83       	std	Z+7, r25	; 0x07
    1ae4:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	8e 83       	std	Y+6, r24	; 0x06
    1aea:	01 c0       	rjmp	.+2      	; 0x1aee <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    1aec:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    1aee:	8e 81       	ldd	r24, Y+6	; 0x06
}
    1af0:	2a 96       	adiw	r28, 0x0a	; 10
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	de bf       	out	0x3e, r29	; 62
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	cd bf       	out	0x3d, r28	; 61
    1afc:	cf 91       	pop	r28
    1afe:	df 91       	pop	r29
    1b00:	08 95       	ret

00001b02 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    1b02:	df 93       	push	r29
    1b04:	cf 93       	push	r28
    1b06:	00 d0       	rcall	.+0      	; 0x1b08 <uxQueueMessagesWaiting+0x6>
    1b08:	0f 92       	push	r0
    1b0a:	cd b7       	in	r28, 0x3d	; 61
    1b0c:	de b7       	in	r29, 0x3e	; 62
    1b0e:	9b 83       	std	Y+3, r25	; 0x03
    1b10:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1b12:	0f b6       	in	r0, 0x3f	; 63
    1b14:	f8 94       	cli
    1b16:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    1b18:	ea 81       	ldd	r30, Y+2	; 0x02
    1b1a:	fb 81       	ldd	r31, Y+3	; 0x03
    1b1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b1e:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1b24:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b26:	0f 90       	pop	r0
    1b28:	0f 90       	pop	r0
    1b2a:	0f 90       	pop	r0
    1b2c:	cf 91       	pop	r28
    1b2e:	df 91       	pop	r29
    1b30:	08 95       	ret

00001b32 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    1b32:	df 93       	push	r29
    1b34:	cf 93       	push	r28
    1b36:	00 d0       	rcall	.+0      	; 0x1b38 <uxQueueSpacesAvailable+0x6>
    1b38:	00 d0       	rcall	.+0      	; 0x1b3a <uxQueueSpacesAvailable+0x8>
    1b3a:	0f 92       	push	r0
    1b3c:	cd b7       	in	r28, 0x3d	; 61
    1b3e:	de b7       	in	r29, 0x3e	; 62
    1b40:	9d 83       	std	Y+5, r25	; 0x05
    1b42:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1b44:	8c 81       	ldd	r24, Y+4	; 0x04
    1b46:	9d 81       	ldd	r25, Y+5	; 0x05
    1b48:	9a 83       	std	Y+2, r25	; 0x02
    1b4a:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1b4c:	0f b6       	in	r0, 0x3f	; 63
    1b4e:	f8 94       	cli
    1b50:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    1b52:	e9 81       	ldd	r30, Y+1	; 0x01
    1b54:	fa 81       	ldd	r31, Y+2	; 0x02
    1b56:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b58:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b5e:	29 2f       	mov	r18, r25
    1b60:	28 1b       	sub	r18, r24
    1b62:	82 2f       	mov	r24, r18
    1b64:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    1b66:	0f 90       	pop	r0
    1b68:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    1b6a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1b6c:	0f 90       	pop	r0
    1b6e:	0f 90       	pop	r0
    1b70:	0f 90       	pop	r0
    1b72:	0f 90       	pop	r0
    1b74:	0f 90       	pop	r0
    1b76:	cf 91       	pop	r28
    1b78:	df 91       	pop	r29
    1b7a:	08 95       	ret

00001b7c <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    1b7c:	df 93       	push	r29
    1b7e:	cf 93       	push	r28
    1b80:	00 d0       	rcall	.+0      	; 0x1b82 <uxQueueMessagesWaitingFromISR+0x6>
    1b82:	00 d0       	rcall	.+0      	; 0x1b84 <uxQueueMessagesWaitingFromISR+0x8>
    1b84:	0f 92       	push	r0
    1b86:	cd b7       	in	r28, 0x3d	; 61
    1b88:	de b7       	in	r29, 0x3e	; 62
    1b8a:	9d 83       	std	Y+5, r25	; 0x05
    1b8c:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    1b8e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b90:	9d 81       	ldd	r25, Y+5	; 0x05
    1b92:	9a 83       	std	Y+2, r25	; 0x02
    1b94:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    1b96:	e9 81       	ldd	r30, Y+1	; 0x01
    1b98:	fa 81       	ldd	r31, Y+2	; 0x02
    1b9a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b9c:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    1b9e:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    1ba0:	0f 90       	pop	r0
    1ba2:	0f 90       	pop	r0
    1ba4:	0f 90       	pop	r0
    1ba6:	0f 90       	pop	r0
    1ba8:	0f 90       	pop	r0
    1baa:	cf 91       	pop	r28
    1bac:	df 91       	pop	r29
    1bae:	08 95       	ret

00001bb0 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    1bb0:	df 93       	push	r29
    1bb2:	cf 93       	push	r28
    1bb4:	00 d0       	rcall	.+0      	; 0x1bb6 <vQueueDelete+0x6>
    1bb6:	00 d0       	rcall	.+0      	; 0x1bb8 <vQueueDelete+0x8>
    1bb8:	cd b7       	in	r28, 0x3d	; 61
    1bba:	de b7       	in	r29, 0x3e	; 62
    1bbc:	9c 83       	std	Y+4, r25	; 0x04
    1bbe:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    1bc0:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc2:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc4:	9a 83       	std	Y+2, r25	; 0x02
    1bc6:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    1bc8:	89 81       	ldd	r24, Y+1	; 0x01
    1bca:	9a 81       	ldd	r25, Y+2	; 0x02
    1bcc:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    1bd0:	0f 90       	pop	r0
    1bd2:	0f 90       	pop	r0
    1bd4:	0f 90       	pop	r0
    1bd6:	0f 90       	pop	r0
    1bd8:	cf 91       	pop	r28
    1bda:	df 91       	pop	r29
    1bdc:	08 95       	ret

00001bde <prvGetDisinheritPriorityAfterTimeout>:
/*-----------------------------------------------------------*/

#if( configUSE_MUTEXES == 1 )

	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
	{
    1bde:	df 93       	push	r29
    1be0:	cf 93       	push	r28
    1be2:	00 d0       	rcall	.+0      	; 0x1be4 <prvGetDisinheritPriorityAfterTimeout+0x6>
    1be4:	0f 92       	push	r0
    1be6:	cd b7       	in	r28, 0x3d	; 61
    1be8:	de b7       	in	r29, 0x3e	; 62
    1bea:	9b 83       	std	Y+3, r25	; 0x03
    1bec:	8a 83       	std	Y+2, r24	; 0x02
		priority, but the waiting task times out, then the holder should
		disinherit the priority - but only down to the highest priority of any
		other tasks that are waiting for the same mutex.  For this purpose,
		return the priority of the highest priority task that is waiting for the
		mutex. */
		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0U )
    1bee:	ea 81       	ldd	r30, Y+2	; 0x02
    1bf0:	fb 81       	ldd	r31, Y+3	; 0x03
    1bf2:	81 89       	ldd	r24, Z+17	; 0x11
    1bf4:	88 23       	and	r24, r24
    1bf6:	61 f0       	breq	.+24     	; 0x1c10 <prvGetDisinheritPriorityAfterTimeout+0x32>
		{
			uxHighestPriorityOfWaitingTasks = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
    1bf8:	ea 81       	ldd	r30, Y+2	; 0x02
    1bfa:	fb 81       	ldd	r31, Y+3	; 0x03
    1bfc:	06 88       	ldd	r0, Z+22	; 0x16
    1bfe:	f7 89       	ldd	r31, Z+23	; 0x17
    1c00:	e0 2d       	mov	r30, r0
    1c02:	80 81       	ld	r24, Z
    1c04:	91 81       	ldd	r25, Z+1	; 0x01
    1c06:	98 2f       	mov	r25, r24
    1c08:	84 e0       	ldi	r24, 0x04	; 4
    1c0a:	89 1b       	sub	r24, r25
    1c0c:	89 83       	std	Y+1, r24	; 0x01
    1c0e:	01 c0       	rjmp	.+2      	; 0x1c12 <prvGetDisinheritPriorityAfterTimeout+0x34>
		}
		else
		{
			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
    1c10:	19 82       	std	Y+1, r1	; 0x01
		}

		return uxHighestPriorityOfWaitingTasks;
    1c12:	89 81       	ldd	r24, Y+1	; 0x01
	}
    1c14:	0f 90       	pop	r0
    1c16:	0f 90       	pop	r0
    1c18:	0f 90       	pop	r0
    1c1a:	cf 91       	pop	r28
    1c1c:	df 91       	pop	r29
    1c1e:	08 95       	ret

00001c20 <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    1c20:	df 93       	push	r29
    1c22:	cf 93       	push	r28
    1c24:	cd b7       	in	r28, 0x3d	; 61
    1c26:	de b7       	in	r29, 0x3e	; 62
    1c28:	27 97       	sbiw	r28, 0x07	; 7
    1c2a:	0f b6       	in	r0, 0x3f	; 63
    1c2c:	f8 94       	cli
    1c2e:	de bf       	out	0x3e, r29	; 62
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	cd bf       	out	0x3d, r28	; 61
    1c34:	9c 83       	std	Y+4, r25	; 0x04
    1c36:	8b 83       	std	Y+3, r24	; 0x03
    1c38:	7e 83       	std	Y+6, r23	; 0x06
    1c3a:	6d 83       	std	Y+5, r22	; 0x05
    1c3c:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    1c3e:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    1c40:	eb 81       	ldd	r30, Y+3	; 0x03
    1c42:	fc 81       	ldd	r31, Y+4	; 0x04
    1c44:	82 8d       	ldd	r24, Z+26	; 0x1a
    1c46:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    1c48:	eb 81       	ldd	r30, Y+3	; 0x03
    1c4a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c4c:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c4e:	88 23       	and	r24, r24
    1c50:	99 f4       	brne	.+38     	; 0x1c78 <prvCopyDataToQueue+0x58>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1c52:	eb 81       	ldd	r30, Y+3	; 0x03
    1c54:	fc 81       	ldd	r31, Y+4	; 0x04
    1c56:	80 81       	ld	r24, Z
    1c58:	91 81       	ldd	r25, Z+1	; 0x01
    1c5a:	00 97       	sbiw	r24, 0x00	; 0
    1c5c:	09 f0       	breq	.+2      	; 0x1c60 <prvCopyDataToQueue+0x40>
    1c5e:	89 c0       	rjmp	.+274    	; 0x1d72 <prvCopyDataToQueue+0x152>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( pxQueue->u.xSemaphore.xMutexHolder );
    1c60:	eb 81       	ldd	r30, Y+3	; 0x03
    1c62:	fc 81       	ldd	r31, Y+4	; 0x04
    1c64:	84 81       	ldd	r24, Z+4	; 0x04
    1c66:	95 81       	ldd	r25, Z+5	; 0x05
    1c68:	0e 94 e7 20 	call	0x41ce	; 0x41ce <xTaskPriorityDisinherit>
    1c6c:	8a 83       	std	Y+2, r24	; 0x02
				pxQueue->u.xSemaphore.xMutexHolder = NULL;
    1c6e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c70:	fc 81       	ldd	r31, Y+4	; 0x04
    1c72:	15 82       	std	Z+5, r1	; 0x05
    1c74:	14 82       	std	Z+4, r1	; 0x04
    1c76:	7d c0       	rjmp	.+250    	; 0x1d72 <prvCopyDataToQueue+0x152>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    1c78:	8f 81       	ldd	r24, Y+7	; 0x07
    1c7a:	88 23       	and	r24, r24
    1c7c:	99 f5       	brne	.+102    	; 0x1ce4 <prvCopyDataToQueue+0xc4>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1c7e:	eb 81       	ldd	r30, Y+3	; 0x03
    1c80:	fc 81       	ldd	r31, Y+4	; 0x04
    1c82:	62 81       	ldd	r22, Z+2	; 0x02
    1c84:	73 81       	ldd	r23, Z+3	; 0x03
    1c86:	eb 81       	ldd	r30, Y+3	; 0x03
    1c88:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8a:	84 8d       	ldd	r24, Z+28	; 0x1c
    1c8c:	48 2f       	mov	r20, r24
    1c8e:	50 e0       	ldi	r21, 0x00	; 0
    1c90:	2d 81       	ldd	r18, Y+5	; 0x05
    1c92:	3e 81       	ldd	r19, Y+6	; 0x06
    1c94:	cb 01       	movw	r24, r22
    1c96:	b9 01       	movw	r22, r18
    1c98:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	22 81       	ldd	r18, Z+2	; 0x02
    1ca2:	33 81       	ldd	r19, Z+3	; 0x03
    1ca4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ca6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1caa:	88 2f       	mov	r24, r24
    1cac:	90 e0       	ldi	r25, 0x00	; 0
    1cae:	82 0f       	add	r24, r18
    1cb0:	93 1f       	adc	r25, r19
    1cb2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb6:	93 83       	std	Z+3, r25	; 0x03
    1cb8:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1cba:	eb 81       	ldd	r30, Y+3	; 0x03
    1cbc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cbe:	22 81       	ldd	r18, Z+2	; 0x02
    1cc0:	33 81       	ldd	r19, Z+3	; 0x03
    1cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc6:	84 81       	ldd	r24, Z+4	; 0x04
    1cc8:	95 81       	ldd	r25, Z+5	; 0x05
    1cca:	28 17       	cp	r18, r24
    1ccc:	39 07       	cpc	r19, r25
    1cce:	08 f4       	brcc	.+2      	; 0x1cd2 <prvCopyDataToQueue+0xb2>
    1cd0:	50 c0       	rjmp	.+160    	; 0x1d72 <prvCopyDataToQueue+0x152>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd6:	80 81       	ld	r24, Z
    1cd8:	91 81       	ldd	r25, Z+1	; 0x01
    1cda:	eb 81       	ldd	r30, Y+3	; 0x03
    1cdc:	fc 81       	ldd	r31, Y+4	; 0x04
    1cde:	93 83       	std	Z+3, r25	; 0x03
    1ce0:	82 83       	std	Z+2, r24	; 0x02
    1ce2:	47 c0       	rjmp	.+142    	; 0x1d72 <prvCopyDataToQueue+0x152>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    1ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce8:	66 81       	ldd	r22, Z+6	; 0x06
    1cea:	77 81       	ldd	r23, Z+7	; 0x07
    1cec:	eb 81       	ldd	r30, Y+3	; 0x03
    1cee:	fc 81       	ldd	r31, Y+4	; 0x04
    1cf0:	84 8d       	ldd	r24, Z+28	; 0x1c
    1cf2:	48 2f       	mov	r20, r24
    1cf4:	50 e0       	ldi	r21, 0x00	; 0
    1cf6:	2d 81       	ldd	r18, Y+5	; 0x05
    1cf8:	3e 81       	ldd	r19, Y+6	; 0x06
    1cfa:	cb 01       	movw	r24, r22
    1cfc:	b9 01       	movw	r22, r18
    1cfe:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    1d02:	eb 81       	ldd	r30, Y+3	; 0x03
    1d04:	fc 81       	ldd	r31, Y+4	; 0x04
    1d06:	26 81       	ldd	r18, Z+6	; 0x06
    1d08:	37 81       	ldd	r19, Z+7	; 0x07
    1d0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0e:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d10:	88 2f       	mov	r24, r24
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	90 95       	com	r25
    1d16:	81 95       	neg	r24
    1d18:	9f 4f       	sbci	r25, 0xFF	; 255
    1d1a:	82 0f       	add	r24, r18
    1d1c:	93 1f       	adc	r25, r19
    1d1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d20:	fc 81       	ldd	r31, Y+4	; 0x04
    1d22:	97 83       	std	Z+7, r25	; 0x07
    1d24:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    1d26:	eb 81       	ldd	r30, Y+3	; 0x03
    1d28:	fc 81       	ldd	r31, Y+4	; 0x04
    1d2a:	26 81       	ldd	r18, Z+6	; 0x06
    1d2c:	37 81       	ldd	r19, Z+7	; 0x07
    1d2e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d30:	fc 81       	ldd	r31, Y+4	; 0x04
    1d32:	80 81       	ld	r24, Z
    1d34:	91 81       	ldd	r25, Z+1	; 0x01
    1d36:	28 17       	cp	r18, r24
    1d38:	39 07       	cpc	r19, r25
    1d3a:	90 f4       	brcc	.+36     	; 0x1d60 <prvCopyDataToQueue+0x140>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    1d3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d40:	24 81       	ldd	r18, Z+4	; 0x04
    1d42:	35 81       	ldd	r19, Z+5	; 0x05
    1d44:	eb 81       	ldd	r30, Y+3	; 0x03
    1d46:	fc 81       	ldd	r31, Y+4	; 0x04
    1d48:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d4a:	88 2f       	mov	r24, r24
    1d4c:	90 e0       	ldi	r25, 0x00	; 0
    1d4e:	90 95       	com	r25
    1d50:	81 95       	neg	r24
    1d52:	9f 4f       	sbci	r25, 0xFF	; 255
    1d54:	82 0f       	add	r24, r18
    1d56:	93 1f       	adc	r25, r19
    1d58:	eb 81       	ldd	r30, Y+3	; 0x03
    1d5a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d5c:	97 83       	std	Z+7, r25	; 0x07
    1d5e:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    1d60:	8f 81       	ldd	r24, Y+7	; 0x07
    1d62:	82 30       	cpi	r24, 0x02	; 2
    1d64:	31 f4       	brne	.+12     	; 0x1d72 <prvCopyDataToQueue+0x152>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    1d66:	89 81       	ldd	r24, Y+1	; 0x01
    1d68:	88 23       	and	r24, r24
    1d6a:	19 f0       	breq	.+6      	; 0x1d72 <prvCopyDataToQueue+0x152>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    1d6c:	89 81       	ldd	r24, Y+1	; 0x01
    1d6e:	81 50       	subi	r24, 0x01	; 1
    1d70:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    1d72:	89 81       	ldd	r24, Y+1	; 0x01
    1d74:	8f 5f       	subi	r24, 0xFF	; 255
    1d76:	eb 81       	ldd	r30, Y+3	; 0x03
    1d78:	fc 81       	ldd	r31, Y+4	; 0x04
    1d7a:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    1d7c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    1d7e:	27 96       	adiw	r28, 0x07	; 7
    1d80:	0f b6       	in	r0, 0x3f	; 63
    1d82:	f8 94       	cli
    1d84:	de bf       	out	0x3e, r29	; 62
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	cd bf       	out	0x3d, r28	; 61
    1d8a:	cf 91       	pop	r28
    1d8c:	df 91       	pop	r29
    1d8e:	08 95       	ret

00001d90 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    1d90:	df 93       	push	r29
    1d92:	cf 93       	push	r28
    1d94:	00 d0       	rcall	.+0      	; 0x1d96 <prvCopyDataFromQueue+0x6>
    1d96:	00 d0       	rcall	.+0      	; 0x1d98 <prvCopyDataFromQueue+0x8>
    1d98:	cd b7       	in	r28, 0x3d	; 61
    1d9a:	de b7       	in	r29, 0x3e	; 62
    1d9c:	9a 83       	std	Y+2, r25	; 0x02
    1d9e:	89 83       	std	Y+1, r24	; 0x01
    1da0:	7c 83       	std	Y+4, r23	; 0x04
    1da2:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1da4:	e9 81       	ldd	r30, Y+1	; 0x01
    1da6:	fa 81       	ldd	r31, Y+2	; 0x02
    1da8:	84 8d       	ldd	r24, Z+28	; 0x1c
    1daa:	88 23       	and	r24, r24
    1dac:	89 f1       	breq	.+98     	; 0x1e10 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    1dae:	e9 81       	ldd	r30, Y+1	; 0x01
    1db0:	fa 81       	ldd	r31, Y+2	; 0x02
    1db2:	26 81       	ldd	r18, Z+6	; 0x06
    1db4:	37 81       	ldd	r19, Z+7	; 0x07
    1db6:	e9 81       	ldd	r30, Y+1	; 0x01
    1db8:	fa 81       	ldd	r31, Y+2	; 0x02
    1dba:	84 8d       	ldd	r24, Z+28	; 0x1c
    1dbc:	88 2f       	mov	r24, r24
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	82 0f       	add	r24, r18
    1dc2:	93 1f       	adc	r25, r19
    1dc4:	e9 81       	ldd	r30, Y+1	; 0x01
    1dc6:	fa 81       	ldd	r31, Y+2	; 0x02
    1dc8:	97 83       	std	Z+7, r25	; 0x07
    1dca:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1dcc:	e9 81       	ldd	r30, Y+1	; 0x01
    1dce:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd0:	26 81       	ldd	r18, Z+6	; 0x06
    1dd2:	37 81       	ldd	r19, Z+7	; 0x07
    1dd4:	e9 81       	ldd	r30, Y+1	; 0x01
    1dd6:	fa 81       	ldd	r31, Y+2	; 0x02
    1dd8:	84 81       	ldd	r24, Z+4	; 0x04
    1dda:	95 81       	ldd	r25, Z+5	; 0x05
    1ddc:	28 17       	cp	r18, r24
    1dde:	39 07       	cpc	r19, r25
    1de0:	40 f0       	brcs	.+16     	; 0x1df2 <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    1de2:	e9 81       	ldd	r30, Y+1	; 0x01
    1de4:	fa 81       	ldd	r31, Y+2	; 0x02
    1de6:	80 81       	ld	r24, Z
    1de8:	91 81       	ldd	r25, Z+1	; 0x01
    1dea:	e9 81       	ldd	r30, Y+1	; 0x01
    1dec:	fa 81       	ldd	r31, Y+2	; 0x02
    1dee:	97 83       	std	Z+7, r25	; 0x07
    1df0:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    1df2:	e9 81       	ldd	r30, Y+1	; 0x01
    1df4:	fa 81       	ldd	r31, Y+2	; 0x02
    1df6:	46 81       	ldd	r20, Z+6	; 0x06
    1df8:	57 81       	ldd	r21, Z+7	; 0x07
    1dfa:	e9 81       	ldd	r30, Y+1	; 0x01
    1dfc:	fa 81       	ldd	r31, Y+2	; 0x02
    1dfe:	84 8d       	ldd	r24, Z+28	; 0x1c
    1e00:	28 2f       	mov	r18, r24
    1e02:	30 e0       	ldi	r19, 0x00	; 0
    1e04:	8b 81       	ldd	r24, Y+3	; 0x03
    1e06:	9c 81       	ldd	r25, Y+4	; 0x04
    1e08:	ba 01       	movw	r22, r20
    1e0a:	a9 01       	movw	r20, r18
    1e0c:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>
	}
}
    1e10:	0f 90       	pop	r0
    1e12:	0f 90       	pop	r0
    1e14:	0f 90       	pop	r0
    1e16:	0f 90       	pop	r0
    1e18:	cf 91       	pop	r28
    1e1a:	df 91       	pop	r29
    1e1c:	08 95       	ret

00001e1e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    1e1e:	df 93       	push	r29
    1e20:	cf 93       	push	r28
    1e22:	00 d0       	rcall	.+0      	; 0x1e24 <prvUnlockQueue+0x6>
    1e24:	00 d0       	rcall	.+0      	; 0x1e26 <prvUnlockQueue+0x8>
    1e26:	cd b7       	in	r28, 0x3d	; 61
    1e28:	de b7       	in	r29, 0x3e	; 62
    1e2a:	9c 83       	std	Y+4, r25	; 0x04
    1e2c:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1e2e:	0f b6       	in	r0, 0x3f	; 63
    1e30:	f8 94       	cli
    1e32:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    1e34:	eb 81       	ldd	r30, Y+3	; 0x03
    1e36:	fc 81       	ldd	r31, Y+4	; 0x04
    1e38:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e3a:	8a 83       	std	Y+2, r24	; 0x02
    1e3c:	11 c0       	rjmp	.+34     	; 0x1e60 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e40:	fc 81       	ldd	r31, Y+4	; 0x04
    1e42:	81 89       	ldd	r24, Z+17	; 0x11
    1e44:	88 23       	and	r24, r24
    1e46:	79 f0       	breq	.+30     	; 0x1e66 <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e48:	8b 81       	ldd	r24, Y+3	; 0x03
    1e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e4c:	41 96       	adiw	r24, 0x11	; 17
    1e4e:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1e52:	88 23       	and	r24, r24
    1e54:	11 f0       	breq	.+4      	; 0x1e5a <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    1e56:	0e 94 72 1f 	call	0x3ee4	; 0x3ee4 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    1e5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e5c:	81 50       	subi	r24, 0x01	; 1
    1e5e:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    1e60:	8a 81       	ldd	r24, Y+2	; 0x02
    1e62:	18 16       	cp	r1, r24
    1e64:	64 f3       	brlt	.-40     	; 0x1e3e <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    1e66:	eb 81       	ldd	r30, Y+3	; 0x03
    1e68:	fc 81       	ldd	r31, Y+4	; 0x04
    1e6a:	8f ef       	ldi	r24, 0xFF	; 255
    1e6c:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1e6e:	0f 90       	pop	r0
    1e70:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1e72:	0f b6       	in	r0, 0x3f	; 63
    1e74:	f8 94       	cli
    1e76:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    1e78:	eb 81       	ldd	r30, Y+3	; 0x03
    1e7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e7c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e7e:	89 83       	std	Y+1, r24	; 0x01
    1e80:	11 c0       	rjmp	.+34     	; 0x1ea4 <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1e82:	eb 81       	ldd	r30, Y+3	; 0x03
    1e84:	fc 81       	ldd	r31, Y+4	; 0x04
    1e86:	80 85       	ldd	r24, Z+8	; 0x08
    1e88:	88 23       	and	r24, r24
    1e8a:	79 f0       	breq	.+30     	; 0x1eaa <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    1e90:	08 96       	adiw	r24, 0x08	; 8
    1e92:	0e 94 06 1e 	call	0x3c0c	; 0x3c0c <xTaskRemoveFromEventList>
    1e96:	88 23       	and	r24, r24
    1e98:	11 f0       	breq	.+4      	; 0x1e9e <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    1e9a:	0e 94 72 1f 	call	0x3ee4	; 0x3ee4 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    1e9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ea0:	81 50       	subi	r24, 0x01	; 1
    1ea2:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    1ea4:	89 81       	ldd	r24, Y+1	; 0x01
    1ea6:	18 16       	cp	r1, r24
    1ea8:	64 f3       	brlt	.-40     	; 0x1e82 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    1eaa:	eb 81       	ldd	r30, Y+3	; 0x03
    1eac:	fc 81       	ldd	r31, Y+4	; 0x04
    1eae:	8f ef       	ldi	r24, 0xFF	; 255
    1eb0:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1eb2:	0f 90       	pop	r0
    1eb4:	0f be       	out	0x3f, r0	; 63
}
    1eb6:	0f 90       	pop	r0
    1eb8:	0f 90       	pop	r0
    1eba:	0f 90       	pop	r0
    1ebc:	0f 90       	pop	r0
    1ebe:	cf 91       	pop	r28
    1ec0:	df 91       	pop	r29
    1ec2:	08 95       	ret

00001ec4 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    1ec4:	df 93       	push	r29
    1ec6:	cf 93       	push	r28
    1ec8:	00 d0       	rcall	.+0      	; 0x1eca <prvIsQueueEmpty+0x6>
    1eca:	0f 92       	push	r0
    1ecc:	cd b7       	in	r28, 0x3d	; 61
    1ece:	de b7       	in	r29, 0x3e	; 62
    1ed0:	9b 83       	std	Y+3, r25	; 0x03
    1ed2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1ed4:	0f b6       	in	r0, 0x3f	; 63
    1ed6:	f8 94       	cli
    1ed8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1eda:	ea 81       	ldd	r30, Y+2	; 0x02
    1edc:	fb 81       	ldd	r31, Y+3	; 0x03
    1ede:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ee0:	88 23       	and	r24, r24
    1ee2:	19 f4       	brne	.+6      	; 0x1eea <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    1ee4:	81 e0       	ldi	r24, 0x01	; 1
    1ee6:	89 83       	std	Y+1, r24	; 0x01
    1ee8:	01 c0       	rjmp	.+2      	; 0x1eec <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    1eea:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1eec:	0f 90       	pop	r0
    1eee:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1ef0:	89 81       	ldd	r24, Y+1	; 0x01
}
    1ef2:	0f 90       	pop	r0
    1ef4:	0f 90       	pop	r0
    1ef6:	0f 90       	pop	r0
    1ef8:	cf 91       	pop	r28
    1efa:	df 91       	pop	r29
    1efc:	08 95       	ret

00001efe <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    1efe:	df 93       	push	r29
    1f00:	cf 93       	push	r28
    1f02:	00 d0       	rcall	.+0      	; 0x1f04 <xQueueIsQueueEmptyFromISR+0x6>
    1f04:	00 d0       	rcall	.+0      	; 0x1f06 <xQueueIsQueueEmptyFromISR+0x8>
    1f06:	0f 92       	push	r0
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
    1f0c:	9d 83       	std	Y+5, r25	; 0x05
    1f0e:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1f10:	8c 81       	ldd	r24, Y+4	; 0x04
    1f12:	9d 81       	ldd	r25, Y+5	; 0x05
    1f14:	9a 83       	std	Y+2, r25	; 0x02
    1f16:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    1f18:	e9 81       	ldd	r30, Y+1	; 0x01
    1f1a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f1c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f1e:	88 23       	and	r24, r24
    1f20:	19 f4       	brne	.+6      	; 0x1f28 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    1f22:	81 e0       	ldi	r24, 0x01	; 1
    1f24:	8b 83       	std	Y+3, r24	; 0x03
    1f26:	01 c0       	rjmp	.+2      	; 0x1f2a <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    1f28:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1f2a:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1f2c:	0f 90       	pop	r0
    1f2e:	0f 90       	pop	r0
    1f30:	0f 90       	pop	r0
    1f32:	0f 90       	pop	r0
    1f34:	0f 90       	pop	r0
    1f36:	cf 91       	pop	r28
    1f38:	df 91       	pop	r29
    1f3a:	08 95       	ret

00001f3c <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    1f3c:	df 93       	push	r29
    1f3e:	cf 93       	push	r28
    1f40:	00 d0       	rcall	.+0      	; 0x1f42 <prvIsQueueFull+0x6>
    1f42:	0f 92       	push	r0
    1f44:	cd b7       	in	r28, 0x3d	; 61
    1f46:	de b7       	in	r29, 0x3e	; 62
    1f48:	9b 83       	std	Y+3, r25	; 0x03
    1f4a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1f4c:	0f b6       	in	r0, 0x3f	; 63
    1f4e:	f8 94       	cli
    1f50:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f52:	ea 81       	ldd	r30, Y+2	; 0x02
    1f54:	fb 81       	ldd	r31, Y+3	; 0x03
    1f56:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f58:	ea 81       	ldd	r30, Y+2	; 0x02
    1f5a:	fb 81       	ldd	r31, Y+3	; 0x03
    1f5c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f5e:	98 17       	cp	r25, r24
    1f60:	19 f4       	brne	.+6      	; 0x1f68 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    1f62:	81 e0       	ldi	r24, 0x01	; 1
    1f64:	89 83       	std	Y+1, r24	; 0x01
    1f66:	01 c0       	rjmp	.+2      	; 0x1f6a <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    1f68:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    1f6a:	0f 90       	pop	r0
    1f6c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    1f6e:	89 81       	ldd	r24, Y+1	; 0x01
}
    1f70:	0f 90       	pop	r0
    1f72:	0f 90       	pop	r0
    1f74:	0f 90       	pop	r0
    1f76:	cf 91       	pop	r28
    1f78:	df 91       	pop	r29
    1f7a:	08 95       	ret

00001f7c <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    1f7c:	df 93       	push	r29
    1f7e:	cf 93       	push	r28
    1f80:	00 d0       	rcall	.+0      	; 0x1f82 <xQueueIsQueueFullFromISR+0x6>
    1f82:	00 d0       	rcall	.+0      	; 0x1f84 <xQueueIsQueueFullFromISR+0x8>
    1f84:	0f 92       	push	r0
    1f86:	cd b7       	in	r28, 0x3d	; 61
    1f88:	de b7       	in	r29, 0x3e	; 62
    1f8a:	9d 83       	std	Y+5, r25	; 0x05
    1f8c:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    1f8e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f90:	9d 81       	ldd	r25, Y+5	; 0x05
    1f92:	9a 83       	std	Y+2, r25	; 0x02
    1f94:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1f96:	e9 81       	ldd	r30, Y+1	; 0x01
    1f98:	fa 81       	ldd	r31, Y+2	; 0x02
    1f9a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1f9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1fa0:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fa2:	98 17       	cp	r25, r24
    1fa4:	19 f4       	brne	.+6      	; 0x1fac <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	8b 83       	std	Y+3, r24	; 0x03
    1faa:	01 c0       	rjmp	.+2      	; 0x1fae <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    1fac:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    1fae:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1fb0:	0f 90       	pop	r0
    1fb2:	0f 90       	pop	r0
    1fb4:	0f 90       	pop	r0
    1fb6:	0f 90       	pop	r0
    1fb8:	0f 90       	pop	r0
    1fba:	cf 91       	pop	r28
    1fbc:	df 91       	pop	r29
    1fbe:	08 95       	ret

00001fc0 <xStreamBufferGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes, size_t xTriggerLevelBytes, BaseType_t xIsMessageBuffer )
	{
    1fc0:	0f 93       	push	r16
    1fc2:	df 93       	push	r29
    1fc4:	cf 93       	push	r28
    1fc6:	cd b7       	in	r28, 0x3d	; 61
    1fc8:	de b7       	in	r29, 0x3e	; 62
    1fca:	28 97       	sbiw	r28, 0x08	; 8
    1fcc:	0f b6       	in	r0, 0x3f	; 63
    1fce:	f8 94       	cli
    1fd0:	de bf       	out	0x3e, r29	; 62
    1fd2:	0f be       	out	0x3f, r0	; 63
    1fd4:	cd bf       	out	0x3d, r28	; 61
    1fd6:	9d 83       	std	Y+5, r25	; 0x05
    1fd8:	8c 83       	std	Y+4, r24	; 0x04
    1fda:	7f 83       	std	Y+7, r23	; 0x07
    1fdc:	6e 83       	std	Y+6, r22	; 0x06
    1fde:	48 87       	std	Y+8, r20	; 0x08

		/* In case the stream buffer is going to be used as a message buffer
		(that is, it will hold discrete messages with a little meta data that
		says how big the next message is) check the buffer will be large enough
		to hold at least one message. */
		if( xIsMessageBuffer == pdTRUE )
    1fe0:	88 85       	ldd	r24, Y+8	; 0x08
    1fe2:	81 30       	cpi	r24, 0x01	; 1
    1fe4:	19 f4       	brne	.+6      	; 0x1fec <xStreamBufferGenericCreate+0x2c>
		{
			/* Is a message buffer but not statically allocated. */
			ucFlags = sbFLAGS_IS_MESSAGE_BUFFER;
    1fe6:	81 e0       	ldi	r24, 0x01	; 1
    1fe8:	89 83       	std	Y+1, r24	; 0x01
    1fea:	01 c0       	rjmp	.+2      	; 0x1fee <xStreamBufferGenericCreate+0x2e>
			configASSERT( xBufferSizeBytes > sbBYTES_TO_STORE_MESSAGE_LENGTH );
		}
		else
		{
			/* Not a message buffer and not statically allocated. */
			ucFlags = 0;
    1fec:	19 82       	std	Y+1, r1	; 0x01
		}
		configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

		/* A trigger level of 0 would cause a waiting task to unblock even when
		the buffer was empty. */
		if( xTriggerLevelBytes == ( size_t ) 0 )
    1fee:	8e 81       	ldd	r24, Y+6	; 0x06
    1ff0:	9f 81       	ldd	r25, Y+7	; 0x07
    1ff2:	00 97       	sbiw	r24, 0x00	; 0
    1ff4:	21 f4       	brne	.+8      	; 0x1ffe <xStreamBufferGenericCreate+0x3e>
		{
			xTriggerLevelBytes = ( size_t ) 1;
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	90 e0       	ldi	r25, 0x00	; 0
    1ffa:	9f 83       	std	Y+7, r25	; 0x07
    1ffc:	8e 83       	std	Y+6, r24	; 0x06
		and the buffer follows immediately after.  The requested size is
		incremented so the free space is returned as the user would expect -
		this is a quirk of the implementation that means otherwise the free
		space would be reported as one byte smaller than would be logically
		expected. */
		xBufferSizeBytes++;
    1ffe:	8c 81       	ldd	r24, Y+4	; 0x04
    2000:	9d 81       	ldd	r25, Y+5	; 0x05
    2002:	01 96       	adiw	r24, 0x01	; 1
    2004:	9d 83       	std	Y+5, r25	; 0x05
    2006:	8c 83       	std	Y+4, r24	; 0x04
		pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    2008:	8c 81       	ldd	r24, Y+4	; 0x04
    200a:	9d 81       	ldd	r25, Y+5	; 0x05
    200c:	0f 96       	adiw	r24, 0x0f	; 15
    200e:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2012:	9b 83       	std	Y+3, r25	; 0x03
    2014:	8a 83       	std	Y+2, r24	; 0x02

		if( pucAllocatedMemory != NULL )
    2016:	8a 81       	ldd	r24, Y+2	; 0x02
    2018:	9b 81       	ldd	r25, Y+3	; 0x03
    201a:	00 97       	sbiw	r24, 0x00	; 0
    201c:	89 f0       	breq	.+34     	; 0x2040 <xStreamBufferGenericCreate+0x80>
		{
			prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory, /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    201e:	6a 81       	ldd	r22, Y+2	; 0x02
    2020:	7b 81       	ldd	r23, Y+3	; 0x03
    2022:	8a 81       	ldd	r24, Y+2	; 0x02
    2024:	9b 81       	ldd	r25, Y+3	; 0x03
    2026:	9c 01       	movw	r18, r24
    2028:	21 5f       	subi	r18, 0xF1	; 241
    202a:	3f 4f       	sbci	r19, 0xFF	; 255
    202c:	4c 81       	ldd	r20, Y+4	; 0x04
    202e:	5d 81       	ldd	r21, Y+5	; 0x05
    2030:	ee 81       	ldd	r30, Y+6	; 0x06
    2032:	ff 81       	ldd	r31, Y+7	; 0x07
    2034:	cb 01       	movw	r24, r22
    2036:	b9 01       	movw	r22, r18
    2038:	9f 01       	movw	r18, r30
    203a:	09 81       	ldd	r16, Y+1	; 0x01
    203c:	0e 94 38 17 	call	0x2e70	; 0x2e70 <prvInitialiseNewStreamBuffer>
		else
		{
			traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
		}

		return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    2040:	8a 81       	ldd	r24, Y+2	; 0x02
    2042:	9b 81       	ldd	r25, Y+3	; 0x03
	}
    2044:	28 96       	adiw	r28, 0x08	; 8
    2046:	0f b6       	in	r0, 0x3f	; 63
    2048:	f8 94       	cli
    204a:	de bf       	out	0x3e, r29	; 62
    204c:	0f be       	out	0x3f, r0	; 63
    204e:	cd bf       	out	0x3d, r28	; 61
    2050:	cf 91       	pop	r28
    2052:	df 91       	pop	r29
    2054:	0f 91       	pop	r16
    2056:	08 95       	ret

00002058 <vStreamBufferDelete>:

#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    2058:	df 93       	push	r29
    205a:	cf 93       	push	r28
    205c:	00 d0       	rcall	.+0      	; 0x205e <vStreamBufferDelete+0x6>
    205e:	00 d0       	rcall	.+0      	; 0x2060 <vStreamBufferDelete+0x8>
    2060:	cd b7       	in	r28, 0x3d	; 61
    2062:	de b7       	in	r29, 0x3e	; 62
    2064:	9c 83       	std	Y+4, r25	; 0x04
    2066:	8b 83       	std	Y+3, r24	; 0x03
StreamBuffer_t * pxStreamBuffer = xStreamBuffer;
    2068:	8b 81       	ldd	r24, Y+3	; 0x03
    206a:	9c 81       	ldd	r25, Y+4	; 0x04
    206c:	9a 83       	std	Y+2, r25	; 0x02
    206e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxStreamBuffer );

	traceSTREAM_BUFFER_DELETE( xStreamBuffer );

	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    2070:	e9 81       	ldd	r30, Y+1	; 0x01
    2072:	fa 81       	ldd	r31, Y+2	; 0x02
    2074:	86 85       	ldd	r24, Z+14	; 0x0e
    2076:	88 2f       	mov	r24, r24
    2078:	90 e0       	ldi	r25, 0x00	; 0
    207a:	82 70       	andi	r24, 0x02	; 2
    207c:	90 70       	andi	r25, 0x00	; 0
    207e:	00 97       	sbiw	r24, 0x00	; 0
    2080:	29 f4       	brne	.+10     	; 0x208c <vStreamBufferDelete+0x34>
	{
		#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
		{
			/* Both the structure and the buffer were allocated using a single call
			to pvPortMalloc(), hence only one call to vPortFree() is required. */
			vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    2082:	89 81       	ldd	r24, Y+1	; 0x01
    2084:	9a 81       	ldd	r25, Y+2	; 0x02
    2086:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    208a:	08 c0       	rjmp	.+16     	; 0x209c <vStreamBufferDelete+0x44>
	}
	else
	{
		/* The structure and buffer were not allocated dynamically and cannot be
		freed - just scrub the structure so future use will assert. */
		( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    208c:	89 81       	ldd	r24, Y+1	; 0x01
    208e:	9a 81       	ldd	r25, Y+2	; 0x02
    2090:	60 e0       	ldi	r22, 0x00	; 0
    2092:	70 e0       	ldi	r23, 0x00	; 0
    2094:	4f e0       	ldi	r20, 0x0F	; 15
    2096:	50 e0       	ldi	r21, 0x00	; 0
    2098:	0e 94 cb 35 	call	0x6b96	; 0x6b96 <memset>
	}
}
    209c:	0f 90       	pop	r0
    209e:	0f 90       	pop	r0
    20a0:	0f 90       	pop	r0
    20a2:	0f 90       	pop	r0
    20a4:	cf 91       	pop	r28
    20a6:	df 91       	pop	r29
    20a8:	08 95       	ret

000020aa <xStreamBufferReset>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    20aa:	0f 93       	push	r16
    20ac:	df 93       	push	r29
    20ae:	cf 93       	push	r28
    20b0:	00 d0       	rcall	.+0      	; 0x20b2 <xStreamBufferReset+0x8>
    20b2:	00 d0       	rcall	.+0      	; 0x20b4 <xStreamBufferReset+0xa>
    20b4:	0f 92       	push	r0
    20b6:	cd b7       	in	r28, 0x3d	; 61
    20b8:	de b7       	in	r29, 0x3e	; 62
    20ba:	9d 83       	std	Y+5, r25	; 0x05
    20bc:	8c 83       	std	Y+4, r24	; 0x04
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    20be:	8c 81       	ldd	r24, Y+4	; 0x04
    20c0:	9d 81       	ldd	r25, Y+5	; 0x05
    20c2:	9b 83       	std	Y+3, r25	; 0x03
    20c4:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn = pdFAIL;
    20c6:	19 82       	std	Y+1, r1	; 0x01
		uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
	}
	#endif

	/* Can only reset a message buffer if there are no tasks blocked on it. */
	taskENTER_CRITICAL();
    20c8:	0f b6       	in	r0, 0x3f	; 63
    20ca:	f8 94       	cli
    20cc:	0f 92       	push	r0
	{
		if( pxStreamBuffer->xTaskWaitingToReceive == NULL )
    20ce:	ea 81       	ldd	r30, Y+2	; 0x02
    20d0:	fb 81       	ldd	r31, Y+3	; 0x03
    20d2:	80 85       	ldd	r24, Z+8	; 0x08
    20d4:	91 85       	ldd	r25, Z+9	; 0x09
    20d6:	00 97       	sbiw	r24, 0x00	; 0
    20d8:	f1 f4       	brne	.+60     	; 0x2116 <xStreamBufferReset+0x6c>
		{
			if( pxStreamBuffer->xTaskWaitingToSend == NULL )
    20da:	ea 81       	ldd	r30, Y+2	; 0x02
    20dc:	fb 81       	ldd	r31, Y+3	; 0x03
    20de:	82 85       	ldd	r24, Z+10	; 0x0a
    20e0:	93 85       	ldd	r25, Z+11	; 0x0b
    20e2:	00 97       	sbiw	r24, 0x00	; 0
    20e4:	c1 f4       	brne	.+48     	; 0x2116 <xStreamBufferReset+0x6c>
			{
				prvInitialiseNewStreamBuffer( pxStreamBuffer,
    20e6:	ea 81       	ldd	r30, Y+2	; 0x02
    20e8:	fb 81       	ldd	r31, Y+3	; 0x03
    20ea:	24 85       	ldd	r18, Z+12	; 0x0c
    20ec:	35 85       	ldd	r19, Z+13	; 0x0d
    20ee:	ea 81       	ldd	r30, Y+2	; 0x02
    20f0:	fb 81       	ldd	r31, Y+3	; 0x03
    20f2:	44 81       	ldd	r20, Z+4	; 0x04
    20f4:	55 81       	ldd	r21, Z+5	; 0x05
    20f6:	ea 81       	ldd	r30, Y+2	; 0x02
    20f8:	fb 81       	ldd	r31, Y+3	; 0x03
    20fa:	a6 81       	ldd	r26, Z+6	; 0x06
    20fc:	b7 81       	ldd	r27, Z+7	; 0x07
    20fe:	ea 81       	ldd	r30, Y+2	; 0x02
    2100:	fb 81       	ldd	r31, Y+3	; 0x03
    2102:	e6 85       	ldd	r30, Z+14	; 0x0e
    2104:	8a 81       	ldd	r24, Y+2	; 0x02
    2106:	9b 81       	ldd	r25, Y+3	; 0x03
    2108:	b9 01       	movw	r22, r18
    210a:	9d 01       	movw	r18, r26
    210c:	0e 2f       	mov	r16, r30
    210e:	0e 94 38 17 	call	0x2e70	; 0x2e70 <prvInitialiseNewStreamBuffer>
											  pxStreamBuffer->pucBuffer,
											  pxStreamBuffer->xLength,
											  pxStreamBuffer->xTriggerLevelBytes,
											  pxStreamBuffer->ucFlags );
				xReturn = pdPASS;
    2112:	81 e0       	ldi	r24, 0x01	; 1
    2114:	89 83       	std	Y+1, r24	; 0x01

				traceSTREAM_BUFFER_RESET( xStreamBuffer );
			}
		}
	}
	taskEXIT_CRITICAL();
    2116:	0f 90       	pop	r0
    2118:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    211a:	89 81       	ldd	r24, Y+1	; 0x01
}
    211c:	0f 90       	pop	r0
    211e:	0f 90       	pop	r0
    2120:	0f 90       	pop	r0
    2122:	0f 90       	pop	r0
    2124:	0f 90       	pop	r0
    2126:	cf 91       	pop	r28
    2128:	df 91       	pop	r29
    212a:	0f 91       	pop	r16
    212c:	08 95       	ret

0000212e <xStreamBufferSetTriggerLevel>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer, size_t xTriggerLevel )
{
    212e:	df 93       	push	r29
    2130:	cf 93       	push	r28
    2132:	cd b7       	in	r28, 0x3d	; 61
    2134:	de b7       	in	r29, 0x3e	; 62
    2136:	27 97       	sbiw	r28, 0x07	; 7
    2138:	0f b6       	in	r0, 0x3f	; 63
    213a:	f8 94       	cli
    213c:	de bf       	out	0x3e, r29	; 62
    213e:	0f be       	out	0x3f, r0	; 63
    2140:	cd bf       	out	0x3d, r28	; 61
    2142:	9d 83       	std	Y+5, r25	; 0x05
    2144:	8c 83       	std	Y+4, r24	; 0x04
    2146:	7f 83       	std	Y+7, r23	; 0x07
    2148:	6e 83       	std	Y+6, r22	; 0x06
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    214a:	8c 81       	ldd	r24, Y+4	; 0x04
    214c:	9d 81       	ldd	r25, Y+5	; 0x05
    214e:	9b 83       	std	Y+3, r25	; 0x03
    2150:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	configASSERT( pxStreamBuffer );

	/* It is not valid for the trigger level to be 0. */
	if( xTriggerLevel == ( size_t ) 0 )
    2152:	8e 81       	ldd	r24, Y+6	; 0x06
    2154:	9f 81       	ldd	r25, Y+7	; 0x07
    2156:	00 97       	sbiw	r24, 0x00	; 0
    2158:	21 f4       	brne	.+8      	; 0x2162 <xStreamBufferSetTriggerLevel+0x34>
	{
		xTriggerLevel = ( size_t ) 1;
    215a:	81 e0       	ldi	r24, 0x01	; 1
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	9f 83       	std	Y+7, r25	; 0x07
    2160:	8e 83       	std	Y+6, r24	; 0x06
	}

	/* The trigger level is the number of bytes that must be in the stream
	buffer before a task that is waiting for data is unblocked. */
	if( xTriggerLevel <= pxStreamBuffer->xLength )
    2162:	ea 81       	ldd	r30, Y+2	; 0x02
    2164:	fb 81       	ldd	r31, Y+3	; 0x03
    2166:	24 81       	ldd	r18, Z+4	; 0x04
    2168:	35 81       	ldd	r19, Z+5	; 0x05
    216a:	8e 81       	ldd	r24, Y+6	; 0x06
    216c:	9f 81       	ldd	r25, Y+7	; 0x07
    216e:	28 17       	cp	r18, r24
    2170:	39 07       	cpc	r19, r25
    2172:	48 f0       	brcs	.+18     	; 0x2186 <xStreamBufferSetTriggerLevel+0x58>
	{
		pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    2174:	ea 81       	ldd	r30, Y+2	; 0x02
    2176:	fb 81       	ldd	r31, Y+3	; 0x03
    2178:	8e 81       	ldd	r24, Y+6	; 0x06
    217a:	9f 81       	ldd	r25, Y+7	; 0x07
    217c:	97 83       	std	Z+7, r25	; 0x07
    217e:	86 83       	std	Z+6, r24	; 0x06
		xReturn = pdPASS;
    2180:	81 e0       	ldi	r24, 0x01	; 1
    2182:	89 83       	std	Y+1, r24	; 0x01
    2184:	01 c0       	rjmp	.+2      	; 0x2188 <xStreamBufferSetTriggerLevel+0x5a>
	}
	else
	{
		xReturn = pdFALSE;
    2186:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2188:	89 81       	ldd	r24, Y+1	; 0x01
}
    218a:	27 96       	adiw	r28, 0x07	; 7
    218c:	0f b6       	in	r0, 0x3f	; 63
    218e:	f8 94       	cli
    2190:	de bf       	out	0x3e, r29	; 62
    2192:	0f be       	out	0x3f, r0	; 63
    2194:	cd bf       	out	0x3d, r28	; 61
    2196:	cf 91       	pop	r28
    2198:	df 91       	pop	r29
    219a:	08 95       	ret

0000219c <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    219c:	df 93       	push	r29
    219e:	cf 93       	push	r28
    21a0:	00 d0       	rcall	.+0      	; 0x21a2 <xStreamBufferSpacesAvailable+0x6>
    21a2:	00 d0       	rcall	.+0      	; 0x21a4 <xStreamBufferSpacesAvailable+0x8>
    21a4:	00 d0       	rcall	.+0      	; 0x21a6 <xStreamBufferSpacesAvailable+0xa>
    21a6:	cd b7       	in	r28, 0x3d	; 61
    21a8:	de b7       	in	r29, 0x3e	; 62
    21aa:	9e 83       	std	Y+6, r25	; 0x06
    21ac:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    21ae:	8d 81       	ldd	r24, Y+5	; 0x05
    21b0:	9e 81       	ldd	r25, Y+6	; 0x06
    21b2:	9c 83       	std	Y+4, r25	; 0x04
    21b4:	8b 83       	std	Y+3, r24	; 0x03
size_t xSpace;

	configASSERT( pxStreamBuffer );

	xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    21b6:	eb 81       	ldd	r30, Y+3	; 0x03
    21b8:	fc 81       	ldd	r31, Y+4	; 0x04
    21ba:	24 81       	ldd	r18, Z+4	; 0x04
    21bc:	35 81       	ldd	r19, Z+5	; 0x05
    21be:	eb 81       	ldd	r30, Y+3	; 0x03
    21c0:	fc 81       	ldd	r31, Y+4	; 0x04
    21c2:	80 81       	ld	r24, Z
    21c4:	91 81       	ldd	r25, Z+1	; 0x01
    21c6:	82 0f       	add	r24, r18
    21c8:	93 1f       	adc	r25, r19
    21ca:	9a 83       	std	Y+2, r25	; 0x02
    21cc:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= pxStreamBuffer->xHead;
    21ce:	eb 81       	ldd	r30, Y+3	; 0x03
    21d0:	fc 81       	ldd	r31, Y+4	; 0x04
    21d2:	22 81       	ldd	r18, Z+2	; 0x02
    21d4:	33 81       	ldd	r19, Z+3	; 0x03
    21d6:	89 81       	ldd	r24, Y+1	; 0x01
    21d8:	9a 81       	ldd	r25, Y+2	; 0x02
    21da:	82 1b       	sub	r24, r18
    21dc:	93 0b       	sbc	r25, r19
    21de:	9a 83       	std	Y+2, r25	; 0x02
    21e0:	89 83       	std	Y+1, r24	; 0x01
	xSpace -= ( size_t ) 1;
    21e2:	89 81       	ldd	r24, Y+1	; 0x01
    21e4:	9a 81       	ldd	r25, Y+2	; 0x02
    21e6:	01 97       	sbiw	r24, 0x01	; 1
    21e8:	9a 83       	std	Y+2, r25	; 0x02
    21ea:	89 83       	std	Y+1, r24	; 0x01

	if( xSpace >= pxStreamBuffer->xLength )
    21ec:	eb 81       	ldd	r30, Y+3	; 0x03
    21ee:	fc 81       	ldd	r31, Y+4	; 0x04
    21f0:	24 81       	ldd	r18, Z+4	; 0x04
    21f2:	35 81       	ldd	r19, Z+5	; 0x05
    21f4:	89 81       	ldd	r24, Y+1	; 0x01
    21f6:	9a 81       	ldd	r25, Y+2	; 0x02
    21f8:	82 17       	cp	r24, r18
    21fa:	93 07       	cpc	r25, r19
    21fc:	50 f0       	brcs	.+20     	; 0x2212 <xStreamBufferSpacesAvailable+0x76>
	{
		xSpace -= pxStreamBuffer->xLength;
    21fe:	eb 81       	ldd	r30, Y+3	; 0x03
    2200:	fc 81       	ldd	r31, Y+4	; 0x04
    2202:	24 81       	ldd	r18, Z+4	; 0x04
    2204:	35 81       	ldd	r19, Z+5	; 0x05
    2206:	89 81       	ldd	r24, Y+1	; 0x01
    2208:	9a 81       	ldd	r25, Y+2	; 0x02
    220a:	82 1b       	sub	r24, r18
    220c:	93 0b       	sbc	r25, r19
    220e:	9a 83       	std	Y+2, r25	; 0x02
    2210:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xSpace;
    2212:	89 81       	ldd	r24, Y+1	; 0x01
    2214:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2216:	26 96       	adiw	r28, 0x06	; 6
    2218:	0f b6       	in	r0, 0x3f	; 63
    221a:	f8 94       	cli
    221c:	de bf       	out	0x3e, r29	; 62
    221e:	0f be       	out	0x3f, r0	; 63
    2220:	cd bf       	out	0x3d, r28	; 61
    2222:	cf 91       	pop	r28
    2224:	df 91       	pop	r29
    2226:	08 95       	ret

00002228 <xStreamBufferBytesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferBytesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    2228:	df 93       	push	r29
    222a:	cf 93       	push	r28
    222c:	00 d0       	rcall	.+0      	; 0x222e <xStreamBufferBytesAvailable+0x6>
    222e:	00 d0       	rcall	.+0      	; 0x2230 <xStreamBufferBytesAvailable+0x8>
    2230:	00 d0       	rcall	.+0      	; 0x2232 <xStreamBufferBytesAvailable+0xa>
    2232:	cd b7       	in	r28, 0x3d	; 61
    2234:	de b7       	in	r29, 0x3e	; 62
    2236:	9e 83       	std	Y+6, r25	; 0x06
    2238:	8d 83       	std	Y+5, r24	; 0x05
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    223a:	8d 81       	ldd	r24, Y+5	; 0x05
    223c:	9e 81       	ldd	r25, Y+6	; 0x06
    223e:	9c 83       	std	Y+4, r25	; 0x04
    2240:	8b 83       	std	Y+3, r24	; 0x03
size_t xReturn;

	configASSERT( pxStreamBuffer );

	xReturn = prvBytesInBuffer( pxStreamBuffer );
    2242:	8b 81       	ldd	r24, Y+3	; 0x03
    2244:	9c 81       	ldd	r25, Y+4	; 0x04
    2246:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    224a:	9a 83       	std	Y+2, r25	; 0x02
    224c:	89 83       	std	Y+1, r24	; 0x01
	return xReturn;
    224e:	89 81       	ldd	r24, Y+1	; 0x01
    2250:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2252:	26 96       	adiw	r28, 0x06	; 6
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	de bf       	out	0x3e, r29	; 62
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	cd bf       	out	0x3d, r28	; 61
    225e:	cf 91       	pop	r28
    2260:	df 91       	pop	r29
    2262:	08 95       	ret

00002264 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
						  const void *pvTxData,
						  size_t xDataLengthBytes,
						  TickType_t xTicksToWait )
{
    2264:	ef 92       	push	r14
    2266:	ff 92       	push	r15
    2268:	0f 93       	push	r16
    226a:	1f 93       	push	r17
    226c:	df 93       	push	r29
    226e:	cf 93       	push	r28
    2270:	cd b7       	in	r28, 0x3d	; 61
    2272:	de b7       	in	r29, 0x3e	; 62
    2274:	63 97       	sbiw	r28, 0x13	; 19
    2276:	0f b6       	in	r0, 0x3f	; 63
    2278:	f8 94       	cli
    227a:	de bf       	out	0x3e, r29	; 62
    227c:	0f be       	out	0x3f, r0	; 63
    227e:	cd bf       	out	0x3d, r28	; 61
    2280:	9d 87       	std	Y+13, r25	; 0x0d
    2282:	8c 87       	std	Y+12, r24	; 0x0c
    2284:	7f 87       	std	Y+15, r23	; 0x0f
    2286:	6e 87       	std	Y+14, r22	; 0x0e
    2288:	59 8b       	std	Y+17, r21	; 0x11
    228a:	48 8b       	std	Y+16, r20	; 0x10
    228c:	3b 8b       	std	Y+19, r19	; 0x13
    228e:	2a 8b       	std	Y+18, r18	; 0x12
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2290:	8c 85       	ldd	r24, Y+12	; 0x0c
    2292:	9d 85       	ldd	r25, Y+13	; 0x0d
    2294:	98 87       	std	Y+8, r25	; 0x08
    2296:	8f 83       	std	Y+7, r24	; 0x07
size_t xReturn, xSpace = 0;
    2298:	1c 82       	std	Y+4, r1	; 0x04
    229a:	1b 82       	std	Y+3, r1	; 0x03
size_t xRequiredSpace = xDataLengthBytes;
    229c:	88 89       	ldd	r24, Y+16	; 0x10
    229e:	99 89       	ldd	r25, Y+17	; 0x11
    22a0:	9a 83       	std	Y+2, r25	; 0x02
    22a2:	89 83       	std	Y+1, r24	; 0x01

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    22a4:	ef 81       	ldd	r30, Y+7	; 0x07
    22a6:	f8 85       	ldd	r31, Y+8	; 0x08
    22a8:	86 85       	ldd	r24, Z+14	; 0x0e
    22aa:	88 2f       	mov	r24, r24
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	81 70       	andi	r24, 0x01	; 1
    22b0:	90 70       	andi	r25, 0x00	; 0
    22b2:	88 23       	and	r24, r24
    22b4:	29 f0       	breq	.+10     	; 0x22c0 <xStreamBufferSend+0x5c>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    22b6:	89 81       	ldd	r24, Y+1	; 0x01
    22b8:	9a 81       	ldd	r25, Y+2	; 0x02
    22ba:	02 96       	adiw	r24, 0x02	; 2
    22bc:	9a 83       	std	Y+2, r25	; 0x02
    22be:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    22c0:	8a 89       	ldd	r24, Y+18	; 0x12
    22c2:	9b 89       	ldd	r25, Y+19	; 0x13
    22c4:	00 97       	sbiw	r24, 0x00	; 0
    22c6:	09 f4       	brne	.+2      	; 0x22ca <xStreamBufferSend+0x66>
    22c8:	40 c0       	rjmp	.+128    	; 0x234a <xStreamBufferSend+0xe6>
	{
		vTaskSetTimeOutState( &xTimeOut );
    22ca:	ce 01       	movw	r24, r28
    22cc:	09 96       	adiw	r24, 0x09	; 9
    22ce:	0e 94 ce 1e 	call	0x3d9c	; 0x3d9c <vTaskSetTimeOutState>

		do
		{
			/* Wait until the required number of bytes are free in the message
			buffer. */
			taskENTER_CRITICAL();
    22d2:	0f b6       	in	r0, 0x3f	; 63
    22d4:	f8 94       	cli
    22d6:	0f 92       	push	r0
			{
				xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    22d8:	8f 81       	ldd	r24, Y+7	; 0x07
    22da:	98 85       	ldd	r25, Y+8	; 0x08
    22dc:	0e 94 ce 10 	call	0x219c	; 0x219c <xStreamBufferSpacesAvailable>
    22e0:	9c 83       	std	Y+4, r25	; 0x04
    22e2:	8b 83       	std	Y+3, r24	; 0x03

				if( xSpace < xRequiredSpace )
    22e4:	2b 81       	ldd	r18, Y+3	; 0x03
    22e6:	3c 81       	ldd	r19, Y+4	; 0x04
    22e8:	89 81       	ldd	r24, Y+1	; 0x01
    22ea:	9a 81       	ldd	r25, Y+2	; 0x02
    22ec:	28 17       	cp	r18, r24
    22ee:	39 07       	cpc	r19, r25
    22f0:	50 f5       	brcc	.+84     	; 0x2346 <xStreamBufferSend+0xe2>
				{
					/* Clear notification state as going to wait for space. */
					( void ) xTaskNotifyStateClear( NULL );
    22f2:	80 e0       	ldi	r24, 0x00	; 0
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <xTaskNotifyStateClear>

					/* Should only be one writer. */
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    22fa:	0e 94 37 20 	call	0x406e	; 0x406e <xTaskGetCurrentTaskHandle>
    22fe:	ef 81       	ldd	r30, Y+7	; 0x07
    2300:	f8 85       	ldd	r31, Y+8	; 0x08
    2302:	93 87       	std	Z+11, r25	; 0x0b
    2304:	82 87       	std	Z+10, r24	; 0x0a
				{
					taskEXIT_CRITICAL();
					break;
				}
			}
			taskEXIT_CRITICAL();
    2306:	0f 90       	pop	r0
    2308:	0f be       	out	0x3f, r0	; 63

			traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    230a:	ea 89       	ldd	r30, Y+18	; 0x12
    230c:	fb 89       	ldd	r31, Y+19	; 0x13
    230e:	60 e0       	ldi	r22, 0x00	; 0
    2310:	70 e0       	ldi	r23, 0x00	; 0
    2312:	80 e0       	ldi	r24, 0x00	; 0
    2314:	90 e0       	ldi	r25, 0x00	; 0
    2316:	20 e0       	ldi	r18, 0x00	; 0
    2318:	30 e0       	ldi	r19, 0x00	; 0
    231a:	40 e0       	ldi	r20, 0x00	; 0
    231c:	50 e0       	ldi	r21, 0x00	; 0
    231e:	00 e0       	ldi	r16, 0x00	; 0
    2320:	10 e0       	ldi	r17, 0x00	; 0
    2322:	7f 01       	movw	r14, r30
    2324:	0e 94 a4 22 	call	0x4548	; 0x4548 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToSend = NULL;
    2328:	ef 81       	ldd	r30, Y+7	; 0x07
    232a:	f8 85       	ldd	r31, Y+8	; 0x08
    232c:	13 86       	std	Z+11, r1	; 0x0b
    232e:	12 86       	std	Z+10, r1	; 0x0a

		} while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    2330:	ce 01       	movw	r24, r28
    2332:	09 96       	adiw	r24, 0x09	; 9
    2334:	9e 01       	movw	r18, r28
    2336:	2e 5e       	subi	r18, 0xEE	; 238
    2338:	3f 4f       	sbci	r19, 0xFF	; 255
    233a:	b9 01       	movw	r22, r18
    233c:	0e 94 05 1f 	call	0x3e0a	; 0x3e0a <xTaskCheckForTimeOut>
    2340:	88 23       	and	r24, r24
    2342:	39 f2       	breq	.-114    	; 0x22d2 <xStreamBufferSend+0x6e>
    2344:	02 c0       	rjmp	.+4      	; 0x234a <xStreamBufferSend+0xe6>
					configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
					pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
				}
				else
				{
					taskEXIT_CRITICAL();
    2346:	0f 90       	pop	r0
    2348:	0f be       	out	0x3f, r0	; 63
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	if( xSpace == ( size_t ) 0 )
    234a:	8b 81       	ldd	r24, Y+3	; 0x03
    234c:	9c 81       	ldd	r25, Y+4	; 0x04
    234e:	00 97       	sbiw	r24, 0x00	; 0
    2350:	31 f4       	brne	.+12     	; 0x235e <xStreamBufferSend+0xfa>
	{
		xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    2352:	8f 81       	ldd	r24, Y+7	; 0x07
    2354:	98 85       	ldd	r25, Y+8	; 0x08
    2356:	0e 94 ce 10 	call	0x219c	; 0x219c <xStreamBufferSpacesAvailable>
    235a:	9c 83       	std	Y+4, r25	; 0x04
    235c:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    235e:	8f 81       	ldd	r24, Y+7	; 0x07
    2360:	98 85       	ldd	r25, Y+8	; 0x08
    2362:	2e 85       	ldd	r18, Y+14	; 0x0e
    2364:	3f 85       	ldd	r19, Y+15	; 0x0f
    2366:	48 89       	ldd	r20, Y+16	; 0x10
    2368:	59 89       	ldd	r21, Y+17	; 0x11
    236a:	eb 81       	ldd	r30, Y+3	; 0x03
    236c:	fc 81       	ldd	r31, Y+4	; 0x04
    236e:	a9 81       	ldd	r26, Y+1	; 0x01
    2370:	ba 81       	ldd	r27, Y+2	; 0x02
    2372:	b9 01       	movw	r22, r18
    2374:	9f 01       	movw	r18, r30
    2376:	8d 01       	movw	r16, r26
    2378:	0e 94 77 12 	call	0x24ee	; 0x24ee <prvWriteMessageToBuffer>
    237c:	9e 83       	std	Y+6, r25	; 0x06
    237e:	8d 83       	std	Y+5, r24	; 0x05

	if( xReturn > ( size_t ) 0 )
    2380:	8d 81       	ldd	r24, Y+5	; 0x05
    2382:	9e 81       	ldd	r25, Y+6	; 0x06
    2384:	00 97       	sbiw	r24, 0x00	; 0
    2386:	39 f1       	breq	.+78     	; 0x23d6 <xStreamBufferSend+0x172>
	{
		traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2388:	8f 81       	ldd	r24, Y+7	; 0x07
    238a:	98 85       	ldd	r25, Y+8	; 0x08
    238c:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    2390:	9c 01       	movw	r18, r24
    2392:	ef 81       	ldd	r30, Y+7	; 0x07
    2394:	f8 85       	ldd	r31, Y+8	; 0x08
    2396:	86 81       	ldd	r24, Z+6	; 0x06
    2398:	97 81       	ldd	r25, Z+7	; 0x07
    239a:	28 17       	cp	r18, r24
    239c:	39 07       	cpc	r19, r25
    239e:	d8 f0       	brcs	.+54     	; 0x23d6 <xStreamBufferSend+0x172>
		{
			sbSEND_COMPLETED( pxStreamBuffer );
    23a0:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
    23a4:	ef 81       	ldd	r30, Y+7	; 0x07
    23a6:	f8 85       	ldd	r31, Y+8	; 0x08
    23a8:	80 85       	ldd	r24, Z+8	; 0x08
    23aa:	91 85       	ldd	r25, Z+9	; 0x09
    23ac:	00 97       	sbiw	r24, 0x00	; 0
    23ae:	89 f0       	breq	.+34     	; 0x23d2 <xStreamBufferSend+0x16e>
    23b0:	ef 81       	ldd	r30, Y+7	; 0x07
    23b2:	f8 85       	ldd	r31, Y+8	; 0x08
    23b4:	80 85       	ldd	r24, Z+8	; 0x08
    23b6:	91 85       	ldd	r25, Z+9	; 0x09
    23b8:	40 e0       	ldi	r20, 0x00	; 0
    23ba:	50 e0       	ldi	r21, 0x00	; 0
    23bc:	60 e0       	ldi	r22, 0x00	; 0
    23be:	70 e0       	ldi	r23, 0x00	; 0
    23c0:	20 e0       	ldi	r18, 0x00	; 0
    23c2:	00 e0       	ldi	r16, 0x00	; 0
    23c4:	10 e0       	ldi	r17, 0x00	; 0
    23c6:	0e 94 40 23 	call	0x4680	; 0x4680 <xTaskGenericNotify>
    23ca:	ef 81       	ldd	r30, Y+7	; 0x07
    23cc:	f8 85       	ldd	r31, Y+8	; 0x08
    23ce:	11 86       	std	Z+9, r1	; 0x09
    23d0:	10 86       	std	Z+8, r1	; 0x08
    23d2:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
	{
		mtCOVERAGE_TEST_MARKER();
		traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
	}

	return xReturn;
    23d6:	8d 81       	ldd	r24, Y+5	; 0x05
    23d8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    23da:	63 96       	adiw	r28, 0x13	; 19
    23dc:	0f b6       	in	r0, 0x3f	; 63
    23de:	f8 94       	cli
    23e0:	de bf       	out	0x3e, r29	; 62
    23e2:	0f be       	out	0x3f, r0	; 63
    23e4:	cd bf       	out	0x3d, r28	; 61
    23e6:	cf 91       	pop	r28
    23e8:	df 91       	pop	r29
    23ea:	1f 91       	pop	r17
    23ec:	0f 91       	pop	r16
    23ee:	ff 90       	pop	r15
    23f0:	ef 90       	pop	r14
    23f2:	08 95       	ret

000023f4 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
								 const void *pvTxData,
								 size_t xDataLengthBytes,
								 BaseType_t * const pxHigherPriorityTaskWoken )
{
    23f4:	ef 92       	push	r14
    23f6:	ff 92       	push	r15
    23f8:	0f 93       	push	r16
    23fa:	1f 93       	push	r17
    23fc:	df 93       	push	r29
    23fe:	cf 93       	push	r28
    2400:	cd b7       	in	r28, 0x3d	; 61
    2402:	de b7       	in	r29, 0x3e	; 62
    2404:	61 97       	sbiw	r28, 0x11	; 17
    2406:	0f b6       	in	r0, 0x3f	; 63
    2408:	f8 94       	cli
    240a:	de bf       	out	0x3e, r29	; 62
    240c:	0f be       	out	0x3f, r0	; 63
    240e:	cd bf       	out	0x3d, r28	; 61
    2410:	9b 87       	std	Y+11, r25	; 0x0b
    2412:	8a 87       	std	Y+10, r24	; 0x0a
    2414:	7d 87       	std	Y+13, r23	; 0x0d
    2416:	6c 87       	std	Y+12, r22	; 0x0c
    2418:	5f 87       	std	Y+15, r21	; 0x0f
    241a:	4e 87       	std	Y+14, r20	; 0x0e
    241c:	39 8b       	std	Y+17, r19	; 0x11
    241e:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2420:	8a 85       	ldd	r24, Y+10	; 0x0a
    2422:	9b 85       	ldd	r25, Y+11	; 0x0b
    2424:	99 87       	std	Y+9, r25	; 0x09
    2426:	88 87       	std	Y+8, r24	; 0x08
size_t xReturn, xSpace;
size_t xRequiredSpace = xDataLengthBytes;
    2428:	8e 85       	ldd	r24, Y+14	; 0x0e
    242a:	9f 85       	ldd	r25, Y+15	; 0x0f
    242c:	9b 83       	std	Y+3, r25	; 0x03
    242e:	8a 83       	std	Y+2, r24	; 0x02

	/* This send function is used to write to both message buffers and stream
	buffers.  If this is a message buffer then the space needed must be
	increased by the amount of bytes needed to store the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2430:	e8 85       	ldd	r30, Y+8	; 0x08
    2432:	f9 85       	ldd	r31, Y+9	; 0x09
    2434:	86 85       	ldd	r24, Z+14	; 0x0e
    2436:	88 2f       	mov	r24, r24
    2438:	90 e0       	ldi	r25, 0x00	; 0
    243a:	81 70       	andi	r24, 0x01	; 1
    243c:	90 70       	andi	r25, 0x00	; 0
    243e:	88 23       	and	r24, r24
    2440:	29 f0       	breq	.+10     	; 0x244c <xStreamBufferSendFromISR+0x58>
	{
		xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2442:	8a 81       	ldd	r24, Y+2	; 0x02
    2444:	9b 81       	ldd	r25, Y+3	; 0x03
    2446:	02 96       	adiw	r24, 0x02	; 2
    2448:	9b 83       	std	Y+3, r25	; 0x03
    244a:	8a 83       	std	Y+2, r24	; 0x02
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    244c:	88 85       	ldd	r24, Y+8	; 0x08
    244e:	99 85       	ldd	r25, Y+9	; 0x09
    2450:	0e 94 ce 10 	call	0x219c	; 0x219c <xStreamBufferSpacesAvailable>
    2454:	9d 83       	std	Y+5, r25	; 0x05
    2456:	8c 83       	std	Y+4, r24	; 0x04
	xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    2458:	88 85       	ldd	r24, Y+8	; 0x08
    245a:	99 85       	ldd	r25, Y+9	; 0x09
    245c:	2c 85       	ldd	r18, Y+12	; 0x0c
    245e:	3d 85       	ldd	r19, Y+13	; 0x0d
    2460:	4e 85       	ldd	r20, Y+14	; 0x0e
    2462:	5f 85       	ldd	r21, Y+15	; 0x0f
    2464:	ec 81       	ldd	r30, Y+4	; 0x04
    2466:	fd 81       	ldd	r31, Y+5	; 0x05
    2468:	aa 81       	ldd	r26, Y+2	; 0x02
    246a:	bb 81       	ldd	r27, Y+3	; 0x03
    246c:	b9 01       	movw	r22, r18
    246e:	9f 01       	movw	r18, r30
    2470:	8d 01       	movw	r16, r26
    2472:	0e 94 77 12 	call	0x24ee	; 0x24ee <prvWriteMessageToBuffer>
    2476:	9f 83       	std	Y+7, r25	; 0x07
    2478:	8e 83       	std	Y+6, r24	; 0x06

	if( xReturn > ( size_t ) 0 )
    247a:	8e 81       	ldd	r24, Y+6	; 0x06
    247c:	9f 81       	ldd	r25, Y+7	; 0x07
    247e:	00 97       	sbiw	r24, 0x00	; 0
    2480:	39 f1       	breq	.+78     	; 0x24d0 <xStreamBufferSendFromISR+0xdc>
	{
		/* Was a task waiting for the data? */
		if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    2482:	88 85       	ldd	r24, Y+8	; 0x08
    2484:	99 85       	ldd	r25, Y+9	; 0x09
    2486:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    248a:	9c 01       	movw	r18, r24
    248c:	e8 85       	ldd	r30, Y+8	; 0x08
    248e:	f9 85       	ldd	r31, Y+9	; 0x09
    2490:	86 81       	ldd	r24, Z+6	; 0x06
    2492:	97 81       	ldd	r25, Z+7	; 0x07
    2494:	28 17       	cp	r18, r24
    2496:	39 07       	cpc	r19, r25
    2498:	d8 f0       	brcs	.+54     	; 0x24d0 <xStreamBufferSendFromISR+0xdc>
		{
			sbSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    249a:	19 82       	std	Y+1, r1	; 0x01
    249c:	e8 85       	ldd	r30, Y+8	; 0x08
    249e:	f9 85       	ldd	r31, Y+9	; 0x09
    24a0:	80 85       	ldd	r24, Z+8	; 0x08
    24a2:	91 85       	ldd	r25, Z+9	; 0x09
    24a4:	00 97       	sbiw	r24, 0x00	; 0
    24a6:	a1 f0       	breq	.+40     	; 0x24d0 <xStreamBufferSendFromISR+0xdc>
    24a8:	e8 85       	ldd	r30, Y+8	; 0x08
    24aa:	f9 85       	ldd	r31, Y+9	; 0x09
    24ac:	80 85       	ldd	r24, Z+8	; 0x08
    24ae:	91 85       	ldd	r25, Z+9	; 0x09
    24b0:	e8 89       	ldd	r30, Y+16	; 0x10
    24b2:	f9 89       	ldd	r31, Y+17	; 0x11
    24b4:	40 e0       	ldi	r20, 0x00	; 0
    24b6:	50 e0       	ldi	r21, 0x00	; 0
    24b8:	60 e0       	ldi	r22, 0x00	; 0
    24ba:	70 e0       	ldi	r23, 0x00	; 0
    24bc:	20 e0       	ldi	r18, 0x00	; 0
    24be:	00 e0       	ldi	r16, 0x00	; 0
    24c0:	10 e0       	ldi	r17, 0x00	; 0
    24c2:	7f 01       	movw	r14, r30
    24c4:	0e 94 1d 24 	call	0x483a	; 0x483a <xTaskGenericNotifyFromISR>
    24c8:	e8 85       	ldd	r30, Y+8	; 0x08
    24ca:	f9 85       	ldd	r31, Y+9	; 0x09
    24cc:	11 86       	std	Z+9, r1	; 0x09
    24ce:	10 86       	std	Z+8, r1	; 0x08
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

	return xReturn;
    24d0:	8e 81       	ldd	r24, Y+6	; 0x06
    24d2:	9f 81       	ldd	r25, Y+7	; 0x07
}
    24d4:	61 96       	adiw	r28, 0x11	; 17
    24d6:	0f b6       	in	r0, 0x3f	; 63
    24d8:	f8 94       	cli
    24da:	de bf       	out	0x3e, r29	; 62
    24dc:	0f be       	out	0x3f, r0	; 63
    24de:	cd bf       	out	0x3d, r28	; 61
    24e0:	cf 91       	pop	r28
    24e2:	df 91       	pop	r29
    24e4:	1f 91       	pop	r17
    24e6:	0f 91       	pop	r16
    24e8:	ff 90       	pop	r15
    24ea:	ef 90       	pop	r14
    24ec:	08 95       	ret

000024ee <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
									   const void * pvTxData,
									   size_t xDataLengthBytes,
									   size_t xSpace,
									   size_t xRequiredSpace )
{
    24ee:	0f 93       	push	r16
    24f0:	1f 93       	push	r17
    24f2:	df 93       	push	r29
    24f4:	cf 93       	push	r28
    24f6:	cd b7       	in	r28, 0x3d	; 61
    24f8:	de b7       	in	r29, 0x3e	; 62
    24fa:	61 97       	sbiw	r28, 0x11	; 17
    24fc:	0f b6       	in	r0, 0x3f	; 63
    24fe:	f8 94       	cli
    2500:	de bf       	out	0x3e, r29	; 62
    2502:	0f be       	out	0x3f, r0	; 63
    2504:	cd bf       	out	0x3d, r28	; 61
    2506:	9d 83       	std	Y+5, r25	; 0x05
    2508:	8c 83       	std	Y+4, r24	; 0x04
    250a:	7f 83       	std	Y+7, r23	; 0x07
    250c:	6e 83       	std	Y+6, r22	; 0x06
    250e:	59 87       	std	Y+9, r21	; 0x09
    2510:	48 87       	std	Y+8, r20	; 0x08
    2512:	3b 87       	std	Y+11, r19	; 0x0b
    2514:	2a 87       	std	Y+10, r18	; 0x0a
    2516:	1d 87       	std	Y+13, r17	; 0x0d
    2518:	0c 87       	std	Y+12, r16	; 0x0c
	BaseType_t xShouldWrite;
	size_t xReturn;

	if( xSpace == ( size_t ) 0 )
    251a:	8a 85       	ldd	r24, Y+10	; 0x0a
    251c:	9b 85       	ldd	r25, Y+11	; 0x0b
    251e:	00 97       	sbiw	r24, 0x00	; 0
    2520:	11 f4       	brne	.+4      	; 0x2526 <prvWriteMessageToBuffer+0x38>
	{
		/* Doesn't matter if this is a stream buffer or a message buffer, there
		is no space to write. */
		xShouldWrite = pdFALSE;
    2522:	1b 82       	std	Y+3, r1	; 0x03
    2524:	38 c0       	rjmp	.+112    	; 0x2596 <prvWriteMessageToBuffer+0xa8>
	}
	else if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) == ( uint8_t ) 0 )
    2526:	ec 81       	ldd	r30, Y+4	; 0x04
    2528:	fd 81       	ldd	r31, Y+5	; 0x05
    252a:	86 85       	ldd	r24, Z+14	; 0x0e
    252c:	88 2f       	mov	r24, r24
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	81 70       	andi	r24, 0x01	; 1
    2532:	90 70       	andi	r25, 0x00	; 0
    2534:	00 97       	sbiw	r24, 0x00	; 0
    2536:	d1 f4       	brne	.+52     	; 0x256c <prvWriteMessageToBuffer+0x7e>
	{
		/* This is a stream buffer, as opposed to a message buffer, so writing a
		stream of bytes rather than discrete messages.  Write as many bytes as
		possible. */
		xShouldWrite = pdTRUE;
    2538:	81 e0       	ldi	r24, 0x01	; 1
    253a:	8b 83       	std	Y+3, r24	; 0x03
		xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    253c:	28 85       	ldd	r18, Y+8	; 0x08
    253e:	39 85       	ldd	r19, Y+9	; 0x09
    2540:	39 8b       	std	Y+17, r19	; 0x11
    2542:	28 8b       	std	Y+16, r18	; 0x10
    2544:	8a 85       	ldd	r24, Y+10	; 0x0a
    2546:	9b 85       	ldd	r25, Y+11	; 0x0b
    2548:	9f 87       	std	Y+15, r25	; 0x0f
    254a:	8e 87       	std	Y+14, r24	; 0x0e
    254c:	2e 85       	ldd	r18, Y+14	; 0x0e
    254e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2550:	88 89       	ldd	r24, Y+16	; 0x10
    2552:	99 89       	ldd	r25, Y+17	; 0x11
    2554:	82 17       	cp	r24, r18
    2556:	93 07       	cpc	r25, r19
    2558:	20 f4       	brcc	.+8      	; 0x2562 <prvWriteMessageToBuffer+0x74>
    255a:	28 89       	ldd	r18, Y+16	; 0x10
    255c:	39 89       	ldd	r19, Y+17	; 0x11
    255e:	3f 87       	std	Y+15, r19	; 0x0f
    2560:	2e 87       	std	Y+14, r18	; 0x0e
    2562:	8e 85       	ldd	r24, Y+14	; 0x0e
    2564:	9f 85       	ldd	r25, Y+15	; 0x0f
    2566:	99 87       	std	Y+9, r25	; 0x09
    2568:	88 87       	std	Y+8, r24	; 0x08
    256a:	15 c0       	rjmp	.+42     	; 0x2596 <prvWriteMessageToBuffer+0xa8>
	}
	else if( xSpace >= xRequiredSpace )
    256c:	2a 85       	ldd	r18, Y+10	; 0x0a
    256e:	3b 85       	ldd	r19, Y+11	; 0x0b
    2570:	8c 85       	ldd	r24, Y+12	; 0x0c
    2572:	9d 85       	ldd	r25, Y+13	; 0x0d
    2574:	28 17       	cp	r18, r24
    2576:	39 07       	cpc	r19, r25
    2578:	68 f0       	brcs	.+26     	; 0x2594 <prvWriteMessageToBuffer+0xa6>
	{
		/* This is a message buffer, as opposed to a stream buffer, and there
		is enough space to write both the message length and the message itself
		into the buffer.  Start by writing the length of the data, the data
		itself will be written later in this function. */
		xShouldWrite = pdTRUE;
    257a:	81 e0       	ldi	r24, 0x01	; 1
    257c:	8b 83       	std	Y+3, r24	; 0x03
		( void ) prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xDataLengthBytes ), sbBYTES_TO_STORE_MESSAGE_LENGTH );
    257e:	9e 01       	movw	r18, r28
    2580:	28 5f       	subi	r18, 0xF8	; 248
    2582:	3f 4f       	sbci	r19, 0xFF	; 255
    2584:	8c 81       	ldd	r24, Y+4	; 0x04
    2586:	9d 81       	ldd	r25, Y+5	; 0x05
    2588:	b9 01       	movw	r22, r18
    258a:	42 e0       	ldi	r20, 0x02	; 2
    258c:	50 e0       	ldi	r21, 0x00	; 0
    258e:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <prvWriteBytesToBuffer>
    2592:	01 c0       	rjmp	.+2      	; 0x2596 <prvWriteMessageToBuffer+0xa8>
	}
	else
	{
		/* There is space available, but not enough space. */
		xShouldWrite = pdFALSE;
    2594:	1b 82       	std	Y+3, r1	; 0x03
	}

	if( xShouldWrite != pdFALSE )
    2596:	8b 81       	ldd	r24, Y+3	; 0x03
    2598:	88 23       	and	r24, r24
    259a:	61 f0       	breq	.+24     	; 0x25b4 <prvWriteMessageToBuffer+0xc6>
	{
		/* Writes the data itself. */
		xReturn = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alighment and access. */
    259c:	2e 81       	ldd	r18, Y+6	; 0x06
    259e:	3f 81       	ldd	r19, Y+7	; 0x07
    25a0:	48 85       	ldd	r20, Y+8	; 0x08
    25a2:	59 85       	ldd	r21, Y+9	; 0x09
    25a4:	8c 81       	ldd	r24, Y+4	; 0x04
    25a6:	9d 81       	ldd	r25, Y+5	; 0x05
    25a8:	b9 01       	movw	r22, r18
    25aa:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <prvWriteBytesToBuffer>
    25ae:	9a 83       	std	Y+2, r25	; 0x02
    25b0:	89 83       	std	Y+1, r24	; 0x01
    25b2:	02 c0       	rjmp	.+4      	; 0x25b8 <prvWriteMessageToBuffer+0xca>
	}
	else
	{
		xReturn = 0;
    25b4:	1a 82       	std	Y+2, r1	; 0x02
    25b6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    25b8:	89 81       	ldd	r24, Y+1	; 0x01
    25ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    25bc:	61 96       	adiw	r28, 0x11	; 17
    25be:	0f b6       	in	r0, 0x3f	; 63
    25c0:	f8 94       	cli
    25c2:	de bf       	out	0x3e, r29	; 62
    25c4:	0f be       	out	0x3f, r0	; 63
    25c6:	cd bf       	out	0x3d, r28	; 61
    25c8:	cf 91       	pop	r28
    25ca:	df 91       	pop	r29
    25cc:	1f 91       	pop	r17
    25ce:	0f 91       	pop	r16
    25d0:	08 95       	ret

000025d2 <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
							 void *pvRxData,
							 size_t xBufferLengthBytes,
							 TickType_t xTicksToWait )
{
    25d2:	ef 92       	push	r14
    25d4:	ff 92       	push	r15
    25d6:	0f 93       	push	r16
    25d8:	1f 93       	push	r17
    25da:	df 93       	push	r29
    25dc:	cf 93       	push	r28
    25de:	cd b7       	in	r28, 0x3d	; 61
    25e0:	de b7       	in	r29, 0x3e	; 62
    25e2:	60 97       	sbiw	r28, 0x10	; 16
    25e4:	0f b6       	in	r0, 0x3f	; 63
    25e6:	f8 94       	cli
    25e8:	de bf       	out	0x3e, r29	; 62
    25ea:	0f be       	out	0x3f, r0	; 63
    25ec:	cd bf       	out	0x3d, r28	; 61
    25ee:	9a 87       	std	Y+10, r25	; 0x0a
    25f0:	89 87       	std	Y+9, r24	; 0x09
    25f2:	7c 87       	std	Y+12, r23	; 0x0c
    25f4:	6b 87       	std	Y+11, r22	; 0x0b
    25f6:	5e 87       	std	Y+14, r21	; 0x0e
    25f8:	4d 87       	std	Y+13, r20	; 0x0d
    25fa:	38 8b       	std	Y+16, r19	; 0x10
    25fc:	2f 87       	std	Y+15, r18	; 0x0f
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    25fe:	89 85       	ldd	r24, Y+9	; 0x09
    2600:	9a 85       	ldd	r25, Y+10	; 0x0a
    2602:	98 87       	std	Y+8, r25	; 0x08
    2604:	8f 83       	std	Y+7, r24	; 0x07
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    2606:	1e 82       	std	Y+6, r1	; 0x06
    2608:	1d 82       	std	Y+5, r1	; 0x05
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    260a:	ef 81       	ldd	r30, Y+7	; 0x07
    260c:	f8 85       	ldd	r31, Y+8	; 0x08
    260e:	86 85       	ldd	r24, Z+14	; 0x0e
    2610:	88 2f       	mov	r24, r24
    2612:	90 e0       	ldi	r25, 0x00	; 0
    2614:	81 70       	andi	r24, 0x01	; 1
    2616:	90 70       	andi	r25, 0x00	; 0
    2618:	88 23       	and	r24, r24
    261a:	29 f0       	breq	.+10     	; 0x2626 <xStreamBufferReceive+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    261c:	82 e0       	ldi	r24, 0x02	; 2
    261e:	90 e0       	ldi	r25, 0x00	; 0
    2620:	9a 83       	std	Y+2, r25	; 0x02
    2622:	89 83       	std	Y+1, r24	; 0x01
    2624:	02 c0       	rjmp	.+4      	; 0x262a <xStreamBufferReceive+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2626:	1a 82       	std	Y+2, r1	; 0x02
    2628:	19 82       	std	Y+1, r1	; 0x01
	}

	if( xTicksToWait != ( TickType_t ) 0 )
    262a:	8f 85       	ldd	r24, Y+15	; 0x0f
    262c:	98 89       	ldd	r25, Y+16	; 0x10
    262e:	00 97       	sbiw	r24, 0x00	; 0
    2630:	09 f4       	brne	.+2      	; 0x2634 <xStreamBufferReceive+0x62>
    2632:	3d c0       	rjmp	.+122    	; 0x26ae <xStreamBufferReceive+0xdc>
	{
		/* Checking if there is data and clearing the notification state must be
		performed atomically. */
		taskENTER_CRITICAL();
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	0f 92       	push	r0
		{
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    263a:	8f 81       	ldd	r24, Y+7	; 0x07
    263c:	98 85       	ldd	r25, Y+8	; 0x08
    263e:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    2642:	9c 83       	std	Y+4, r25	; 0x04
    2644:	8b 83       	std	Y+3, r24	; 0x03
			/* If this function was invoked by a message buffer read then
			xBytesToStoreMessageLength holds the number of bytes used to hold
			the length of the next discrete message.  If this function was
			invoked by a stream buffer read then xBytesToStoreMessageLength will
			be 0. */
			if( xBytesAvailable <= xBytesToStoreMessageLength )
    2646:	2b 81       	ldd	r18, Y+3	; 0x03
    2648:	3c 81       	ldd	r19, Y+4	; 0x04
    264a:	89 81       	ldd	r24, Y+1	; 0x01
    264c:	9a 81       	ldd	r25, Y+2	; 0x02
    264e:	82 17       	cp	r24, r18
    2650:	93 07       	cpc	r25, r19
    2652:	50 f0       	brcs	.+20     	; 0x2668 <xStreamBufferReceive+0x96>
			{
				/* Clear notification state as going to wait for data. */
				( void ) xTaskNotifyStateClear( NULL );
    2654:	80 e0       	ldi	r24, 0x00	; 0
    2656:	90 e0       	ldi	r25, 0x00	; 0
    2658:	0e 94 9b 25 	call	0x4b36	; 0x4b36 <xTaskNotifyStateClear>

				/* Should only be one reader. */
				configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
				pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    265c:	0e 94 37 20 	call	0x406e	; 0x406e <xTaskGetCurrentTaskHandle>
    2660:	ef 81       	ldd	r30, Y+7	; 0x07
    2662:	f8 85       	ldd	r31, Y+8	; 0x08
    2664:	91 87       	std	Z+9, r25	; 0x09
    2666:	80 87       	std	Z+8, r24	; 0x08
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    2668:	0f 90       	pop	r0
    266a:	0f be       	out	0x3f, r0	; 63

		if( xBytesAvailable <= xBytesToStoreMessageLength )
    266c:	2b 81       	ldd	r18, Y+3	; 0x03
    266e:	3c 81       	ldd	r19, Y+4	; 0x04
    2670:	89 81       	ldd	r24, Y+1	; 0x01
    2672:	9a 81       	ldd	r25, Y+2	; 0x02
    2674:	82 17       	cp	r24, r18
    2676:	93 07       	cpc	r25, r19
    2678:	00 f1       	brcs	.+64     	; 0x26ba <xStreamBufferReceive+0xe8>
		{
			/* Wait for data to be available. */
			traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
			( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    267a:	ef 85       	ldd	r30, Y+15	; 0x0f
    267c:	f8 89       	ldd	r31, Y+16	; 0x10
    267e:	60 e0       	ldi	r22, 0x00	; 0
    2680:	70 e0       	ldi	r23, 0x00	; 0
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	90 e0       	ldi	r25, 0x00	; 0
    2686:	20 e0       	ldi	r18, 0x00	; 0
    2688:	30 e0       	ldi	r19, 0x00	; 0
    268a:	40 e0       	ldi	r20, 0x00	; 0
    268c:	50 e0       	ldi	r21, 0x00	; 0
    268e:	00 e0       	ldi	r16, 0x00	; 0
    2690:	10 e0       	ldi	r17, 0x00	; 0
    2692:	7f 01       	movw	r14, r30
    2694:	0e 94 a4 22 	call	0x4548	; 0x4548 <xTaskNotifyWait>
			pxStreamBuffer->xTaskWaitingToReceive = NULL;
    2698:	ef 81       	ldd	r30, Y+7	; 0x07
    269a:	f8 85       	ldd	r31, Y+8	; 0x08
    269c:	11 86       	std	Z+9, r1	; 0x09
    269e:	10 86       	std	Z+8, r1	; 0x08

			/* Recheck the data available after blocking. */
			xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26a0:	8f 81       	ldd	r24, Y+7	; 0x07
    26a2:	98 85       	ldd	r25, Y+8	; 0x08
    26a4:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    26a8:	9c 83       	std	Y+4, r25	; 0x04
    26aa:	8b 83       	std	Y+3, r24	; 0x03
    26ac:	06 c0       	rjmp	.+12     	; 0x26ba <xStreamBufferReceive+0xe8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    26ae:	8f 81       	ldd	r24, Y+7	; 0x07
    26b0:	98 85       	ldd	r25, Y+8	; 0x08
    26b2:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    26b6:	9c 83       	std	Y+4, r25	; 0x04
    26b8:	8b 83       	std	Y+3, r24	; 0x03
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    26ba:	2b 81       	ldd	r18, Y+3	; 0x03
    26bc:	3c 81       	ldd	r19, Y+4	; 0x04
    26be:	89 81       	ldd	r24, Y+1	; 0x01
    26c0:	9a 81       	ldd	r25, Y+2	; 0x02
    26c2:	82 17       	cp	r24, r18
    26c4:	93 07       	cpc	r25, r19
    26c6:	80 f5       	brcc	.+96     	; 0x2728 <xStreamBufferReceive+0x156>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    26c8:	8f 81       	ldd	r24, Y+7	; 0x07
    26ca:	98 85       	ldd	r25, Y+8	; 0x08
    26cc:	2b 85       	ldd	r18, Y+11	; 0x0b
    26ce:	3c 85       	ldd	r19, Y+12	; 0x0c
    26d0:	4d 85       	ldd	r20, Y+13	; 0x0d
    26d2:	5e 85       	ldd	r21, Y+14	; 0x0e
    26d4:	eb 81       	ldd	r30, Y+3	; 0x03
    26d6:	fc 81       	ldd	r31, Y+4	; 0x04
    26d8:	a9 81       	ldd	r26, Y+1	; 0x01
    26da:	ba 81       	ldd	r27, Y+2	; 0x02
    26dc:	b9 01       	movw	r22, r18
    26de:	9f 01       	movw	r18, r30
    26e0:	8d 01       	movw	r16, r26
    26e2:	0e 94 6d 14 	call	0x28da	; 0x28da <prvReadMessageFromBuffer>
    26e6:	9e 83       	std	Y+6, r25	; 0x06
    26e8:	8d 83       	std	Y+5, r24	; 0x05

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    26ea:	8d 81       	ldd	r24, Y+5	; 0x05
    26ec:	9e 81       	ldd	r25, Y+6	; 0x06
    26ee:	00 97       	sbiw	r24, 0x00	; 0
    26f0:	d9 f0       	breq	.+54     	; 0x2728 <xStreamBufferReceive+0x156>
		{
			traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
			sbRECEIVE_COMPLETED( pxStreamBuffer );
    26f2:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
    26f6:	ef 81       	ldd	r30, Y+7	; 0x07
    26f8:	f8 85       	ldd	r31, Y+8	; 0x08
    26fa:	82 85       	ldd	r24, Z+10	; 0x0a
    26fc:	93 85       	ldd	r25, Z+11	; 0x0b
    26fe:	00 97       	sbiw	r24, 0x00	; 0
    2700:	89 f0       	breq	.+34     	; 0x2724 <xStreamBufferReceive+0x152>
    2702:	ef 81       	ldd	r30, Y+7	; 0x07
    2704:	f8 85       	ldd	r31, Y+8	; 0x08
    2706:	82 85       	ldd	r24, Z+10	; 0x0a
    2708:	93 85       	ldd	r25, Z+11	; 0x0b
    270a:	40 e0       	ldi	r20, 0x00	; 0
    270c:	50 e0       	ldi	r21, 0x00	; 0
    270e:	60 e0       	ldi	r22, 0x00	; 0
    2710:	70 e0       	ldi	r23, 0x00	; 0
    2712:	20 e0       	ldi	r18, 0x00	; 0
    2714:	00 e0       	ldi	r16, 0x00	; 0
    2716:	10 e0       	ldi	r17, 0x00	; 0
    2718:	0e 94 40 23 	call	0x4680	; 0x4680 <xTaskGenericNotify>
    271c:	ef 81       	ldd	r30, Y+7	; 0x07
    271e:	f8 85       	ldd	r31, Y+8	; 0x08
    2720:	13 86       	std	Z+11, r1	; 0x0b
    2722:	12 86       	std	Z+10, r1	; 0x0a
    2724:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
	{
		traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
		mtCOVERAGE_TEST_MARKER();
	}

	return xReceivedLength;
    2728:	8d 81       	ldd	r24, Y+5	; 0x05
    272a:	9e 81       	ldd	r25, Y+6	; 0x06
}
    272c:	60 96       	adiw	r28, 0x10	; 16
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	de bf       	out	0x3e, r29	; 62
    2734:	0f be       	out	0x3f, r0	; 63
    2736:	cd bf       	out	0x3d, r28	; 61
    2738:	cf 91       	pop	r28
    273a:	df 91       	pop	r29
    273c:	1f 91       	pop	r17
    273e:	0f 91       	pop	r16
    2740:	ff 90       	pop	r15
    2742:	ef 90       	pop	r14
    2744:	08 95       	ret

00002746 <xStreamBufferNextMessageLengthBytes>:
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    2746:	df 93       	push	r29
    2748:	cf 93       	push	r28
    274a:	cd b7       	in	r28, 0x3d	; 61
    274c:	de b7       	in	r29, 0x3e	; 62
    274e:	2c 97       	sbiw	r28, 0x0c	; 12
    2750:	0f b6       	in	r0, 0x3f	; 63
    2752:	f8 94       	cli
    2754:	de bf       	out	0x3e, r29	; 62
    2756:	0f be       	out	0x3f, r0	; 63
    2758:	cd bf       	out	0x3d, r28	; 61
    275a:	9c 87       	std	Y+12, r25	; 0x0c
    275c:	8b 87       	std	Y+11, r24	; 0x0b
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    275e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2760:	9c 85       	ldd	r25, Y+12	; 0x0c
    2762:	98 87       	std	Y+8, r25	; 0x08
    2764:	8f 83       	std	Y+7, r24	; 0x07
configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

	configASSERT( pxStreamBuffer );

	/* Ensure the stream buffer is being used as a message buffer. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2766:	ef 81       	ldd	r30, Y+7	; 0x07
    2768:	f8 85       	ldd	r31, Y+8	; 0x08
    276a:	86 85       	ldd	r24, Z+14	; 0x0e
    276c:	88 2f       	mov	r24, r24
    276e:	90 e0       	ldi	r25, 0x00	; 0
    2770:	81 70       	andi	r24, 0x01	; 1
    2772:	90 70       	andi	r25, 0x00	; 0
    2774:	88 23       	and	r24, r24
    2776:	61 f1       	breq	.+88     	; 0x27d0 <xStreamBufferNextMessageLengthBytes+0x8a>
	{
		xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2778:	8f 81       	ldd	r24, Y+7	; 0x07
    277a:	98 85       	ldd	r25, Y+8	; 0x08
    277c:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    2780:	9c 83       	std	Y+4, r25	; 0x04
    2782:	8b 83       	std	Y+3, r24	; 0x03
		if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    2784:	8b 81       	ldd	r24, Y+3	; 0x03
    2786:	9c 81       	ldd	r25, Y+4	; 0x04
    2788:	83 30       	cpi	r24, 0x03	; 3
    278a:	91 05       	cpc	r25, r1
    278c:	f0 f0       	brcs	.+60     	; 0x27ca <xStreamBufferNextMessageLengthBytes+0x84>
			required to hold the length of the next message, so another message
			is available.  Return its length without removing the length bytes
			from the buffer.  A copy of the tail is stored so the buffer can be
			returned to its prior state as the message is not actually being
			removed from the buffer. */
			xOriginalTail = pxStreamBuffer->xTail;
    278e:	ef 81       	ldd	r30, Y+7	; 0x07
    2790:	f8 85       	ldd	r31, Y+8	; 0x08
    2792:	80 81       	ld	r24, Z
    2794:	91 81       	ldd	r25, Z+1	; 0x01
    2796:	9a 83       	std	Y+2, r25	; 0x02
    2798:	89 83       	std	Y+1, r24	; 0x01
			( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, xBytesAvailable );
    279a:	9e 01       	movw	r18, r28
    279c:	27 5f       	subi	r18, 0xF7	; 247
    279e:	3f 4f       	sbci	r19, 0xFF	; 255
    27a0:	8f 81       	ldd	r24, Y+7	; 0x07
    27a2:	98 85       	ldd	r25, Y+8	; 0x08
    27a4:	eb 81       	ldd	r30, Y+3	; 0x03
    27a6:	fc 81       	ldd	r31, Y+4	; 0x04
    27a8:	b9 01       	movw	r22, r18
    27aa:	42 e0       	ldi	r20, 0x02	; 2
    27ac:	50 e0       	ldi	r21, 0x00	; 0
    27ae:	9f 01       	movw	r18, r30
    27b0:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <prvReadBytesFromBuffer>
			xReturn = ( size_t ) xTempReturn;
    27b4:	89 85       	ldd	r24, Y+9	; 0x09
    27b6:	9a 85       	ldd	r25, Y+10	; 0x0a
    27b8:	9e 83       	std	Y+6, r25	; 0x06
    27ba:	8d 83       	std	Y+5, r24	; 0x05
			pxStreamBuffer->xTail = xOriginalTail;
    27bc:	ef 81       	ldd	r30, Y+7	; 0x07
    27be:	f8 85       	ldd	r31, Y+8	; 0x08
    27c0:	89 81       	ldd	r24, Y+1	; 0x01
    27c2:	9a 81       	ldd	r25, Y+2	; 0x02
    27c4:	91 83       	std	Z+1, r25	; 0x01
    27c6:	80 83       	st	Z, r24
    27c8:	05 c0       	rjmp	.+10     	; 0x27d4 <xStreamBufferNextMessageLengthBytes+0x8e>
			/* The minimum amount of bytes in a message buffer is
			( sbBYTES_TO_STORE_MESSAGE_LENGTH + 1 ), so if xBytesAvailable is
			less than sbBYTES_TO_STORE_MESSAGE_LENGTH the only other valid
			value is 0. */
			configASSERT( xBytesAvailable == 0 );
			xReturn = 0;
    27ca:	1e 82       	std	Y+6, r1	; 0x06
    27cc:	1d 82       	std	Y+5, r1	; 0x05
    27ce:	02 c0       	rjmp	.+4      	; 0x27d4 <xStreamBufferNextMessageLengthBytes+0x8e>
		}
	}
	else
	{
		xReturn = 0;
    27d0:	1e 82       	std	Y+6, r1	; 0x06
    27d2:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    27d4:	8d 81       	ldd	r24, Y+5	; 0x05
    27d6:	9e 81       	ldd	r25, Y+6	; 0x06
}
    27d8:	2c 96       	adiw	r28, 0x0c	; 12
    27da:	0f b6       	in	r0, 0x3f	; 63
    27dc:	f8 94       	cli
    27de:	de bf       	out	0x3e, r29	; 62
    27e0:	0f be       	out	0x3f, r0	; 63
    27e2:	cd bf       	out	0x3d, r28	; 61
    27e4:	cf 91       	pop	r28
    27e6:	df 91       	pop	r29
    27e8:	08 95       	ret

000027ea <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
									void *pvRxData,
									size_t xBufferLengthBytes,
									BaseType_t * const pxHigherPriorityTaskWoken )
{
    27ea:	ef 92       	push	r14
    27ec:	ff 92       	push	r15
    27ee:	0f 93       	push	r16
    27f0:	1f 93       	push	r17
    27f2:	df 93       	push	r29
    27f4:	cf 93       	push	r28
    27f6:	cd b7       	in	r28, 0x3d	; 61
    27f8:	de b7       	in	r29, 0x3e	; 62
    27fa:	61 97       	sbiw	r28, 0x11	; 17
    27fc:	0f b6       	in	r0, 0x3f	; 63
    27fe:	f8 94       	cli
    2800:	de bf       	out	0x3e, r29	; 62
    2802:	0f be       	out	0x3f, r0	; 63
    2804:	cd bf       	out	0x3d, r28	; 61
    2806:	9b 87       	std	Y+11, r25	; 0x0b
    2808:	8a 87       	std	Y+10, r24	; 0x0a
    280a:	7d 87       	std	Y+13, r23	; 0x0d
    280c:	6c 87       	std	Y+12, r22	; 0x0c
    280e:	5f 87       	std	Y+15, r21	; 0x0f
    2810:	4e 87       	std	Y+14, r20	; 0x0e
    2812:	39 8b       	std	Y+17, r19	; 0x11
    2814:	28 8b       	std	Y+16, r18	; 0x10
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2816:	8a 85       	ldd	r24, Y+10	; 0x0a
    2818:	9b 85       	ldd	r25, Y+11	; 0x0b
    281a:	99 87       	std	Y+9, r25	; 0x09
    281c:	88 87       	std	Y+8, r24	; 0x08
size_t xReceivedLength = 0, xBytesAvailable, xBytesToStoreMessageLength;
    281e:	1f 82       	std	Y+7, r1	; 0x07
    2820:	1e 82       	std	Y+6, r1	; 0x06
	/* This receive function is used by both message buffers, which store
	discrete messages, and stream buffers, which store a continuous stream of
	bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
	message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2822:	e8 85       	ldd	r30, Y+8	; 0x08
    2824:	f9 85       	ldd	r31, Y+9	; 0x09
    2826:	86 85       	ldd	r24, Z+14	; 0x0e
    2828:	88 2f       	mov	r24, r24
    282a:	90 e0       	ldi	r25, 0x00	; 0
    282c:	81 70       	andi	r24, 0x01	; 1
    282e:	90 70       	andi	r25, 0x00	; 0
    2830:	88 23       	and	r24, r24
    2832:	29 f0       	breq	.+10     	; 0x283e <xStreamBufferReceiveFromISR+0x54>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2834:	82 e0       	ldi	r24, 0x02	; 2
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	9b 83       	std	Y+3, r25	; 0x03
    283a:	8a 83       	std	Y+2, r24	; 0x02
    283c:	02 c0       	rjmp	.+4      	; 0x2842 <xStreamBufferReceiveFromISR+0x58>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    283e:	1b 82       	std	Y+3, r1	; 0x03
    2840:	1a 82       	std	Y+2, r1	; 0x02
	}

	xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    2842:	88 85       	ldd	r24, Y+8	; 0x08
    2844:	99 85       	ldd	r25, Y+9	; 0x09
    2846:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <prvBytesInBuffer>
    284a:	9d 83       	std	Y+5, r25	; 0x05
    284c:	8c 83       	std	Y+4, r24	; 0x04
	/* Whether receiving a discrete message (where xBytesToStoreMessageLength
	holds the number of bytes used to store the message length) or a stream of
	bytes (where xBytesToStoreMessageLength is zero), the number of bytes
	available must be greater than xBytesToStoreMessageLength to be able to
	read bytes from the buffer. */
	if( xBytesAvailable > xBytesToStoreMessageLength )
    284e:	2c 81       	ldd	r18, Y+4	; 0x04
    2850:	3d 81       	ldd	r19, Y+5	; 0x05
    2852:	8a 81       	ldd	r24, Y+2	; 0x02
    2854:	9b 81       	ldd	r25, Y+3	; 0x03
    2856:	82 17       	cp	r24, r18
    2858:	93 07       	cpc	r25, r19
    285a:	80 f5       	brcc	.+96     	; 0x28bc <xStreamBufferReceiveFromISR+0xd2>
	{
		xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable, xBytesToStoreMessageLength );
    285c:	88 85       	ldd	r24, Y+8	; 0x08
    285e:	99 85       	ldd	r25, Y+9	; 0x09
    2860:	2c 85       	ldd	r18, Y+12	; 0x0c
    2862:	3d 85       	ldd	r19, Y+13	; 0x0d
    2864:	4e 85       	ldd	r20, Y+14	; 0x0e
    2866:	5f 85       	ldd	r21, Y+15	; 0x0f
    2868:	ec 81       	ldd	r30, Y+4	; 0x04
    286a:	fd 81       	ldd	r31, Y+5	; 0x05
    286c:	aa 81       	ldd	r26, Y+2	; 0x02
    286e:	bb 81       	ldd	r27, Y+3	; 0x03
    2870:	b9 01       	movw	r22, r18
    2872:	9f 01       	movw	r18, r30
    2874:	8d 01       	movw	r16, r26
    2876:	0e 94 6d 14 	call	0x28da	; 0x28da <prvReadMessageFromBuffer>
    287a:	9f 83       	std	Y+7, r25	; 0x07
    287c:	8e 83       	std	Y+6, r24	; 0x06

		/* Was a task waiting for space in the buffer? */
		if( xReceivedLength != ( size_t ) 0 )
    287e:	8e 81       	ldd	r24, Y+6	; 0x06
    2880:	9f 81       	ldd	r25, Y+7	; 0x07
    2882:	00 97       	sbiw	r24, 0x00	; 0
    2884:	d9 f0       	breq	.+54     	; 0x28bc <xStreamBufferReceiveFromISR+0xd2>
		{
			sbRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    2886:	19 82       	std	Y+1, r1	; 0x01
    2888:	e8 85       	ldd	r30, Y+8	; 0x08
    288a:	f9 85       	ldd	r31, Y+9	; 0x09
    288c:	82 85       	ldd	r24, Z+10	; 0x0a
    288e:	93 85       	ldd	r25, Z+11	; 0x0b
    2890:	00 97       	sbiw	r24, 0x00	; 0
    2892:	a1 f0       	breq	.+40     	; 0x28bc <xStreamBufferReceiveFromISR+0xd2>
    2894:	e8 85       	ldd	r30, Y+8	; 0x08
    2896:	f9 85       	ldd	r31, Y+9	; 0x09
    2898:	82 85       	ldd	r24, Z+10	; 0x0a
    289a:	93 85       	ldd	r25, Z+11	; 0x0b
    289c:	e8 89       	ldd	r30, Y+16	; 0x10
    289e:	f9 89       	ldd	r31, Y+17	; 0x11
    28a0:	40 e0       	ldi	r20, 0x00	; 0
    28a2:	50 e0       	ldi	r21, 0x00	; 0
    28a4:	60 e0       	ldi	r22, 0x00	; 0
    28a6:	70 e0       	ldi	r23, 0x00	; 0
    28a8:	20 e0       	ldi	r18, 0x00	; 0
    28aa:	00 e0       	ldi	r16, 0x00	; 0
    28ac:	10 e0       	ldi	r17, 0x00	; 0
    28ae:	7f 01       	movw	r14, r30
    28b0:	0e 94 1d 24 	call	0x483a	; 0x483a <xTaskGenericNotifyFromISR>
    28b4:	e8 85       	ldd	r30, Y+8	; 0x08
    28b6:	f9 85       	ldd	r31, Y+9	; 0x09
    28b8:	13 86       	std	Z+11, r1	; 0x0b
    28ba:	12 86       	std	Z+10, r1	; 0x0a
		mtCOVERAGE_TEST_MARKER();
	}

	traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

	return xReceivedLength;
    28bc:	8e 81       	ldd	r24, Y+6	; 0x06
    28be:	9f 81       	ldd	r25, Y+7	; 0x07
}
    28c0:	61 96       	adiw	r28, 0x11	; 17
    28c2:	0f b6       	in	r0, 0x3f	; 63
    28c4:	f8 94       	cli
    28c6:	de bf       	out	0x3e, r29	; 62
    28c8:	0f be       	out	0x3f, r0	; 63
    28ca:	cd bf       	out	0x3d, r28	; 61
    28cc:	cf 91       	pop	r28
    28ce:	df 91       	pop	r29
    28d0:	1f 91       	pop	r17
    28d2:	0f 91       	pop	r16
    28d4:	ff 90       	pop	r15
    28d6:	ef 90       	pop	r14
    28d8:	08 95       	ret

000028da <prvReadMessageFromBuffer>:
static size_t prvReadMessageFromBuffer( StreamBuffer_t *pxStreamBuffer,
										void *pvRxData,
										size_t xBufferLengthBytes,
										size_t xBytesAvailable,
										size_t xBytesToStoreMessageLength )
{
    28da:	0f 93       	push	r16
    28dc:	1f 93       	push	r17
    28de:	df 93       	push	r29
    28e0:	cf 93       	push	r28
    28e2:	cd b7       	in	r28, 0x3d	; 61
    28e4:	de b7       	in	r29, 0x3e	; 62
    28e6:	62 97       	sbiw	r28, 0x12	; 18
    28e8:	0f b6       	in	r0, 0x3f	; 63
    28ea:	f8 94       	cli
    28ec:	de bf       	out	0x3e, r29	; 62
    28ee:	0f be       	out	0x3f, r0	; 63
    28f0:	cd bf       	out	0x3d, r28	; 61
    28f2:	9a 87       	std	Y+10, r25	; 0x0a
    28f4:	89 87       	std	Y+9, r24	; 0x09
    28f6:	7c 87       	std	Y+12, r23	; 0x0c
    28f8:	6b 87       	std	Y+11, r22	; 0x0b
    28fa:	5e 87       	std	Y+14, r21	; 0x0e
    28fc:	4d 87       	std	Y+13, r20	; 0x0d
    28fe:	38 8b       	std	Y+16, r19	; 0x10
    2900:	2f 87       	std	Y+15, r18	; 0x0f
    2902:	1a 8b       	std	Y+18, r17	; 0x12
    2904:	09 8b       	std	Y+17, r16	; 0x11
size_t xOriginalTail, xReceivedLength, xNextMessageLength;
configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;

	if( xBytesToStoreMessageLength != ( size_t ) 0 )
    2906:	89 89       	ldd	r24, Y+17	; 0x11
    2908:	9a 89       	ldd	r25, Y+18	; 0x12
    290a:	00 97       	sbiw	r24, 0x00	; 0
    290c:	91 f1       	breq	.+100    	; 0x2972 <prvReadMessageFromBuffer+0x98>
	{
		/* A discrete message is being received.  First receive the length
		of the message.  A copy of the tail is stored so the buffer can be
		returned to its prior state if the length of the message is too
		large for the provided buffer. */
		xOriginalTail = pxStreamBuffer->xTail;
    290e:	e9 85       	ldd	r30, Y+9	; 0x09
    2910:	fa 85       	ldd	r31, Y+10	; 0x0a
    2912:	80 81       	ld	r24, Z
    2914:	91 81       	ldd	r25, Z+1	; 0x01
    2916:	9e 83       	std	Y+6, r25	; 0x06
    2918:	8d 83       	std	Y+5, r24	; 0x05
		( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, xBytesToStoreMessageLength, xBytesAvailable );
    291a:	ae 01       	movw	r20, r28
    291c:	49 5f       	subi	r20, 0xF9	; 249
    291e:	5f 4f       	sbci	r21, 0xFF	; 255
    2920:	89 85       	ldd	r24, Y+9	; 0x09
    2922:	9a 85       	ldd	r25, Y+10	; 0x0a
    2924:	29 89       	ldd	r18, Y+17	; 0x11
    2926:	3a 89       	ldd	r19, Y+18	; 0x12
    2928:	ef 85       	ldd	r30, Y+15	; 0x0f
    292a:	f8 89       	ldd	r31, Y+16	; 0x10
    292c:	ba 01       	movw	r22, r20
    292e:	a9 01       	movw	r20, r18
    2930:	9f 01       	movw	r18, r30
    2932:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <prvReadBytesFromBuffer>
		xNextMessageLength = ( size_t ) xTempNextMessageLength;
    2936:	8f 81       	ldd	r24, Y+7	; 0x07
    2938:	98 85       	ldd	r25, Y+8	; 0x08
    293a:	9a 83       	std	Y+2, r25	; 0x02
    293c:	89 83       	std	Y+1, r24	; 0x01

		/* Reduce the number of bytes available by the number of bytes just
		read out. */
		xBytesAvailable -= xBytesToStoreMessageLength;
    293e:	2f 85       	ldd	r18, Y+15	; 0x0f
    2940:	38 89       	ldd	r19, Y+16	; 0x10
    2942:	89 89       	ldd	r24, Y+17	; 0x11
    2944:	9a 89       	ldd	r25, Y+18	; 0x12
    2946:	a9 01       	movw	r20, r18
    2948:	48 1b       	sub	r20, r24
    294a:	59 0b       	sbc	r21, r25
    294c:	ca 01       	movw	r24, r20
    294e:	98 8b       	std	Y+16, r25	; 0x10
    2950:	8f 87       	std	Y+15, r24	; 0x0f

		/* Check there is enough space in the buffer provided by the
		user. */
		if( xNextMessageLength > xBufferLengthBytes )
    2952:	29 81       	ldd	r18, Y+1	; 0x01
    2954:	3a 81       	ldd	r19, Y+2	; 0x02
    2956:	8d 85       	ldd	r24, Y+13	; 0x0d
    2958:	9e 85       	ldd	r25, Y+14	; 0x0e
    295a:	82 17       	cp	r24, r18
    295c:	93 07       	cpc	r25, r19
    295e:	68 f4       	brcc	.+26     	; 0x297a <prvReadMessageFromBuffer+0xa0>
		{
			/* The user has provided insufficient space to read the message
			so return the buffer to its previous state (so the length of
			the message is in the buffer again). */
			pxStreamBuffer->xTail = xOriginalTail;
    2960:	e9 85       	ldd	r30, Y+9	; 0x09
    2962:	fa 85       	ldd	r31, Y+10	; 0x0a
    2964:	8d 81       	ldd	r24, Y+5	; 0x05
    2966:	9e 81       	ldd	r25, Y+6	; 0x06
    2968:	91 83       	std	Z+1, r25	; 0x01
    296a:	80 83       	st	Z, r24
			xNextMessageLength = 0;
    296c:	1a 82       	std	Y+2, r1	; 0x02
    296e:	19 82       	std	Y+1, r1	; 0x01
    2970:	04 c0       	rjmp	.+8      	; 0x297a <prvReadMessageFromBuffer+0xa0>
	}
	else
	{
		/* A stream of bytes is being received (as opposed to a discrete
		message), so read as many bytes as possible. */
		xNextMessageLength = xBufferLengthBytes;
    2972:	8d 85       	ldd	r24, Y+13	; 0x0d
    2974:	9e 85       	ldd	r25, Y+14	; 0x0e
    2976:	9a 83       	std	Y+2, r25	; 0x02
    2978:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Read the actual data. */
	xReceivedLength = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xNextMessageLength, xBytesAvailable ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    297a:	4b 85       	ldd	r20, Y+11	; 0x0b
    297c:	5c 85       	ldd	r21, Y+12	; 0x0c
    297e:	89 85       	ldd	r24, Y+9	; 0x09
    2980:	9a 85       	ldd	r25, Y+10	; 0x0a
    2982:	29 81       	ldd	r18, Y+1	; 0x01
    2984:	3a 81       	ldd	r19, Y+2	; 0x02
    2986:	ef 85       	ldd	r30, Y+15	; 0x0f
    2988:	f8 89       	ldd	r31, Y+16	; 0x10
    298a:	ba 01       	movw	r22, r20
    298c:	a9 01       	movw	r20, r18
    298e:	9f 01       	movw	r18, r30
    2990:	0e 94 51 16 	call	0x2ca2	; 0x2ca2 <prvReadBytesFromBuffer>
    2994:	9c 83       	std	Y+4, r25	; 0x04
    2996:	8b 83       	std	Y+3, r24	; 0x03

	return xReceivedLength;
    2998:	8b 81       	ldd	r24, Y+3	; 0x03
    299a:	9c 81       	ldd	r25, Y+4	; 0x04
}
    299c:	62 96       	adiw	r28, 0x12	; 18
    299e:	0f b6       	in	r0, 0x3f	; 63
    29a0:	f8 94       	cli
    29a2:	de bf       	out	0x3e, r29	; 62
    29a4:	0f be       	out	0x3f, r0	; 63
    29a6:	cd bf       	out	0x3d, r28	; 61
    29a8:	cf 91       	pop	r28
    29aa:	df 91       	pop	r29
    29ac:	1f 91       	pop	r17
    29ae:	0f 91       	pop	r16
    29b0:	08 95       	ret

000029b2 <xStreamBufferIsEmpty>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    29b2:	df 93       	push	r29
    29b4:	cf 93       	push	r28
    29b6:	cd b7       	in	r28, 0x3d	; 61
    29b8:	de b7       	in	r29, 0x3e	; 62
    29ba:	27 97       	sbiw	r28, 0x07	; 7
    29bc:	0f b6       	in	r0, 0x3f	; 63
    29be:	f8 94       	cli
    29c0:	de bf       	out	0x3e, r29	; 62
    29c2:	0f be       	out	0x3f, r0	; 63
    29c4:	cd bf       	out	0x3d, r28	; 61
    29c6:	9f 83       	std	Y+7, r25	; 0x07
    29c8:	8e 83       	std	Y+6, r24	; 0x06
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    29ca:	8e 81       	ldd	r24, Y+6	; 0x06
    29cc:	9f 81       	ldd	r25, Y+7	; 0x07
    29ce:	9d 83       	std	Y+5, r25	; 0x05
    29d0:	8c 83       	std	Y+4, r24	; 0x04
size_t xTail;

	configASSERT( pxStreamBuffer );

	/* True if no bytes are available. */
	xTail = pxStreamBuffer->xTail;
    29d2:	ec 81       	ldd	r30, Y+4	; 0x04
    29d4:	fd 81       	ldd	r31, Y+5	; 0x05
    29d6:	80 81       	ld	r24, Z
    29d8:	91 81       	ldd	r25, Z+1	; 0x01
    29da:	9a 83       	std	Y+2, r25	; 0x02
    29dc:	89 83       	std	Y+1, r24	; 0x01
	if( pxStreamBuffer->xHead == xTail )
    29de:	ec 81       	ldd	r30, Y+4	; 0x04
    29e0:	fd 81       	ldd	r31, Y+5	; 0x05
    29e2:	22 81       	ldd	r18, Z+2	; 0x02
    29e4:	33 81       	ldd	r19, Z+3	; 0x03
    29e6:	89 81       	ldd	r24, Y+1	; 0x01
    29e8:	9a 81       	ldd	r25, Y+2	; 0x02
    29ea:	28 17       	cp	r18, r24
    29ec:	39 07       	cpc	r19, r25
    29ee:	19 f4       	brne	.+6      	; 0x29f6 <xStreamBufferIsEmpty+0x44>
	{
		xReturn = pdTRUE;
    29f0:	81 e0       	ldi	r24, 0x01	; 1
    29f2:	8b 83       	std	Y+3, r24	; 0x03
    29f4:	01 c0       	rjmp	.+2      	; 0x29f8 <xStreamBufferIsEmpty+0x46>
	}
	else
	{
		xReturn = pdFALSE;
    29f6:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    29f8:	8b 81       	ldd	r24, Y+3	; 0x03
}
    29fa:	27 96       	adiw	r28, 0x07	; 7
    29fc:	0f b6       	in	r0, 0x3f	; 63
    29fe:	f8 94       	cli
    2a00:	de bf       	out	0x3e, r29	; 62
    2a02:	0f be       	out	0x3f, r0	; 63
    2a04:	cd bf       	out	0x3d, r28	; 61
    2a06:	cf 91       	pop	r28
    2a08:	df 91       	pop	r29
    2a0a:	08 95       	ret

00002a0c <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    2a0c:	df 93       	push	r29
    2a0e:	cf 93       	push	r28
    2a10:	cd b7       	in	r28, 0x3d	; 61
    2a12:	de b7       	in	r29, 0x3e	; 62
    2a14:	27 97       	sbiw	r28, 0x07	; 7
    2a16:	0f b6       	in	r0, 0x3f	; 63
    2a18:	f8 94       	cli
    2a1a:	de bf       	out	0x3e, r29	; 62
    2a1c:	0f be       	out	0x3f, r0	; 63
    2a1e:	cd bf       	out	0x3d, r28	; 61
    2a20:	9f 83       	std	Y+7, r25	; 0x07
    2a22:	8e 83       	std	Y+6, r24	; 0x06
BaseType_t xReturn;
size_t xBytesToStoreMessageLength;
const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2a24:	8e 81       	ldd	r24, Y+6	; 0x06
    2a26:	9f 81       	ldd	r25, Y+7	; 0x07
    2a28:	9a 83       	std	Y+2, r25	; 0x02
    2a2a:	89 83       	std	Y+1, r24	; 0x01

	/* This generic version of the receive function is used by both message
	buffers, which store discrete messages, and stream buffers, which store a
	continuous stream of bytes.  Discrete messages include an additional
	sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
	if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    2a2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a30:	86 85       	ldd	r24, Z+14	; 0x0e
    2a32:	88 2f       	mov	r24, r24
    2a34:	90 e0       	ldi	r25, 0x00	; 0
    2a36:	81 70       	andi	r24, 0x01	; 1
    2a38:	90 70       	andi	r25, 0x00	; 0
    2a3a:	88 23       	and	r24, r24
    2a3c:	29 f0       	breq	.+10     	; 0x2a48 <xStreamBufferIsFull+0x3c>
	{
		xBytesToStoreMessageLength = sbBYTES_TO_STORE_MESSAGE_LENGTH;
    2a3e:	82 e0       	ldi	r24, 0x02	; 2
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	9c 83       	std	Y+4, r25	; 0x04
    2a44:	8b 83       	std	Y+3, r24	; 0x03
    2a46:	02 c0       	rjmp	.+4      	; 0x2a4c <xStreamBufferIsFull+0x40>
	}
	else
	{
		xBytesToStoreMessageLength = 0;
    2a48:	1c 82       	std	Y+4, r1	; 0x04
    2a4a:	1b 82       	std	Y+3, r1	; 0x03
	}

	/* True if the available space equals zero. */
	if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    2a4c:	8e 81       	ldd	r24, Y+6	; 0x06
    2a4e:	9f 81       	ldd	r25, Y+7	; 0x07
    2a50:	0e 94 ce 10 	call	0x219c	; 0x219c <xStreamBufferSpacesAvailable>
    2a54:	9c 01       	movw	r18, r24
    2a56:	8b 81       	ldd	r24, Y+3	; 0x03
    2a58:	9c 81       	ldd	r25, Y+4	; 0x04
    2a5a:	82 17       	cp	r24, r18
    2a5c:	93 07       	cpc	r25, r19
    2a5e:	18 f0       	brcs	.+6      	; 0x2a66 <xStreamBufferIsFull+0x5a>
	{
		xReturn = pdTRUE;
    2a60:	81 e0       	ldi	r24, 0x01	; 1
    2a62:	8d 83       	std	Y+5, r24	; 0x05
    2a64:	01 c0       	rjmp	.+2      	; 0x2a68 <xStreamBufferIsFull+0x5c>
	}
	else
	{
		xReturn = pdFALSE;
    2a66:	1d 82       	std	Y+5, r1	; 0x05
	}

	return xReturn;
    2a68:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2a6a:	27 96       	adiw	r28, 0x07	; 7
    2a6c:	0f b6       	in	r0, 0x3f	; 63
    2a6e:	f8 94       	cli
    2a70:	de bf       	out	0x3e, r29	; 62
    2a72:	0f be       	out	0x3f, r0	; 63
    2a74:	cd bf       	out	0x3d, r28	; 61
    2a76:	cf 91       	pop	r28
    2a78:	df 91       	pop	r29
    2a7a:	08 95       	ret

00002a7c <xStreamBufferSendCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2a7c:	ef 92       	push	r14
    2a7e:	ff 92       	push	r15
    2a80:	0f 93       	push	r16
    2a82:	1f 93       	push	r17
    2a84:	df 93       	push	r29
    2a86:	cf 93       	push	r28
    2a88:	cd b7       	in	r28, 0x3d	; 61
    2a8a:	de b7       	in	r29, 0x3e	; 62
    2a8c:	28 97       	sbiw	r28, 0x08	; 8
    2a8e:	0f b6       	in	r0, 0x3f	; 63
    2a90:	f8 94       	cli
    2a92:	de bf       	out	0x3e, r29	; 62
    2a94:	0f be       	out	0x3f, r0	; 63
    2a96:	cd bf       	out	0x3d, r28	; 61
    2a98:	9e 83       	std	Y+6, r25	; 0x06
    2a9a:	8d 83       	std	Y+5, r24	; 0x05
    2a9c:	78 87       	std	Y+8, r23	; 0x08
    2a9e:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2aa0:	8d 81       	ldd	r24, Y+5	; 0x05
    2aa2:	9e 81       	ldd	r25, Y+6	; 0x06
    2aa4:	9c 83       	std	Y+4, r25	; 0x04
    2aa6:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2aa8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    2aaa:	eb 81       	ldd	r30, Y+3	; 0x03
    2aac:	fc 81       	ldd	r31, Y+4	; 0x04
    2aae:	80 85       	ldd	r24, Z+8	; 0x08
    2ab0:	91 85       	ldd	r25, Z+9	; 0x09
    2ab2:	00 97       	sbiw	r24, 0x00	; 0
    2ab4:	b9 f0       	breq	.+46     	; 0x2ae4 <xStreamBufferSendCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	80 85       	ldd	r24, Z+8	; 0x08
    2abc:	91 85       	ldd	r25, Z+9	; 0x09
    2abe:	ef 81       	ldd	r30, Y+7	; 0x07
    2ac0:	f8 85       	ldd	r31, Y+8	; 0x08
    2ac2:	40 e0       	ldi	r20, 0x00	; 0
    2ac4:	50 e0       	ldi	r21, 0x00	; 0
    2ac6:	60 e0       	ldi	r22, 0x00	; 0
    2ac8:	70 e0       	ldi	r23, 0x00	; 0
    2aca:	20 e0       	ldi	r18, 0x00	; 0
    2acc:	00 e0       	ldi	r16, 0x00	; 0
    2ace:	10 e0       	ldi	r17, 0x00	; 0
    2ad0:	7f 01       	movw	r14, r30
    2ad2:	0e 94 1d 24 	call	0x483a	; 0x483a <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    2ad6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ad8:	fc 81       	ldd	r31, Y+4	; 0x04
    2ada:	11 86       	std	Z+9, r1	; 0x09
    2adc:	10 86       	std	Z+8, r1	; 0x08
			xReturn = pdTRUE;
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	8a 83       	std	Y+2, r24	; 0x02
    2ae2:	01 c0       	rjmp	.+2      	; 0x2ae6 <xStreamBufferSendCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2ae4:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2ae6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2ae8:	28 96       	adiw	r28, 0x08	; 8
    2aea:	0f b6       	in	r0, 0x3f	; 63
    2aec:	f8 94       	cli
    2aee:	de bf       	out	0x3e, r29	; 62
    2af0:	0f be       	out	0x3f, r0	; 63
    2af2:	cd bf       	out	0x3d, r28	; 61
    2af4:	cf 91       	pop	r28
    2af6:	df 91       	pop	r29
    2af8:	1f 91       	pop	r17
    2afa:	0f 91       	pop	r16
    2afc:	ff 90       	pop	r15
    2afe:	ef 90       	pop	r14
    2b00:	08 95       	ret

00002b02 <xStreamBufferReceiveCompletedFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer, BaseType_t *pxHigherPriorityTaskWoken )
{
    2b02:	ef 92       	push	r14
    2b04:	ff 92       	push	r15
    2b06:	0f 93       	push	r16
    2b08:	1f 93       	push	r17
    2b0a:	df 93       	push	r29
    2b0c:	cf 93       	push	r28
    2b0e:	cd b7       	in	r28, 0x3d	; 61
    2b10:	de b7       	in	r29, 0x3e	; 62
    2b12:	28 97       	sbiw	r28, 0x08	; 8
    2b14:	0f b6       	in	r0, 0x3f	; 63
    2b16:	f8 94       	cli
    2b18:	de bf       	out	0x3e, r29	; 62
    2b1a:	0f be       	out	0x3f, r0	; 63
    2b1c:	cd bf       	out	0x3d, r28	; 61
    2b1e:	9e 83       	std	Y+6, r25	; 0x06
    2b20:	8d 83       	std	Y+5, r24	; 0x05
    2b22:	78 87       	std	Y+8, r23	; 0x08
    2b24:	6f 83       	std	Y+7, r22	; 0x07
StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    2b26:	8d 81       	ldd	r24, Y+5	; 0x05
    2b28:	9e 81       	ldd	r25, Y+6	; 0x06
    2b2a:	9c 83       	std	Y+4, r25	; 0x04
    2b2c:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;

	configASSERT( pxStreamBuffer );

	uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    2b2e:	19 82       	std	Y+1, r1	; 0x01
	{
		if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    2b30:	eb 81       	ldd	r30, Y+3	; 0x03
    2b32:	fc 81       	ldd	r31, Y+4	; 0x04
    2b34:	82 85       	ldd	r24, Z+10	; 0x0a
    2b36:	93 85       	ldd	r25, Z+11	; 0x0b
    2b38:	00 97       	sbiw	r24, 0x00	; 0
    2b3a:	b9 f0       	breq	.+46     	; 0x2b6a <xStreamBufferReceiveCompletedFromISR+0x68>
		{
			( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    2b3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b40:	82 85       	ldd	r24, Z+10	; 0x0a
    2b42:	93 85       	ldd	r25, Z+11	; 0x0b
    2b44:	ef 81       	ldd	r30, Y+7	; 0x07
    2b46:	f8 85       	ldd	r31, Y+8	; 0x08
    2b48:	40 e0       	ldi	r20, 0x00	; 0
    2b4a:	50 e0       	ldi	r21, 0x00	; 0
    2b4c:	60 e0       	ldi	r22, 0x00	; 0
    2b4e:	70 e0       	ldi	r23, 0x00	; 0
    2b50:	20 e0       	ldi	r18, 0x00	; 0
    2b52:	00 e0       	ldi	r16, 0x00	; 0
    2b54:	10 e0       	ldi	r17, 0x00	; 0
    2b56:	7f 01       	movw	r14, r30
    2b58:	0e 94 1d 24 	call	0x483a	; 0x483a <xTaskGenericNotifyFromISR>
										 ( uint32_t ) 0,
										 eNoAction,
										 pxHigherPriorityTaskWoken );
			( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    2b5c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b5e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b60:	13 86       	std	Z+11, r1	; 0x0b
    2b62:	12 86       	std	Z+10, r1	; 0x0a
			xReturn = pdTRUE;
    2b64:	81 e0       	ldi	r24, 0x01	; 1
    2b66:	8a 83       	std	Y+2, r24	; 0x02
    2b68:	01 c0       	rjmp	.+2      	; 0x2b6c <xStreamBufferReceiveCompletedFromISR+0x6a>
		}
		else
		{
			xReturn = pdFALSE;
    2b6a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2b6c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2b6e:	28 96       	adiw	r28, 0x08	; 8
    2b70:	0f b6       	in	r0, 0x3f	; 63
    2b72:	f8 94       	cli
    2b74:	de bf       	out	0x3e, r29	; 62
    2b76:	0f be       	out	0x3f, r0	; 63
    2b78:	cd bf       	out	0x3d, r28	; 61
    2b7a:	cf 91       	pop	r28
    2b7c:	df 91       	pop	r29
    2b7e:	1f 91       	pop	r17
    2b80:	0f 91       	pop	r16
    2b82:	ff 90       	pop	r15
    2b84:	ef 90       	pop	r14
    2b86:	08 95       	ret

00002b88 <prvWriteBytesToBuffer>:
/*-----------------------------------------------------------*/

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer, const uint8_t *pucData, size_t xCount )
{
    2b88:	df 93       	push	r29
    2b8a:	cf 93       	push	r28
    2b8c:	cd b7       	in	r28, 0x3d	; 61
    2b8e:	de b7       	in	r29, 0x3e	; 62
    2b90:	2e 97       	sbiw	r28, 0x0e	; 14
    2b92:	0f b6       	in	r0, 0x3f	; 63
    2b94:	f8 94       	cli
    2b96:	de bf       	out	0x3e, r29	; 62
    2b98:	0f be       	out	0x3f, r0	; 63
    2b9a:	cd bf       	out	0x3d, r28	; 61
    2b9c:	9e 83       	std	Y+6, r25	; 0x06
    2b9e:	8d 83       	std	Y+5, r24	; 0x05
    2ba0:	78 87       	std	Y+8, r23	; 0x08
    2ba2:	6f 83       	std	Y+7, r22	; 0x07
    2ba4:	5a 87       	std	Y+10, r21	; 0x0a
    2ba6:	49 87       	std	Y+9, r20	; 0x09
size_t xNextHead, xFirstLength;

	configASSERT( xCount > ( size_t ) 0 );

	xNextHead = pxStreamBuffer->xHead;
    2ba8:	ed 81       	ldd	r30, Y+5	; 0x05
    2baa:	fe 81       	ldd	r31, Y+6	; 0x06
    2bac:	82 81       	ldd	r24, Z+2	; 0x02
    2bae:	93 81       	ldd	r25, Z+3	; 0x03
    2bb0:	9c 83       	std	Y+4, r25	; 0x04
    2bb2:	8b 83       	std	Y+3, r24	; 0x03

	/* Calculate the number of bytes that can be added in the first write -
	which may be less than the total number of bytes that need to be added if
	the buffer will wrap back to the beginning. */
	xFirstLength = configMIN( pxStreamBuffer->xLength - xNextHead, xCount );
    2bb4:	ed 81       	ldd	r30, Y+5	; 0x05
    2bb6:	fe 81       	ldd	r31, Y+6	; 0x06
    2bb8:	24 81       	ldd	r18, Z+4	; 0x04
    2bba:	35 81       	ldd	r19, Z+5	; 0x05
    2bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2bc0:	a9 01       	movw	r20, r18
    2bc2:	48 1b       	sub	r20, r24
    2bc4:	59 0b       	sbc	r21, r25
    2bc6:	ca 01       	movw	r24, r20
    2bc8:	29 85       	ldd	r18, Y+9	; 0x09
    2bca:	3a 85       	ldd	r19, Y+10	; 0x0a
    2bcc:	3e 87       	std	Y+14, r19	; 0x0e
    2bce:	2d 87       	std	Y+13, r18	; 0x0d
    2bd0:	9c 87       	std	Y+12, r25	; 0x0c
    2bd2:	8b 87       	std	Y+11, r24	; 0x0b
    2bd4:	4b 85       	ldd	r20, Y+11	; 0x0b
    2bd6:	5c 85       	ldd	r21, Y+12	; 0x0c
    2bd8:	8d 85       	ldd	r24, Y+13	; 0x0d
    2bda:	9e 85       	ldd	r25, Y+14	; 0x0e
    2bdc:	84 17       	cp	r24, r20
    2bde:	95 07       	cpc	r25, r21
    2be0:	20 f4       	brcc	.+8      	; 0x2bea <prvWriteBytesToBuffer+0x62>
    2be2:	2d 85       	ldd	r18, Y+13	; 0x0d
    2be4:	3e 85       	ldd	r19, Y+14	; 0x0e
    2be6:	3c 87       	std	Y+12, r19	; 0x0c
    2be8:	2b 87       	std	Y+11, r18	; 0x0b
    2bea:	4b 85       	ldd	r20, Y+11	; 0x0b
    2bec:	5c 85       	ldd	r21, Y+12	; 0x0c
    2bee:	5a 83       	std	Y+2, r21	; 0x02
    2bf0:	49 83       	std	Y+1, r20	; 0x01

	/* Write as many bytes as can be written in the first write. */
	configASSERT( ( xNextHead + xFirstLength ) <= pxStreamBuffer->xLength );
	( void ) memcpy( ( void* ) ( &( pxStreamBuffer->pucBuffer[ xNextHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2bf2:	ed 81       	ldd	r30, Y+5	; 0x05
    2bf4:	fe 81       	ldd	r31, Y+6	; 0x06
    2bf6:	24 85       	ldd	r18, Z+12	; 0x0c
    2bf8:	35 85       	ldd	r19, Z+13	; 0x0d
    2bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    2bfe:	82 0f       	add	r24, r18
    2c00:	93 1f       	adc	r25, r19
    2c02:	2f 81       	ldd	r18, Y+7	; 0x07
    2c04:	38 85       	ldd	r19, Y+8	; 0x08
    2c06:	49 81       	ldd	r20, Y+1	; 0x01
    2c08:	5a 81       	ldd	r21, Y+2	; 0x02
    2c0a:	b9 01       	movw	r22, r18
    2c0c:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>

	/* If the number of bytes written was less than the number that could be
	written in the first write... */
	if( xCount > xFirstLength )
    2c10:	29 85       	ldd	r18, Y+9	; 0x09
    2c12:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c14:	89 81       	ldd	r24, Y+1	; 0x01
    2c16:	9a 81       	ldd	r25, Y+2	; 0x02
    2c18:	82 17       	cp	r24, r18
    2c1a:	93 07       	cpc	r25, r19
    2c1c:	b0 f4       	brcc	.+44     	; 0x2c4a <prvWriteBytesToBuffer+0xc2>
	{
		/* ...then write the remaining bytes to the start of the buffer. */
		configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2c1e:	ed 81       	ldd	r30, Y+5	; 0x05
    2c20:	fe 81       	ldd	r31, Y+6	; 0x06
    2c22:	64 85       	ldd	r22, Z+12	; 0x0c
    2c24:	75 85       	ldd	r23, Z+13	; 0x0d
    2c26:	2f 81       	ldd	r18, Y+7	; 0x07
    2c28:	38 85       	ldd	r19, Y+8	; 0x08
    2c2a:	89 81       	ldd	r24, Y+1	; 0x01
    2c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c2e:	a9 01       	movw	r20, r18
    2c30:	48 0f       	add	r20, r24
    2c32:	59 1f       	adc	r21, r25
    2c34:	29 85       	ldd	r18, Y+9	; 0x09
    2c36:	3a 85       	ldd	r19, Y+10	; 0x0a
    2c38:	89 81       	ldd	r24, Y+1	; 0x01
    2c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3c:	28 1b       	sub	r18, r24
    2c3e:	39 0b       	sbc	r19, r25
    2c40:	cb 01       	movw	r24, r22
    2c42:	ba 01       	movw	r22, r20
    2c44:	a9 01       	movw	r20, r18
    2c46:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	xNextHead += xCount;
    2c4a:	2b 81       	ldd	r18, Y+3	; 0x03
    2c4c:	3c 81       	ldd	r19, Y+4	; 0x04
    2c4e:	89 85       	ldd	r24, Y+9	; 0x09
    2c50:	9a 85       	ldd	r25, Y+10	; 0x0a
    2c52:	82 0f       	add	r24, r18
    2c54:	93 1f       	adc	r25, r19
    2c56:	9c 83       	std	Y+4, r25	; 0x04
    2c58:	8b 83       	std	Y+3, r24	; 0x03
	if( xNextHead >= pxStreamBuffer->xLength )
    2c5a:	ed 81       	ldd	r30, Y+5	; 0x05
    2c5c:	fe 81       	ldd	r31, Y+6	; 0x06
    2c5e:	24 81       	ldd	r18, Z+4	; 0x04
    2c60:	35 81       	ldd	r19, Z+5	; 0x05
    2c62:	8b 81       	ldd	r24, Y+3	; 0x03
    2c64:	9c 81       	ldd	r25, Y+4	; 0x04
    2c66:	82 17       	cp	r24, r18
    2c68:	93 07       	cpc	r25, r19
    2c6a:	50 f0       	brcs	.+20     	; 0x2c80 <prvWriteBytesToBuffer+0xf8>
	{
		xNextHead -= pxStreamBuffer->xLength;
    2c6c:	ed 81       	ldd	r30, Y+5	; 0x05
    2c6e:	fe 81       	ldd	r31, Y+6	; 0x06
    2c70:	24 81       	ldd	r18, Z+4	; 0x04
    2c72:	35 81       	ldd	r19, Z+5	; 0x05
    2c74:	8b 81       	ldd	r24, Y+3	; 0x03
    2c76:	9c 81       	ldd	r25, Y+4	; 0x04
    2c78:	82 1b       	sub	r24, r18
    2c7a:	93 0b       	sbc	r25, r19
    2c7c:	9c 83       	std	Y+4, r25	; 0x04
    2c7e:	8b 83       	std	Y+3, r24	; 0x03
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxStreamBuffer->xHead = xNextHead;
    2c80:	ed 81       	ldd	r30, Y+5	; 0x05
    2c82:	fe 81       	ldd	r31, Y+6	; 0x06
    2c84:	8b 81       	ldd	r24, Y+3	; 0x03
    2c86:	9c 81       	ldd	r25, Y+4	; 0x04
    2c88:	93 83       	std	Z+3, r25	; 0x03
    2c8a:	82 83       	std	Z+2, r24	; 0x02

	return xCount;
    2c8c:	89 85       	ldd	r24, Y+9	; 0x09
    2c8e:	9a 85       	ldd	r25, Y+10	; 0x0a
}
    2c90:	2e 96       	adiw	r28, 0x0e	; 14
    2c92:	0f b6       	in	r0, 0x3f	; 63
    2c94:	f8 94       	cli
    2c96:	de bf       	out	0x3e, r29	; 62
    2c98:	0f be       	out	0x3f, r0	; 63
    2c9a:	cd bf       	out	0x3d, r28	; 61
    2c9c:	cf 91       	pop	r28
    2c9e:	df 91       	pop	r29
    2ca0:	08 95       	ret

00002ca2 <prvReadBytesFromBuffer>:
/*-----------------------------------------------------------*/

static size_t prvReadBytesFromBuffer( StreamBuffer_t *pxStreamBuffer, uint8_t *pucData, size_t xMaxCount, size_t xBytesAvailable )
{
    2ca2:	df 93       	push	r29
    2ca4:	cf 93       	push	r28
    2ca6:	cd b7       	in	r28, 0x3d	; 61
    2ca8:	de b7       	in	r29, 0x3e	; 62
    2caa:	66 97       	sbiw	r28, 0x16	; 22
    2cac:	0f b6       	in	r0, 0x3f	; 63
    2cae:	f8 94       	cli
    2cb0:	de bf       	out	0x3e, r29	; 62
    2cb2:	0f be       	out	0x3f, r0	; 63
    2cb4:	cd bf       	out	0x3d, r28	; 61
    2cb6:	98 87       	std	Y+8, r25	; 0x08
    2cb8:	8f 83       	std	Y+7, r24	; 0x07
    2cba:	7a 87       	std	Y+10, r23	; 0x0a
    2cbc:	69 87       	std	Y+9, r22	; 0x09
    2cbe:	5c 87       	std	Y+12, r21	; 0x0c
    2cc0:	4b 87       	std	Y+11, r20	; 0x0b
    2cc2:	3e 87       	std	Y+14, r19	; 0x0e
    2cc4:	2d 87       	std	Y+13, r18	; 0x0d
size_t xCount, xFirstLength, xNextTail;

	/* Use the minimum of the wanted bytes and the available bytes. */
	xCount = configMIN( xBytesAvailable, xMaxCount );
    2cc6:	2d 85       	ldd	r18, Y+13	; 0x0d
    2cc8:	3e 85       	ldd	r19, Y+14	; 0x0e
    2cca:	3a 8b       	std	Y+18, r19	; 0x12
    2ccc:	29 8b       	std	Y+17, r18	; 0x11
    2cce:	4b 85       	ldd	r20, Y+11	; 0x0b
    2cd0:	5c 85       	ldd	r21, Y+12	; 0x0c
    2cd2:	58 8b       	std	Y+16, r21	; 0x10
    2cd4:	4f 87       	std	Y+15, r20	; 0x0f
    2cd6:	8f 85       	ldd	r24, Y+15	; 0x0f
    2cd8:	98 89       	ldd	r25, Y+16	; 0x10
    2cda:	29 89       	ldd	r18, Y+17	; 0x11
    2cdc:	3a 89       	ldd	r19, Y+18	; 0x12
    2cde:	28 17       	cp	r18, r24
    2ce0:	39 07       	cpc	r19, r25
    2ce2:	20 f4       	brcc	.+8      	; 0x2cec <prvReadBytesFromBuffer+0x4a>
    2ce4:	49 89       	ldd	r20, Y+17	; 0x11
    2ce6:	5a 89       	ldd	r21, Y+18	; 0x12
    2ce8:	58 8b       	std	Y+16, r21	; 0x10
    2cea:	4f 87       	std	Y+15, r20	; 0x0f
    2cec:	8f 85       	ldd	r24, Y+15	; 0x0f
    2cee:	98 89       	ldd	r25, Y+16	; 0x10
    2cf0:	9e 83       	std	Y+6, r25	; 0x06
    2cf2:	8d 83       	std	Y+5, r24	; 0x05

	if( xCount > ( size_t ) 0 )
    2cf4:	8d 81       	ldd	r24, Y+5	; 0x05
    2cf6:	9e 81       	ldd	r25, Y+6	; 0x06
    2cf8:	00 97       	sbiw	r24, 0x00	; 0
    2cfa:	09 f4       	brne	.+2      	; 0x2cfe <prvReadBytesFromBuffer+0x5c>
    2cfc:	74 c0       	rjmp	.+232    	; 0x2de6 <prvReadBytesFromBuffer+0x144>
	{
		xNextTail = pxStreamBuffer->xTail;
    2cfe:	ef 81       	ldd	r30, Y+7	; 0x07
    2d00:	f8 85       	ldd	r31, Y+8	; 0x08
    2d02:	80 81       	ld	r24, Z
    2d04:	91 81       	ldd	r25, Z+1	; 0x01
    2d06:	9a 83       	std	Y+2, r25	; 0x02
    2d08:	89 83       	std	Y+1, r24	; 0x01

		/* Calculate the number of bytes that can be read - which may be
		less than the number wanted if the data wraps around to the start of
		the buffer. */
		xFirstLength = configMIN( pxStreamBuffer->xLength - xNextTail, xCount );
    2d0a:	ef 81       	ldd	r30, Y+7	; 0x07
    2d0c:	f8 85       	ldd	r31, Y+8	; 0x08
    2d0e:	24 81       	ldd	r18, Z+4	; 0x04
    2d10:	35 81       	ldd	r19, Z+5	; 0x05
    2d12:	89 81       	ldd	r24, Y+1	; 0x01
    2d14:	9a 81       	ldd	r25, Y+2	; 0x02
    2d16:	a9 01       	movw	r20, r18
    2d18:	48 1b       	sub	r20, r24
    2d1a:	59 0b       	sbc	r21, r25
    2d1c:	ca 01       	movw	r24, r20
    2d1e:	2d 81       	ldd	r18, Y+5	; 0x05
    2d20:	3e 81       	ldd	r19, Y+6	; 0x06
    2d22:	3e 8b       	std	Y+22, r19	; 0x16
    2d24:	2d 8b       	std	Y+21, r18	; 0x15
    2d26:	9c 8b       	std	Y+20, r25	; 0x14
    2d28:	8b 8b       	std	Y+19, r24	; 0x13
    2d2a:	4b 89       	ldd	r20, Y+19	; 0x13
    2d2c:	5c 89       	ldd	r21, Y+20	; 0x14
    2d2e:	8d 89       	ldd	r24, Y+21	; 0x15
    2d30:	9e 89       	ldd	r25, Y+22	; 0x16
    2d32:	84 17       	cp	r24, r20
    2d34:	95 07       	cpc	r25, r21
    2d36:	20 f4       	brcc	.+8      	; 0x2d40 <prvReadBytesFromBuffer+0x9e>
    2d38:	2d 89       	ldd	r18, Y+21	; 0x15
    2d3a:	3e 89       	ldd	r19, Y+22	; 0x16
    2d3c:	3c 8b       	std	Y+20, r19	; 0x14
    2d3e:	2b 8b       	std	Y+19, r18	; 0x13
    2d40:	4b 89       	ldd	r20, Y+19	; 0x13
    2d42:	5c 89       	ldd	r21, Y+20	; 0x14
    2d44:	5c 83       	std	Y+4, r21	; 0x04
    2d46:	4b 83       	std	Y+3, r20	; 0x03

		/* Obtain the number of bytes it is possible to obtain in the first
		read.  Asserts check bounds of read and write. */
		configASSERT( xFirstLength <= xMaxCount );
		configASSERT( ( xNextTail + xFirstLength ) <= pxStreamBuffer->xLength );
		( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xNextTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d48:	ef 81       	ldd	r30, Y+7	; 0x07
    2d4a:	f8 85       	ldd	r31, Y+8	; 0x08
    2d4c:	24 85       	ldd	r18, Z+12	; 0x0c
    2d4e:	35 85       	ldd	r19, Z+13	; 0x0d
    2d50:	89 81       	ldd	r24, Y+1	; 0x01
    2d52:	9a 81       	ldd	r25, Y+2	; 0x02
    2d54:	a9 01       	movw	r20, r18
    2d56:	48 0f       	add	r20, r24
    2d58:	59 1f       	adc	r21, r25
    2d5a:	89 85       	ldd	r24, Y+9	; 0x09
    2d5c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2d5e:	2b 81       	ldd	r18, Y+3	; 0x03
    2d60:	3c 81       	ldd	r19, Y+4	; 0x04
    2d62:	ba 01       	movw	r22, r20
    2d64:	a9 01       	movw	r20, r18
    2d66:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>

		/* If the total number of wanted bytes is greater than the number
		that could be read in the first read... */
		if( xCount > xFirstLength )
    2d6a:	2d 81       	ldd	r18, Y+5	; 0x05
    2d6c:	3e 81       	ldd	r19, Y+6	; 0x06
    2d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d70:	9c 81       	ldd	r25, Y+4	; 0x04
    2d72:	82 17       	cp	r24, r18
    2d74:	93 07       	cpc	r25, r19
    2d76:	b0 f4       	brcc	.+44     	; 0x2da4 <prvReadBytesFromBuffer+0x102>
		{
			/*...then read the remaining bytes from the start of the buffer. */
			configASSERT( xCount <= xMaxCount );
			( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    2d78:	29 85       	ldd	r18, Y+9	; 0x09
    2d7a:	3a 85       	ldd	r19, Y+10	; 0x0a
    2d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d80:	b9 01       	movw	r22, r18
    2d82:	68 0f       	add	r22, r24
    2d84:	79 1f       	adc	r23, r25
    2d86:	ef 81       	ldd	r30, Y+7	; 0x07
    2d88:	f8 85       	ldd	r31, Y+8	; 0x08
    2d8a:	44 85       	ldd	r20, Z+12	; 0x0c
    2d8c:	55 85       	ldd	r21, Z+13	; 0x0d
    2d8e:	2d 81       	ldd	r18, Y+5	; 0x05
    2d90:	3e 81       	ldd	r19, Y+6	; 0x06
    2d92:	8b 81       	ldd	r24, Y+3	; 0x03
    2d94:	9c 81       	ldd	r25, Y+4	; 0x04
    2d96:	28 1b       	sub	r18, r24
    2d98:	39 0b       	sbc	r19, r25
    2d9a:	cb 01       	movw	r24, r22
    2d9c:	ba 01       	movw	r22, r20
    2d9e:	a9 01       	movw	r20, r18
    2da0:	0e 94 c2 35 	call	0x6b84	; 0x6b84 <memcpy>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Move the tail pointer to effectively remove the data read from
		the buffer. */
		xNextTail += xCount;
    2da4:	29 81       	ldd	r18, Y+1	; 0x01
    2da6:	3a 81       	ldd	r19, Y+2	; 0x02
    2da8:	8d 81       	ldd	r24, Y+5	; 0x05
    2daa:	9e 81       	ldd	r25, Y+6	; 0x06
    2dac:	82 0f       	add	r24, r18
    2dae:	93 1f       	adc	r25, r19
    2db0:	9a 83       	std	Y+2, r25	; 0x02
    2db2:	89 83       	std	Y+1, r24	; 0x01

		if( xNextTail >= pxStreamBuffer->xLength )
    2db4:	ef 81       	ldd	r30, Y+7	; 0x07
    2db6:	f8 85       	ldd	r31, Y+8	; 0x08
    2db8:	24 81       	ldd	r18, Z+4	; 0x04
    2dba:	35 81       	ldd	r19, Z+5	; 0x05
    2dbc:	89 81       	ldd	r24, Y+1	; 0x01
    2dbe:	9a 81       	ldd	r25, Y+2	; 0x02
    2dc0:	82 17       	cp	r24, r18
    2dc2:	93 07       	cpc	r25, r19
    2dc4:	50 f0       	brcs	.+20     	; 0x2dda <prvReadBytesFromBuffer+0x138>
		{
			xNextTail -= pxStreamBuffer->xLength;
    2dc6:	ef 81       	ldd	r30, Y+7	; 0x07
    2dc8:	f8 85       	ldd	r31, Y+8	; 0x08
    2dca:	24 81       	ldd	r18, Z+4	; 0x04
    2dcc:	35 81       	ldd	r19, Z+5	; 0x05
    2dce:	89 81       	ldd	r24, Y+1	; 0x01
    2dd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2dd2:	82 1b       	sub	r24, r18
    2dd4:	93 0b       	sbc	r25, r19
    2dd6:	9a 83       	std	Y+2, r25	; 0x02
    2dd8:	89 83       	std	Y+1, r24	; 0x01
		}

		pxStreamBuffer->xTail = xNextTail;
    2dda:	ef 81       	ldd	r30, Y+7	; 0x07
    2ddc:	f8 85       	ldd	r31, Y+8	; 0x08
    2dde:	89 81       	ldd	r24, Y+1	; 0x01
    2de0:	9a 81       	ldd	r25, Y+2	; 0x02
    2de2:	91 83       	std	Z+1, r25	; 0x01
    2de4:	80 83       	st	Z, r24
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2de6:	8d 81       	ldd	r24, Y+5	; 0x05
    2de8:	9e 81       	ldd	r25, Y+6	; 0x06
}
    2dea:	66 96       	adiw	r28, 0x16	; 22
    2dec:	0f b6       	in	r0, 0x3f	; 63
    2dee:	f8 94       	cli
    2df0:	de bf       	out	0x3e, r29	; 62
    2df2:	0f be       	out	0x3f, r0	; 63
    2df4:	cd bf       	out	0x3d, r28	; 61
    2df6:	cf 91       	pop	r28
    2df8:	df 91       	pop	r29
    2dfa:	08 95       	ret

00002dfc <prvBytesInBuffer>:
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    2dfc:	df 93       	push	r29
    2dfe:	cf 93       	push	r28
    2e00:	00 d0       	rcall	.+0      	; 0x2e02 <prvBytesInBuffer+0x6>
    2e02:	00 d0       	rcall	.+0      	; 0x2e04 <prvBytesInBuffer+0x8>
    2e04:	cd b7       	in	r28, 0x3d	; 61
    2e06:	de b7       	in	r29, 0x3e	; 62
    2e08:	9c 83       	std	Y+4, r25	; 0x04
    2e0a:	8b 83       	std	Y+3, r24	; 0x03
/* Returns the distance between xTail and xHead. */
size_t xCount;

	xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    2e0c:	eb 81       	ldd	r30, Y+3	; 0x03
    2e0e:	fc 81       	ldd	r31, Y+4	; 0x04
    2e10:	24 81       	ldd	r18, Z+4	; 0x04
    2e12:	35 81       	ldd	r19, Z+5	; 0x05
    2e14:	eb 81       	ldd	r30, Y+3	; 0x03
    2e16:	fc 81       	ldd	r31, Y+4	; 0x04
    2e18:	82 81       	ldd	r24, Z+2	; 0x02
    2e1a:	93 81       	ldd	r25, Z+3	; 0x03
    2e1c:	82 0f       	add	r24, r18
    2e1e:	93 1f       	adc	r25, r19
    2e20:	9a 83       	std	Y+2, r25	; 0x02
    2e22:	89 83       	std	Y+1, r24	; 0x01
	xCount -= pxStreamBuffer->xTail;
    2e24:	eb 81       	ldd	r30, Y+3	; 0x03
    2e26:	fc 81       	ldd	r31, Y+4	; 0x04
    2e28:	20 81       	ld	r18, Z
    2e2a:	31 81       	ldd	r19, Z+1	; 0x01
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e30:	82 1b       	sub	r24, r18
    2e32:	93 0b       	sbc	r25, r19
    2e34:	9a 83       	std	Y+2, r25	; 0x02
    2e36:	89 83       	std	Y+1, r24	; 0x01
	if ( xCount >= pxStreamBuffer->xLength )
    2e38:	eb 81       	ldd	r30, Y+3	; 0x03
    2e3a:	fc 81       	ldd	r31, Y+4	; 0x04
    2e3c:	24 81       	ldd	r18, Z+4	; 0x04
    2e3e:	35 81       	ldd	r19, Z+5	; 0x05
    2e40:	89 81       	ldd	r24, Y+1	; 0x01
    2e42:	9a 81       	ldd	r25, Y+2	; 0x02
    2e44:	82 17       	cp	r24, r18
    2e46:	93 07       	cpc	r25, r19
    2e48:	50 f0       	brcs	.+20     	; 0x2e5e <prvBytesInBuffer+0x62>
	{
		xCount -= pxStreamBuffer->xLength;
    2e4a:	eb 81       	ldd	r30, Y+3	; 0x03
    2e4c:	fc 81       	ldd	r31, Y+4	; 0x04
    2e4e:	24 81       	ldd	r18, Z+4	; 0x04
    2e50:	35 81       	ldd	r19, Z+5	; 0x05
    2e52:	89 81       	ldd	r24, Y+1	; 0x01
    2e54:	9a 81       	ldd	r25, Y+2	; 0x02
    2e56:	82 1b       	sub	r24, r18
    2e58:	93 0b       	sbc	r25, r19
    2e5a:	9a 83       	std	Y+2, r25	; 0x02
    2e5c:	89 83       	std	Y+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xCount;
    2e5e:	89 81       	ldd	r24, Y+1	; 0x01
    2e60:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2e62:	0f 90       	pop	r0
    2e64:	0f 90       	pop	r0
    2e66:	0f 90       	pop	r0
    2e68:	0f 90       	pop	r0
    2e6a:	cf 91       	pop	r28
    2e6c:	df 91       	pop	r29
    2e6e:	08 95       	ret

00002e70 <prvInitialiseNewStreamBuffer>:
static void prvInitialiseNewStreamBuffer( StreamBuffer_t * const pxStreamBuffer,
										  uint8_t * const pucBuffer,
										  size_t xBufferSizeBytes,
										  size_t xTriggerLevelBytes,
										  uint8_t ucFlags )
{
    2e70:	0f 93       	push	r16
    2e72:	df 93       	push	r29
    2e74:	cf 93       	push	r28
    2e76:	cd b7       	in	r28, 0x3d	; 61
    2e78:	de b7       	in	r29, 0x3e	; 62
    2e7a:	29 97       	sbiw	r28, 0x09	; 9
    2e7c:	0f b6       	in	r0, 0x3f	; 63
    2e7e:	f8 94       	cli
    2e80:	de bf       	out	0x3e, r29	; 62
    2e82:	0f be       	out	0x3f, r0	; 63
    2e84:	cd bf       	out	0x3d, r28	; 61
    2e86:	9a 83       	std	Y+2, r25	; 0x02
    2e88:	89 83       	std	Y+1, r24	; 0x01
    2e8a:	7c 83       	std	Y+4, r23	; 0x04
    2e8c:	6b 83       	std	Y+3, r22	; 0x03
    2e8e:	5e 83       	std	Y+6, r21	; 0x06
    2e90:	4d 83       	std	Y+5, r20	; 0x05
    2e92:	38 87       	std	Y+8, r19	; 0x08
    2e94:	2f 83       	std	Y+7, r18	; 0x07
    2e96:	09 87       	std	Y+9, r16	; 0x09
		const BaseType_t xWriteValue = 0x55;
		configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
	} /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
	#endif

	( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    2e98:	89 81       	ldd	r24, Y+1	; 0x01
    2e9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2e9c:	60 e0       	ldi	r22, 0x00	; 0
    2e9e:	70 e0       	ldi	r23, 0x00	; 0
    2ea0:	4f e0       	ldi	r20, 0x0F	; 15
    2ea2:	50 e0       	ldi	r21, 0x00	; 0
    2ea4:	0e 94 cb 35 	call	0x6b96	; 0x6b96 <memset>
	pxStreamBuffer->pucBuffer = pucBuffer;
    2ea8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eaa:	fa 81       	ldd	r31, Y+2	; 0x02
    2eac:	8b 81       	ldd	r24, Y+3	; 0x03
    2eae:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb0:	95 87       	std	Z+13, r25	; 0x0d
    2eb2:	84 87       	std	Z+12, r24	; 0x0c
	pxStreamBuffer->xLength = xBufferSizeBytes;
    2eb4:	e9 81       	ldd	r30, Y+1	; 0x01
    2eb6:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb8:	8d 81       	ldd	r24, Y+5	; 0x05
    2eba:	9e 81       	ldd	r25, Y+6	; 0x06
    2ebc:	95 83       	std	Z+5, r25	; 0x05
    2ebe:	84 83       	std	Z+4, r24	; 0x04
	pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    2ec0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec4:	8f 81       	ldd	r24, Y+7	; 0x07
    2ec6:	98 85       	ldd	r25, Y+8	; 0x08
    2ec8:	97 83       	std	Z+7, r25	; 0x07
    2eca:	86 83       	std	Z+6, r24	; 0x06
	pxStreamBuffer->ucFlags = ucFlags;
    2ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ece:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed0:	89 85       	ldd	r24, Y+9	; 0x09
    2ed2:	86 87       	std	Z+14, r24	; 0x0e
}
    2ed4:	29 96       	adiw	r28, 0x09	; 9
    2ed6:	0f b6       	in	r0, 0x3f	; 63
    2ed8:	f8 94       	cli
    2eda:	de bf       	out	0x3e, r29	; 62
    2edc:	0f be       	out	0x3f, r0	; 63
    2ede:	cd bf       	out	0x3d, r28	; 61
    2ee0:	cf 91       	pop	r28
    2ee2:	df 91       	pop	r29
    2ee4:	0f 91       	pop	r16
    2ee6:	08 95       	ret

00002ee8 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    2ee8:	8f 92       	push	r8
    2eea:	9f 92       	push	r9
    2eec:	af 92       	push	r10
    2eee:	bf 92       	push	r11
    2ef0:	cf 92       	push	r12
    2ef2:	df 92       	push	r13
    2ef4:	ef 92       	push	r14
    2ef6:	ff 92       	push	r15
    2ef8:	0f 93       	push	r16
    2efa:	1f 93       	push	r17
    2efc:	df 93       	push	r29
    2efe:	cf 93       	push	r28
    2f00:	cd b7       	in	r28, 0x3d	; 61
    2f02:	de b7       	in	r29, 0x3e	; 62
    2f04:	60 97       	sbiw	r28, 0x10	; 16
    2f06:	0f b6       	in	r0, 0x3f	; 63
    2f08:	f8 94       	cli
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	0f be       	out	0x3f, r0	; 63
    2f0e:	cd bf       	out	0x3d, r28	; 61
    2f10:	9f 83       	std	Y+7, r25	; 0x07
    2f12:	8e 83       	std	Y+6, r24	; 0x06
    2f14:	79 87       	std	Y+9, r23	; 0x09
    2f16:	68 87       	std	Y+8, r22	; 0x08
    2f18:	5b 87       	std	Y+11, r21	; 0x0b
    2f1a:	4a 87       	std	Y+10, r20	; 0x0a
    2f1c:	3d 87       	std	Y+13, r19	; 0x0d
    2f1e:	2c 87       	std	Y+12, r18	; 0x0c
    2f20:	0e 87       	std	Y+14, r16	; 0x0e
    2f22:	f8 8a       	std	Y+16, r15	; 0x10
    2f24:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2f26:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f28:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f2a:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2f2e:	9a 83       	std	Y+2, r25	; 0x02
    2f30:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2f32:	89 81       	ldd	r24, Y+1	; 0x01
    2f34:	9a 81       	ldd	r25, Y+2	; 0x02
    2f36:	00 97       	sbiw	r24, 0x00	; 0
    2f38:	b1 f0       	breq	.+44     	; 0x2f66 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2f3a:	88 e2       	ldi	r24, 0x28	; 40
    2f3c:	90 e0       	ldi	r25, 0x00	; 0
    2f3e:	0e 94 8e 03 	call	0x71c	; 0x71c <pvPortMalloc>
    2f42:	9d 83       	std	Y+5, r25	; 0x05
    2f44:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2f46:	8c 81       	ldd	r24, Y+4	; 0x04
    2f48:	9d 81       	ldd	r25, Y+5	; 0x05
    2f4a:	00 97       	sbiw	r24, 0x00	; 0
    2f4c:	39 f0       	breq	.+14     	; 0x2f5c <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2f4e:	ec 81       	ldd	r30, Y+4	; 0x04
    2f50:	fd 81       	ldd	r31, Y+5	; 0x05
    2f52:	89 81       	ldd	r24, Y+1	; 0x01
    2f54:	9a 81       	ldd	r25, Y+2	; 0x02
    2f56:	90 8f       	std	Z+24, r25	; 0x18
    2f58:	87 8b       	std	Z+23, r24	; 0x17
    2f5a:	07 c0       	rjmp	.+14     	; 0x2f6a <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2f5c:	89 81       	ldd	r24, Y+1	; 0x01
    2f5e:	9a 81       	ldd	r25, Y+2	; 0x02
    2f60:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
    2f64:	02 c0       	rjmp	.+4      	; 0x2f6a <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2f66:	1d 82       	std	Y+5, r1	; 0x05
    2f68:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2f6a:	8c 81       	ldd	r24, Y+4	; 0x04
    2f6c:	9d 81       	ldd	r25, Y+5	; 0x05
    2f6e:	00 97       	sbiw	r24, 0x00	; 0
    2f70:	e9 f0       	breq	.+58     	; 0x2fac <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2f72:	8a 85       	ldd	r24, Y+10	; 0x0a
    2f74:	9b 85       	ldd	r25, Y+11	; 0x0b
    2f76:	9c 01       	movw	r18, r24
    2f78:	40 e0       	ldi	r20, 0x00	; 0
    2f7a:	50 e0       	ldi	r21, 0x00	; 0
    2f7c:	8e 81       	ldd	r24, Y+6	; 0x06
    2f7e:	9f 81       	ldd	r25, Y+7	; 0x07
    2f80:	68 85       	ldd	r22, Y+8	; 0x08
    2f82:	79 85       	ldd	r23, Y+9	; 0x09
    2f84:	ec 85       	ldd	r30, Y+12	; 0x0c
    2f86:	fd 85       	ldd	r31, Y+13	; 0x0d
    2f88:	af 85       	ldd	r26, Y+15	; 0x0f
    2f8a:	b8 89       	ldd	r27, Y+16	; 0x10
    2f8c:	ac 80       	ldd	r10, Y+4	; 0x04
    2f8e:	bd 80       	ldd	r11, Y+5	; 0x05
    2f90:	8f 01       	movw	r16, r30
    2f92:	ee 84       	ldd	r14, Y+14	; 0x0e
    2f94:	6d 01       	movw	r12, r26
    2f96:	88 24       	eor	r8, r8
    2f98:	99 24       	eor	r9, r9
    2f9a:	0e 94 ec 17 	call	0x2fd8	; 0x2fd8 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2f9e:	8c 81       	ldd	r24, Y+4	; 0x04
    2fa0:	9d 81       	ldd	r25, Y+5	; 0x05
    2fa2:	0e 94 af 18 	call	0x315e	; 0x315e <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2fa6:	81 e0       	ldi	r24, 0x01	; 1
    2fa8:	8b 83       	std	Y+3, r24	; 0x03
    2faa:	02 c0       	rjmp	.+4      	; 0x2fb0 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2fac:	8f ef       	ldi	r24, 0xFF	; 255
    2fae:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2fb0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2fb2:	60 96       	adiw	r28, 0x10	; 16
    2fb4:	0f b6       	in	r0, 0x3f	; 63
    2fb6:	f8 94       	cli
    2fb8:	de bf       	out	0x3e, r29	; 62
    2fba:	0f be       	out	0x3f, r0	; 63
    2fbc:	cd bf       	out	0x3d, r28	; 61
    2fbe:	cf 91       	pop	r28
    2fc0:	df 91       	pop	r29
    2fc2:	1f 91       	pop	r17
    2fc4:	0f 91       	pop	r16
    2fc6:	ff 90       	pop	r15
    2fc8:	ef 90       	pop	r14
    2fca:	df 90       	pop	r13
    2fcc:	cf 90       	pop	r12
    2fce:	bf 90       	pop	r11
    2fd0:	af 90       	pop	r10
    2fd2:	9f 90       	pop	r9
    2fd4:	8f 90       	pop	r8
    2fd6:	08 95       	ret

00002fd8 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2fd8:	8f 92       	push	r8
    2fda:	9f 92       	push	r9
    2fdc:	af 92       	push	r10
    2fde:	bf 92       	push	r11
    2fe0:	cf 92       	push	r12
    2fe2:	df 92       	push	r13
    2fe4:	ef 92       	push	r14
    2fe6:	0f 93       	push	r16
    2fe8:	1f 93       	push	r17
    2fea:	df 93       	push	r29
    2fec:	cf 93       	push	r28
    2fee:	cd b7       	in	r28, 0x3d	; 61
    2ff0:	de b7       	in	r29, 0x3e	; 62
    2ff2:	64 97       	sbiw	r28, 0x14	; 20
    2ff4:	0f b6       	in	r0, 0x3f	; 63
    2ff6:	f8 94       	cli
    2ff8:	de bf       	out	0x3e, r29	; 62
    2ffa:	0f be       	out	0x3f, r0	; 63
    2ffc:	cd bf       	out	0x3d, r28	; 61
    2ffe:	9d 83       	std	Y+5, r25	; 0x05
    3000:	8c 83       	std	Y+4, r24	; 0x04
    3002:	7f 83       	std	Y+7, r23	; 0x07
    3004:	6e 83       	std	Y+6, r22	; 0x06
    3006:	28 87       	std	Y+8, r18	; 0x08
    3008:	39 87       	std	Y+9, r19	; 0x09
    300a:	4a 87       	std	Y+10, r20	; 0x0a
    300c:	5b 87       	std	Y+11, r21	; 0x0b
    300e:	1d 87       	std	Y+13, r17	; 0x0d
    3010:	0c 87       	std	Y+12, r16	; 0x0c
    3012:	ee 86       	std	Y+14, r14	; 0x0e
    3014:	d8 8a       	std	Y+16, r13	; 0x10
    3016:	cf 86       	std	Y+15, r12	; 0x0f
    3018:	ba 8a       	std	Y+18, r11	; 0x12
    301a:	a9 8a       	std	Y+17, r10	; 0x11
    301c:	9c 8a       	std	Y+20, r9	; 0x14
    301e:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    3020:	e9 89       	ldd	r30, Y+17	; 0x11
    3022:	fa 89       	ldd	r31, Y+18	; 0x12
    3024:	27 89       	ldd	r18, Z+23	; 0x17
    3026:	30 8d       	ldd	r19, Z+24	; 0x18
    3028:	88 85       	ldd	r24, Y+8	; 0x08
    302a:	99 85       	ldd	r25, Y+9	; 0x09
    302c:	01 97       	sbiw	r24, 0x01	; 1
    302e:	82 0f       	add	r24, r18
    3030:	93 1f       	adc	r25, r19
    3032:	9b 83       	std	Y+3, r25	; 0x03
    3034:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    3036:	8e 81       	ldd	r24, Y+6	; 0x06
    3038:	9f 81       	ldd	r25, Y+7	; 0x07
    303a:	00 97       	sbiw	r24, 0x00	; 0
    303c:	51 f1       	breq	.+84     	; 0x3092 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    303e:	19 82       	std	Y+1, r1	; 0x01
    3040:	21 c0       	rjmp	.+66     	; 0x3084 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    3042:	89 81       	ldd	r24, Y+1	; 0x01
    3044:	48 2f       	mov	r20, r24
    3046:	50 e0       	ldi	r21, 0x00	; 0
    3048:	89 81       	ldd	r24, Y+1	; 0x01
    304a:	28 2f       	mov	r18, r24
    304c:	30 e0       	ldi	r19, 0x00	; 0
    304e:	8e 81       	ldd	r24, Y+6	; 0x06
    3050:	9f 81       	ldd	r25, Y+7	; 0x07
    3052:	fc 01       	movw	r30, r24
    3054:	e2 0f       	add	r30, r18
    3056:	f3 1f       	adc	r31, r19
    3058:	20 81       	ld	r18, Z
    305a:	89 89       	ldd	r24, Y+17	; 0x11
    305c:	9a 89       	ldd	r25, Y+18	; 0x12
    305e:	84 0f       	add	r24, r20
    3060:	95 1f       	adc	r25, r21
    3062:	fc 01       	movw	r30, r24
    3064:	79 96       	adiw	r30, 0x19	; 25
    3066:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    3068:	89 81       	ldd	r24, Y+1	; 0x01
    306a:	28 2f       	mov	r18, r24
    306c:	30 e0       	ldi	r19, 0x00	; 0
    306e:	8e 81       	ldd	r24, Y+6	; 0x06
    3070:	9f 81       	ldd	r25, Y+7	; 0x07
    3072:	fc 01       	movw	r30, r24
    3074:	e2 0f       	add	r30, r18
    3076:	f3 1f       	adc	r31, r19
    3078:	80 81       	ld	r24, Z
    307a:	88 23       	and	r24, r24
    307c:	31 f0       	breq	.+12     	; 0x308a <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    307e:	89 81       	ldd	r24, Y+1	; 0x01
    3080:	8f 5f       	subi	r24, 0xFF	; 255
    3082:	89 83       	std	Y+1, r24	; 0x01
    3084:	89 81       	ldd	r24, Y+1	; 0x01
    3086:	88 30       	cpi	r24, 0x08	; 8
    3088:	e0 f2       	brcs	.-72     	; 0x3042 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    308a:	e9 89       	ldd	r30, Y+17	; 0x11
    308c:	fa 89       	ldd	r31, Y+18	; 0x12
    308e:	10 a2       	std	Z+32, r1	; 0x20
    3090:	03 c0       	rjmp	.+6      	; 0x3098 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    3092:	e9 89       	ldd	r30, Y+17	; 0x11
    3094:	fa 89       	ldd	r31, Y+18	; 0x12
    3096:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3098:	8e 85       	ldd	r24, Y+14	; 0x0e
    309a:	84 30       	cpi	r24, 0x04	; 4
    309c:	10 f0       	brcs	.+4      	; 0x30a2 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    309e:	83 e0       	ldi	r24, 0x03	; 3
    30a0:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    30a2:	e9 89       	ldd	r30, Y+17	; 0x11
    30a4:	fa 89       	ldd	r31, Y+18	; 0x12
    30a6:	8e 85       	ldd	r24, Y+14	; 0x0e
    30a8:	86 8b       	std	Z+22, r24	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxNewTCB->uxBasePriority = uxPriority;
    30aa:	e9 89       	ldd	r30, Y+17	; 0x11
    30ac:	fa 89       	ldd	r31, Y+18	; 0x12
    30ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    30b0:	81 a3       	std	Z+33, r24	; 0x21
		pxNewTCB->uxMutexesHeld = 0;
    30b2:	e9 89       	ldd	r30, Y+17	; 0x11
    30b4:	fa 89       	ldd	r31, Y+18	; 0x12
    30b6:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    30b8:	89 89       	ldd	r24, Y+17	; 0x11
    30ba:	9a 89       	ldd	r25, Y+18	; 0x12
    30bc:	02 96       	adiw	r24, 0x02	; 2
    30be:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    30c2:	89 89       	ldd	r24, Y+17	; 0x11
    30c4:	9a 89       	ldd	r25, Y+18	; 0x12
    30c6:	0c 96       	adiw	r24, 0x0c	; 12
    30c8:	0e 94 34 04 	call	0x868	; 0x868 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    30cc:	e9 89       	ldd	r30, Y+17	; 0x11
    30ce:	fa 89       	ldd	r31, Y+18	; 0x12
    30d0:	89 89       	ldd	r24, Y+17	; 0x11
    30d2:	9a 89       	ldd	r25, Y+18	; 0x12
    30d4:	91 87       	std	Z+9, r25	; 0x09
    30d6:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    30d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    30da:	28 2f       	mov	r18, r24
    30dc:	30 e0       	ldi	r19, 0x00	; 0
    30de:	84 e0       	ldi	r24, 0x04	; 4
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    30e2:	82 1b       	sub	r24, r18
    30e4:	93 0b       	sbc	r25, r19
    30e6:	e9 89       	ldd	r30, Y+17	; 0x11
    30e8:	fa 89       	ldd	r31, Y+18	; 0x12
    30ea:	95 87       	std	Z+13, r25	; 0x0d
    30ec:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    30ee:	e9 89       	ldd	r30, Y+17	; 0x11
    30f0:	fa 89       	ldd	r31, Y+18	; 0x12
    30f2:	89 89       	ldd	r24, Y+17	; 0x11
    30f4:	9a 89       	ldd	r25, Y+18	; 0x12
    30f6:	93 8b       	std	Z+19, r25	; 0x13
    30f8:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    30fa:	e9 89       	ldd	r30, Y+17	; 0x11
    30fc:	fa 89       	ldd	r31, Y+18	; 0x12
    30fe:	13 a2       	std	Z+35, r1	; 0x23
    3100:	14 a2       	std	Z+36, r1	; 0x24
    3102:	15 a2       	std	Z+37, r1	; 0x25
    3104:	16 a2       	std	Z+38, r1	; 0x26
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3106:	e9 89       	ldd	r30, Y+17	; 0x11
    3108:	fa 89       	ldd	r31, Y+18	; 0x12
    310a:	17 a2       	std	Z+39, r1	; 0x27
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    310c:	8a 81       	ldd	r24, Y+2	; 0x02
    310e:	9b 81       	ldd	r25, Y+3	; 0x03
    3110:	2c 81       	ldd	r18, Y+4	; 0x04
    3112:	3d 81       	ldd	r19, Y+5	; 0x05
    3114:	4c 85       	ldd	r20, Y+12	; 0x0c
    3116:	5d 85       	ldd	r21, Y+13	; 0x0d
    3118:	b9 01       	movw	r22, r18
    311a:	0e 94 40 05 	call	0xa80	; 0xa80 <pxPortInitialiseStack>
    311e:	e9 89       	ldd	r30, Y+17	; 0x11
    3120:	fa 89       	ldd	r31, Y+18	; 0x12
    3122:	91 83       	std	Z+1, r25	; 0x01
    3124:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    3126:	8f 85       	ldd	r24, Y+15	; 0x0f
    3128:	98 89       	ldd	r25, Y+16	; 0x10
    312a:	00 97       	sbiw	r24, 0x00	; 0
    312c:	31 f0       	breq	.+12     	; 0x313a <prvInitialiseNewTask+0x162>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    312e:	ef 85       	ldd	r30, Y+15	; 0x0f
    3130:	f8 89       	ldd	r31, Y+16	; 0x10
    3132:	89 89       	ldd	r24, Y+17	; 0x11
    3134:	9a 89       	ldd	r25, Y+18	; 0x12
    3136:	91 83       	std	Z+1, r25	; 0x01
    3138:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    313a:	64 96       	adiw	r28, 0x14	; 20
    313c:	0f b6       	in	r0, 0x3f	; 63
    313e:	f8 94       	cli
    3140:	de bf       	out	0x3e, r29	; 62
    3142:	0f be       	out	0x3f, r0	; 63
    3144:	cd bf       	out	0x3d, r28	; 61
    3146:	cf 91       	pop	r28
    3148:	df 91       	pop	r29
    314a:	1f 91       	pop	r17
    314c:	0f 91       	pop	r16
    314e:	ef 90       	pop	r14
    3150:	df 90       	pop	r13
    3152:	cf 90       	pop	r12
    3154:	bf 90       	pop	r11
    3156:	af 90       	pop	r10
    3158:	9f 90       	pop	r9
    315a:	8f 90       	pop	r8
    315c:	08 95       	ret

0000315e <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    315e:	df 93       	push	r29
    3160:	cf 93       	push	r28
    3162:	00 d0       	rcall	.+0      	; 0x3164 <prvAddNewTaskToReadyList+0x6>
    3164:	cd b7       	in	r28, 0x3d	; 61
    3166:	de b7       	in	r29, 0x3e	; 62
    3168:	9a 83       	std	Y+2, r25	; 0x02
    316a:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    316c:	0f b6       	in	r0, 0x3f	; 63
    316e:	f8 94       	cli
    3170:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    3172:	80 91 eb 06 	lds	r24, 0x06EB
    3176:	8f 5f       	subi	r24, 0xFF	; 255
    3178:	80 93 eb 06 	sts	0x06EB, r24
		if( pxCurrentTCB == NULL )
    317c:	80 91 e8 06 	lds	r24, 0x06E8
    3180:	90 91 e9 06 	lds	r25, 0x06E9
    3184:	00 97       	sbiw	r24, 0x00	; 0
    3186:	69 f4       	brne	.+26     	; 0x31a2 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    3188:	89 81       	ldd	r24, Y+1	; 0x01
    318a:	9a 81       	ldd	r25, Y+2	; 0x02
    318c:	90 93 e9 06 	sts	0x06E9, r25
    3190:	80 93 e8 06 	sts	0x06E8, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    3194:	80 91 eb 06 	lds	r24, 0x06EB
    3198:	81 30       	cpi	r24, 0x01	; 1
    319a:	b9 f4       	brne	.+46     	; 0x31ca <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    319c:	0e 94 86 1f 	call	0x3f0c	; 0x3f0c <prvInitialiseTaskLists>
    31a0:	14 c0       	rjmp	.+40     	; 0x31ca <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    31a2:	80 91 ef 06 	lds	r24, 0x06EF
    31a6:	88 23       	and	r24, r24
    31a8:	81 f4       	brne	.+32     	; 0x31ca <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    31aa:	e0 91 e8 06 	lds	r30, 0x06E8
    31ae:	f0 91 e9 06 	lds	r31, 0x06E9
    31b2:	96 89       	ldd	r25, Z+22	; 0x16
    31b4:	e9 81       	ldd	r30, Y+1	; 0x01
    31b6:	fa 81       	ldd	r31, Y+2	; 0x02
    31b8:	86 89       	ldd	r24, Z+22	; 0x16
    31ba:	89 17       	cp	r24, r25
    31bc:	30 f0       	brcs	.+12     	; 0x31ca <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    31be:	89 81       	ldd	r24, Y+1	; 0x01
    31c0:	9a 81       	ldd	r25, Y+2	; 0x02
    31c2:	90 93 e9 06 	sts	0x06E9, r25
    31c6:	80 93 e8 06 	sts	0x06E8, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    31ca:	80 91 f3 06 	lds	r24, 0x06F3
    31ce:	8f 5f       	subi	r24, 0xFF	; 255
    31d0:	80 93 f3 06 	sts	0x06F3, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    31d4:	e9 81       	ldd	r30, Y+1	; 0x01
    31d6:	fa 81       	ldd	r31, Y+2	; 0x02
    31d8:	96 89       	ldd	r25, Z+22	; 0x16
    31da:	80 91 ee 06 	lds	r24, 0x06EE
    31de:	89 17       	cp	r24, r25
    31e0:	28 f4       	brcc	.+10     	; 0x31ec <prvAddNewTaskToReadyList+0x8e>
    31e2:	e9 81       	ldd	r30, Y+1	; 0x01
    31e4:	fa 81       	ldd	r31, Y+2	; 0x02
    31e6:	86 89       	ldd	r24, Z+22	; 0x16
    31e8:	80 93 ee 06 	sts	0x06EE, r24
    31ec:	e9 81       	ldd	r30, Y+1	; 0x01
    31ee:	fa 81       	ldd	r31, Y+2	; 0x02
    31f0:	86 89       	ldd	r24, Z+22	; 0x16
    31f2:	28 2f       	mov	r18, r24
    31f4:	30 e0       	ldi	r19, 0x00	; 0
    31f6:	c9 01       	movw	r24, r18
    31f8:	88 0f       	add	r24, r24
    31fa:	99 1f       	adc	r25, r25
    31fc:	88 0f       	add	r24, r24
    31fe:	99 1f       	adc	r25, r25
    3200:	88 0f       	add	r24, r24
    3202:	99 1f       	adc	r25, r25
    3204:	82 0f       	add	r24, r18
    3206:	93 1f       	adc	r25, r19
    3208:	ac 01       	movw	r20, r24
    320a:	47 50       	subi	r20, 0x07	; 7
    320c:	59 4f       	sbci	r21, 0xF9	; 249
    320e:	89 81       	ldd	r24, Y+1	; 0x01
    3210:	9a 81       	ldd	r25, Y+2	; 0x02
    3212:	9c 01       	movw	r18, r24
    3214:	2e 5f       	subi	r18, 0xFE	; 254
    3216:	3f 4f       	sbci	r19, 0xFF	; 255
    3218:	ca 01       	movw	r24, r20
    321a:	b9 01       	movw	r22, r18
    321c:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    3220:	0f 90       	pop	r0
    3222:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    3224:	80 91 ef 06 	lds	r24, 0x06EF
    3228:	88 23       	and	r24, r24
    322a:	61 f0       	breq	.+24     	; 0x3244 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    322c:	e0 91 e8 06 	lds	r30, 0x06E8
    3230:	f0 91 e9 06 	lds	r31, 0x06E9
    3234:	96 89       	ldd	r25, Z+22	; 0x16
    3236:	e9 81       	ldd	r30, Y+1	; 0x01
    3238:	fa 81       	ldd	r31, Y+2	; 0x02
    323a:	86 89       	ldd	r24, Z+22	; 0x16
    323c:	98 17       	cp	r25, r24
    323e:	10 f4       	brcc	.+4      	; 0x3244 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    3240:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    3244:	0f 90       	pop	r0
    3246:	0f 90       	pop	r0
    3248:	cf 91       	pop	r28
    324a:	df 91       	pop	r29
    324c:	08 95       	ret

0000324e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    324e:	df 93       	push	r29
    3250:	cf 93       	push	r28
    3252:	00 d0       	rcall	.+0      	; 0x3254 <vTaskDelete+0x6>
    3254:	00 d0       	rcall	.+0      	; 0x3256 <vTaskDelete+0x8>
    3256:	00 d0       	rcall	.+0      	; 0x3258 <vTaskDelete+0xa>
    3258:	cd b7       	in	r28, 0x3d	; 61
    325a:	de b7       	in	r29, 0x3e	; 62
    325c:	9c 83       	std	Y+4, r25	; 0x04
    325e:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3260:	0f b6       	in	r0, 0x3f	; 63
    3262:	f8 94       	cli
    3264:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    3266:	8b 81       	ldd	r24, Y+3	; 0x03
    3268:	9c 81       	ldd	r25, Y+4	; 0x04
    326a:	00 97       	sbiw	r24, 0x00	; 0
    326c:	39 f4       	brne	.+14     	; 0x327c <vTaskDelete+0x2e>
    326e:	80 91 e8 06 	lds	r24, 0x06E8
    3272:	90 91 e9 06 	lds	r25, 0x06E9
    3276:	9e 83       	std	Y+6, r25	; 0x06
    3278:	8d 83       	std	Y+5, r24	; 0x05
    327a:	04 c0       	rjmp	.+8      	; 0x3284 <vTaskDelete+0x36>
    327c:	8b 81       	ldd	r24, Y+3	; 0x03
    327e:	9c 81       	ldd	r25, Y+4	; 0x04
    3280:	9e 83       	std	Y+6, r25	; 0x06
    3282:	8d 83       	std	Y+5, r24	; 0x05
    3284:	8d 81       	ldd	r24, Y+5	; 0x05
    3286:	9e 81       	ldd	r25, Y+6	; 0x06
    3288:	9a 83       	std	Y+2, r25	; 0x02
    328a:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    328c:	89 81       	ldd	r24, Y+1	; 0x01
    328e:	9a 81       	ldd	r25, Y+2	; 0x02
    3290:	02 96       	adiw	r24, 0x02	; 2
    3292:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3296:	e9 81       	ldd	r30, Y+1	; 0x01
    3298:	fa 81       	ldd	r31, Y+2	; 0x02
    329a:	84 89       	ldd	r24, Z+20	; 0x14
    329c:	95 89       	ldd	r25, Z+21	; 0x15
    329e:	00 97       	sbiw	r24, 0x00	; 0
    32a0:	29 f0       	breq	.+10     	; 0x32ac <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    32a2:	89 81       	ldd	r24, Y+1	; 0x01
    32a4:	9a 81       	ldd	r25, Y+2	; 0x02
    32a6:	0c 96       	adiw	r24, 0x0c	; 12
    32a8:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    32ac:	80 91 f3 06 	lds	r24, 0x06F3
    32b0:	8f 5f       	subi	r24, 0xFF	; 255
    32b2:	80 93 f3 06 	sts	0x06F3, r24

			if( pxTCB == pxCurrentTCB )
    32b6:	20 91 e8 06 	lds	r18, 0x06E8
    32ba:	30 91 e9 06 	lds	r19, 0x06E9
    32be:	89 81       	ldd	r24, Y+1	; 0x01
    32c0:	9a 81       	ldd	r25, Y+2	; 0x02
    32c2:	82 17       	cp	r24, r18
    32c4:	93 07       	cpc	r25, r19
    32c6:	81 f4       	brne	.+32     	; 0x32e8 <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    32c8:	89 81       	ldd	r24, Y+1	; 0x01
    32ca:	9a 81       	ldd	r25, Y+2	; 0x02
    32cc:	9c 01       	movw	r18, r24
    32ce:	2e 5f       	subi	r18, 0xFE	; 254
    32d0:	3f 4f       	sbci	r19, 0xFF	; 255
    32d2:	8c e3       	ldi	r24, 0x3C	; 60
    32d4:	97 e0       	ldi	r25, 0x07	; 7
    32d6:	b9 01       	movw	r22, r18
    32d8:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    32dc:	80 91 ea 06 	lds	r24, 0x06EA
    32e0:	8f 5f       	subi	r24, 0xFF	; 255
    32e2:	80 93 ea 06 	sts	0x06EA, r24
    32e6:	0b c0       	rjmp	.+22     	; 0x32fe <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    32e8:	80 91 eb 06 	lds	r24, 0x06EB
    32ec:	81 50       	subi	r24, 0x01	; 1
    32ee:	80 93 eb 06 	sts	0x06EB, r24
				prvDeleteTCB( pxTCB );
    32f2:	89 81       	ldd	r24, Y+1	; 0x01
    32f4:	9a 81       	ldd	r25, Y+2	; 0x02
    32f6:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    32fa:	0e 94 0c 20 	call	0x4018	; 0x4018 <prvResetNextTaskUnblockTime>
			}

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    32fe:	0f 90       	pop	r0
    3300:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    3302:	80 91 ef 06 	lds	r24, 0x06EF
    3306:	88 23       	and	r24, r24
    3308:	59 f0       	breq	.+22     	; 0x3320 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    330a:	20 91 e8 06 	lds	r18, 0x06E8
    330e:	30 91 e9 06 	lds	r19, 0x06E9
    3312:	89 81       	ldd	r24, Y+1	; 0x01
    3314:	9a 81       	ldd	r25, Y+2	; 0x02
    3316:	82 17       	cp	r24, r18
    3318:	93 07       	cpc	r25, r19
    331a:	11 f4       	brne	.+4      	; 0x3320 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    331c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    3320:	26 96       	adiw	r28, 0x06	; 6
    3322:	0f b6       	in	r0, 0x3f	; 63
    3324:	f8 94       	cli
    3326:	de bf       	out	0x3e, r29	; 62
    3328:	0f be       	out	0x3f, r0	; 63
    332a:	cd bf       	out	0x3d, r28	; 61
    332c:	cf 91       	pop	r28
    332e:	df 91       	pop	r29
    3330:	08 95       	ret

00003332 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3332:	df 93       	push	r29
    3334:	cf 93       	push	r28
    3336:	00 d0       	rcall	.+0      	; 0x3338 <vTaskDelay+0x6>
    3338:	0f 92       	push	r0
    333a:	cd b7       	in	r28, 0x3d	; 61
    333c:	de b7       	in	r29, 0x3e	; 62
    333e:	9b 83       	std	Y+3, r25	; 0x03
    3340:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3342:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    3344:	8a 81       	ldd	r24, Y+2	; 0x02
    3346:	9b 81       	ldd	r25, Y+3	; 0x03
    3348:	00 97       	sbiw	r24, 0x00	; 0
    334a:	51 f0       	breq	.+20     	; 0x3360 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    334c:	0e 94 66 1b 	call	0x36cc	; 0x36cc <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3350:	8a 81       	ldd	r24, Y+2	; 0x02
    3352:	9b 81       	ldd	r25, Y+3	; 0x03
    3354:	60 e0       	ldi	r22, 0x00	; 0
    3356:	0e 94 d5 25 	call	0x4baa	; 0x4baa <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    335a:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <xTaskResumeAll>
    335e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3360:	89 81       	ldd	r24, Y+1	; 0x01
    3362:	88 23       	and	r24, r24
    3364:	11 f4       	brne	.+4      	; 0x336a <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    3366:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    336a:	0f 90       	pop	r0
    336c:	0f 90       	pop	r0
    336e:	0f 90       	pop	r0
    3370:	cf 91       	pop	r28
    3372:	df 91       	pop	r29
    3374:	08 95       	ret

00003376 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    3376:	df 93       	push	r29
    3378:	cf 93       	push	r28
    337a:	00 d0       	rcall	.+0      	; 0x337c <vTaskSuspend+0x6>
    337c:	00 d0       	rcall	.+0      	; 0x337e <vTaskSuspend+0x8>
    337e:	00 d0       	rcall	.+0      	; 0x3380 <vTaskSuspend+0xa>
    3380:	cd b7       	in	r28, 0x3d	; 61
    3382:	de b7       	in	r29, 0x3e	; 62
    3384:	9c 83       	std	Y+4, r25	; 0x04
    3386:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    3388:	0f b6       	in	r0, 0x3f	; 63
    338a:	f8 94       	cli
    338c:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    338e:	8b 81       	ldd	r24, Y+3	; 0x03
    3390:	9c 81       	ldd	r25, Y+4	; 0x04
    3392:	00 97       	sbiw	r24, 0x00	; 0
    3394:	39 f4       	brne	.+14     	; 0x33a4 <vTaskSuspend+0x2e>
    3396:	80 91 e8 06 	lds	r24, 0x06E8
    339a:	90 91 e9 06 	lds	r25, 0x06E9
    339e:	9e 83       	std	Y+6, r25	; 0x06
    33a0:	8d 83       	std	Y+5, r24	; 0x05
    33a2:	04 c0       	rjmp	.+8      	; 0x33ac <vTaskSuspend+0x36>
    33a4:	8b 81       	ldd	r24, Y+3	; 0x03
    33a6:	9c 81       	ldd	r25, Y+4	; 0x04
    33a8:	9e 83       	std	Y+6, r25	; 0x06
    33aa:	8d 83       	std	Y+5, r24	; 0x05
    33ac:	8d 81       	ldd	r24, Y+5	; 0x05
    33ae:	9e 81       	ldd	r25, Y+6	; 0x06
    33b0:	9a 83       	std	Y+2, r25	; 0x02
    33b2:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    33b4:	89 81       	ldd	r24, Y+1	; 0x01
    33b6:	9a 81       	ldd	r25, Y+2	; 0x02
    33b8:	02 96       	adiw	r24, 0x02	; 2
    33ba:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    33be:	e9 81       	ldd	r30, Y+1	; 0x01
    33c0:	fa 81       	ldd	r31, Y+2	; 0x02
    33c2:	84 89       	ldd	r24, Z+20	; 0x14
    33c4:	95 89       	ldd	r25, Z+21	; 0x15
    33c6:	00 97       	sbiw	r24, 0x00	; 0
    33c8:	29 f0       	breq	.+10     	; 0x33d4 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    33ca:	89 81       	ldd	r24, Y+1	; 0x01
    33cc:	9a 81       	ldd	r25, Y+2	; 0x02
    33ce:	0c 96       	adiw	r24, 0x0c	; 12
    33d0:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    33d4:	89 81       	ldd	r24, Y+1	; 0x01
    33d6:	9a 81       	ldd	r25, Y+2	; 0x02
    33d8:	9c 01       	movw	r18, r24
    33da:	2e 5f       	subi	r18, 0xFE	; 254
    33dc:	3f 4f       	sbci	r19, 0xFF	; 255
    33de:	85 e4       	ldi	r24, 0x45	; 69
    33e0:	97 e0       	ldi	r25, 0x07	; 7
    33e2:	b9 01       	movw	r22, r18
    33e4:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    33e8:	e9 81       	ldd	r30, Y+1	; 0x01
    33ea:	fa 81       	ldd	r31, Y+2	; 0x02
    33ec:	87 a1       	ldd	r24, Z+39	; 0x27
    33ee:	81 30       	cpi	r24, 0x01	; 1
    33f0:	19 f4       	brne	.+6      	; 0x33f8 <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    33f2:	e9 81       	ldd	r30, Y+1	; 0x01
    33f4:	fa 81       	ldd	r31, Y+2	; 0x02
    33f6:	17 a2       	std	Z+39, r1	; 0x27
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    33f8:	0f 90       	pop	r0
    33fa:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    33fc:	80 91 ef 06 	lds	r24, 0x06EF
    3400:	88 23       	and	r24, r24
    3402:	39 f0       	breq	.+14     	; 0x3412 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3404:	0f b6       	in	r0, 0x3f	; 63
    3406:	f8 94       	cli
    3408:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    340a:	0e 94 0c 20 	call	0x4018	; 0x4018 <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    340e:	0f 90       	pop	r0
    3410:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3412:	20 91 e8 06 	lds	r18, 0x06E8
    3416:	30 91 e9 06 	lds	r19, 0x06E9
    341a:	89 81       	ldd	r24, Y+1	; 0x01
    341c:	9a 81       	ldd	r25, Y+2	; 0x02
    341e:	82 17       	cp	r24, r18
    3420:	93 07       	cpc	r25, r19
    3422:	a1 f4       	brne	.+40     	; 0x344c <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3424:	80 91 ef 06 	lds	r24, 0x06EF
    3428:	88 23       	and	r24, r24
    342a:	19 f0       	breq	.+6      	; 0x3432 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    342c:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
    3430:	0d c0       	rjmp	.+26     	; 0x344c <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3432:	90 91 45 07 	lds	r25, 0x0745
    3436:	80 91 eb 06 	lds	r24, 0x06EB
    343a:	98 17       	cp	r25, r24
    343c:	29 f4       	brne	.+10     	; 0x3448 <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    343e:	10 92 e9 06 	sts	0x06E9, r1
    3442:	10 92 e8 06 	sts	0x06E8, r1
    3446:	02 c0       	rjmp	.+4      	; 0x344c <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    3448:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    344c:	26 96       	adiw	r28, 0x06	; 6
    344e:	0f b6       	in	r0, 0x3f	; 63
    3450:	f8 94       	cli
    3452:	de bf       	out	0x3e, r29	; 62
    3454:	0f be       	out	0x3f, r0	; 63
    3456:	cd bf       	out	0x3d, r28	; 61
    3458:	cf 91       	pop	r28
    345a:	df 91       	pop	r29
    345c:	08 95       	ret

0000345e <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    345e:	df 93       	push	r29
    3460:	cf 93       	push	r28
    3462:	00 d0       	rcall	.+0      	; 0x3464 <prvTaskIsTaskSuspended+0x6>
    3464:	00 d0       	rcall	.+0      	; 0x3466 <prvTaskIsTaskSuspended+0x8>
    3466:	0f 92       	push	r0
    3468:	cd b7       	in	r28, 0x3d	; 61
    346a:	de b7       	in	r29, 0x3e	; 62
    346c:	9d 83       	std	Y+5, r25	; 0x05
    346e:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    3470:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    3472:	8c 81       	ldd	r24, Y+4	; 0x04
    3474:	9d 81       	ldd	r25, Y+5	; 0x05
    3476:	9a 83       	std	Y+2, r25	; 0x02
    3478:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    347a:	e9 81       	ldd	r30, Y+1	; 0x01
    347c:	fa 81       	ldd	r31, Y+2	; 0x02
    347e:	82 85       	ldd	r24, Z+10	; 0x0a
    3480:	93 85       	ldd	r25, Z+11	; 0x0b
    3482:	27 e0       	ldi	r18, 0x07	; 7
    3484:	85 34       	cpi	r24, 0x45	; 69
    3486:	92 07       	cpc	r25, r18
    3488:	81 f4       	brne	.+32     	; 0x34aa <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    348a:	e9 81       	ldd	r30, Y+1	; 0x01
    348c:	fa 81       	ldd	r31, Y+2	; 0x02
    348e:	84 89       	ldd	r24, Z+20	; 0x14
    3490:	95 89       	ldd	r25, Z+21	; 0x15
    3492:	27 e0       	ldi	r18, 0x07	; 7
    3494:	83 33       	cpi	r24, 0x33	; 51
    3496:	92 07       	cpc	r25, r18
    3498:	41 f0       	breq	.+16     	; 0x34aa <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    349a:	e9 81       	ldd	r30, Y+1	; 0x01
    349c:	fa 81       	ldd	r31, Y+2	; 0x02
    349e:	84 89       	ldd	r24, Z+20	; 0x14
    34a0:	95 89       	ldd	r25, Z+21	; 0x15
    34a2:	00 97       	sbiw	r24, 0x00	; 0
    34a4:	11 f4       	brne	.+4      	; 0x34aa <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    34a6:	81 e0       	ldi	r24, 0x01	; 1
    34a8:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    34aa:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    34ac:	0f 90       	pop	r0
    34ae:	0f 90       	pop	r0
    34b0:	0f 90       	pop	r0
    34b2:	0f 90       	pop	r0
    34b4:	0f 90       	pop	r0
    34b6:	cf 91       	pop	r28
    34b8:	df 91       	pop	r29
    34ba:	08 95       	ret

000034bc <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    34bc:	df 93       	push	r29
    34be:	cf 93       	push	r28
    34c0:	00 d0       	rcall	.+0      	; 0x34c2 <vTaskResume+0x6>
    34c2:	00 d0       	rcall	.+0      	; 0x34c4 <vTaskResume+0x8>
    34c4:	cd b7       	in	r28, 0x3d	; 61
    34c6:	de b7       	in	r29, 0x3e	; 62
    34c8:	9c 83       	std	Y+4, r25	; 0x04
    34ca:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    34cc:	8b 81       	ldd	r24, Y+3	; 0x03
    34ce:	9c 81       	ldd	r25, Y+4	; 0x04
    34d0:	9a 83       	std	Y+2, r25	; 0x02
    34d2:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    34d4:	20 91 e8 06 	lds	r18, 0x06E8
    34d8:	30 91 e9 06 	lds	r19, 0x06E9
    34dc:	89 81       	ldd	r24, Y+1	; 0x01
    34de:	9a 81       	ldd	r25, Y+2	; 0x02
    34e0:	82 17       	cp	r24, r18
    34e2:	93 07       	cpc	r25, r19
    34e4:	09 f4       	brne	.+2      	; 0x34e8 <vTaskResume+0x2c>
    34e6:	47 c0       	rjmp	.+142    	; 0x3576 <vTaskResume+0xba>
    34e8:	89 81       	ldd	r24, Y+1	; 0x01
    34ea:	9a 81       	ldd	r25, Y+2	; 0x02
    34ec:	00 97       	sbiw	r24, 0x00	; 0
    34ee:	09 f4       	brne	.+2      	; 0x34f2 <vTaskResume+0x36>
    34f0:	42 c0       	rjmp	.+132    	; 0x3576 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    34f2:	0f b6       	in	r0, 0x3f	; 63
    34f4:	f8 94       	cli
    34f6:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    34f8:	89 81       	ldd	r24, Y+1	; 0x01
    34fa:	9a 81       	ldd	r25, Y+2	; 0x02
    34fc:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvTaskIsTaskSuspended>
    3500:	88 23       	and	r24, r24
    3502:	b9 f1       	breq	.+110    	; 0x3572 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3504:	89 81       	ldd	r24, Y+1	; 0x01
    3506:	9a 81       	ldd	r25, Y+2	; 0x02
    3508:	02 96       	adiw	r24, 0x02	; 2
    350a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    350e:	e9 81       	ldd	r30, Y+1	; 0x01
    3510:	fa 81       	ldd	r31, Y+2	; 0x02
    3512:	96 89       	ldd	r25, Z+22	; 0x16
    3514:	80 91 ee 06 	lds	r24, 0x06EE
    3518:	89 17       	cp	r24, r25
    351a:	28 f4       	brcc	.+10     	; 0x3526 <vTaskResume+0x6a>
    351c:	e9 81       	ldd	r30, Y+1	; 0x01
    351e:	fa 81       	ldd	r31, Y+2	; 0x02
    3520:	86 89       	ldd	r24, Z+22	; 0x16
    3522:	80 93 ee 06 	sts	0x06EE, r24
    3526:	e9 81       	ldd	r30, Y+1	; 0x01
    3528:	fa 81       	ldd	r31, Y+2	; 0x02
    352a:	86 89       	ldd	r24, Z+22	; 0x16
    352c:	28 2f       	mov	r18, r24
    352e:	30 e0       	ldi	r19, 0x00	; 0
    3530:	c9 01       	movw	r24, r18
    3532:	88 0f       	add	r24, r24
    3534:	99 1f       	adc	r25, r25
    3536:	88 0f       	add	r24, r24
    3538:	99 1f       	adc	r25, r25
    353a:	88 0f       	add	r24, r24
    353c:	99 1f       	adc	r25, r25
    353e:	82 0f       	add	r24, r18
    3540:	93 1f       	adc	r25, r19
    3542:	ac 01       	movw	r20, r24
    3544:	47 50       	subi	r20, 0x07	; 7
    3546:	59 4f       	sbci	r21, 0xF9	; 249
    3548:	89 81       	ldd	r24, Y+1	; 0x01
    354a:	9a 81       	ldd	r25, Y+2	; 0x02
    354c:	9c 01       	movw	r18, r24
    354e:	2e 5f       	subi	r18, 0xFE	; 254
    3550:	3f 4f       	sbci	r19, 0xFF	; 255
    3552:	ca 01       	movw	r24, r20
    3554:	b9 01       	movw	r22, r18
    3556:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    355a:	e9 81       	ldd	r30, Y+1	; 0x01
    355c:	fa 81       	ldd	r31, Y+2	; 0x02
    355e:	96 89       	ldd	r25, Z+22	; 0x16
    3560:	e0 91 e8 06 	lds	r30, 0x06E8
    3564:	f0 91 e9 06 	lds	r31, 0x06E9
    3568:	86 89       	ldd	r24, Z+22	; 0x16
    356a:	98 17       	cp	r25, r24
    356c:	10 f0       	brcs	.+4      	; 0x3572 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    356e:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    3572:	0f 90       	pop	r0
    3574:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3576:	0f 90       	pop	r0
    3578:	0f 90       	pop	r0
    357a:	0f 90       	pop	r0
    357c:	0f 90       	pop	r0
    357e:	cf 91       	pop	r28
    3580:	df 91       	pop	r29
    3582:	08 95       	ret

00003584 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    3584:	df 93       	push	r29
    3586:	cf 93       	push	r28
    3588:	00 d0       	rcall	.+0      	; 0x358a <xTaskResumeFromISR+0x6>
    358a:	00 d0       	rcall	.+0      	; 0x358c <xTaskResumeFromISR+0x8>
    358c:	00 d0       	rcall	.+0      	; 0x358e <xTaskResumeFromISR+0xa>
    358e:	cd b7       	in	r28, 0x3d	; 61
    3590:	de b7       	in	r29, 0x3e	; 62
    3592:	9e 83       	std	Y+6, r25	; 0x06
    3594:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    3596:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    3598:	8d 81       	ldd	r24, Y+5	; 0x05
    359a:	9e 81       	ldd	r25, Y+6	; 0x06
    359c:	9b 83       	std	Y+3, r25	; 0x03
    359e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    35a0:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    35a2:	8a 81       	ldd	r24, Y+2	; 0x02
    35a4:	9b 81       	ldd	r25, Y+3	; 0x03
    35a6:	0e 94 2f 1a 	call	0x345e	; 0x345e <prvTaskIsTaskSuspended>
    35aa:	88 23       	and	r24, r24
    35ac:	09 f4       	brne	.+2      	; 0x35b0 <xTaskResumeFromISR+0x2c>
    35ae:	46 c0       	rjmp	.+140    	; 0x363c <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35b0:	80 91 f8 06 	lds	r24, 0x06F8
    35b4:	88 23       	and	r24, r24
    35b6:	c1 f5       	brne	.+112    	; 0x3628 <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    35b8:	ea 81       	ldd	r30, Y+2	; 0x02
    35ba:	fb 81       	ldd	r31, Y+3	; 0x03
    35bc:	96 89       	ldd	r25, Z+22	; 0x16
    35be:	e0 91 e8 06 	lds	r30, 0x06E8
    35c2:	f0 91 e9 06 	lds	r31, 0x06E9
    35c6:	86 89       	ldd	r24, Z+22	; 0x16
    35c8:	98 17       	cp	r25, r24
    35ca:	10 f0       	brcs	.+4      	; 0x35d0 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    35cc:	81 e0       	ldi	r24, 0x01	; 1
    35ce:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    35d0:	8a 81       	ldd	r24, Y+2	; 0x02
    35d2:	9b 81       	ldd	r25, Y+3	; 0x03
    35d4:	02 96       	adiw	r24, 0x02	; 2
    35d6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35da:	ea 81       	ldd	r30, Y+2	; 0x02
    35dc:	fb 81       	ldd	r31, Y+3	; 0x03
    35de:	96 89       	ldd	r25, Z+22	; 0x16
    35e0:	80 91 ee 06 	lds	r24, 0x06EE
    35e4:	89 17       	cp	r24, r25
    35e6:	28 f4       	brcc	.+10     	; 0x35f2 <xTaskResumeFromISR+0x6e>
    35e8:	ea 81       	ldd	r30, Y+2	; 0x02
    35ea:	fb 81       	ldd	r31, Y+3	; 0x03
    35ec:	86 89       	ldd	r24, Z+22	; 0x16
    35ee:	80 93 ee 06 	sts	0x06EE, r24
    35f2:	ea 81       	ldd	r30, Y+2	; 0x02
    35f4:	fb 81       	ldd	r31, Y+3	; 0x03
    35f6:	86 89       	ldd	r24, Z+22	; 0x16
    35f8:	28 2f       	mov	r18, r24
    35fa:	30 e0       	ldi	r19, 0x00	; 0
    35fc:	c9 01       	movw	r24, r18
    35fe:	88 0f       	add	r24, r24
    3600:	99 1f       	adc	r25, r25
    3602:	88 0f       	add	r24, r24
    3604:	99 1f       	adc	r25, r25
    3606:	88 0f       	add	r24, r24
    3608:	99 1f       	adc	r25, r25
    360a:	82 0f       	add	r24, r18
    360c:	93 1f       	adc	r25, r19
    360e:	ac 01       	movw	r20, r24
    3610:	47 50       	subi	r20, 0x07	; 7
    3612:	59 4f       	sbci	r21, 0xF9	; 249
    3614:	8a 81       	ldd	r24, Y+2	; 0x02
    3616:	9b 81       	ldd	r25, Y+3	; 0x03
    3618:	9c 01       	movw	r18, r24
    361a:	2e 5f       	subi	r18, 0xFE	; 254
    361c:	3f 4f       	sbci	r19, 0xFF	; 255
    361e:	ca 01       	movw	r24, r20
    3620:	b9 01       	movw	r22, r18
    3622:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    3626:	0a c0       	rjmp	.+20     	; 0x363c <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    3628:	8a 81       	ldd	r24, Y+2	; 0x02
    362a:	9b 81       	ldd	r25, Y+3	; 0x03
    362c:	9c 01       	movw	r18, r24
    362e:	24 5f       	subi	r18, 0xF4	; 244
    3630:	3f 4f       	sbci	r19, 0xFF	; 255
    3632:	83 e3       	ldi	r24, 0x33	; 51
    3634:	97 e0       	ldi	r25, 0x07	; 7
    3636:	b9 01       	movw	r22, r18
    3638:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    363c:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    363e:	26 96       	adiw	r28, 0x06	; 6
    3640:	0f b6       	in	r0, 0x3f	; 63
    3642:	f8 94       	cli
    3644:	de bf       	out	0x3e, r29	; 62
    3646:	0f be       	out	0x3f, r0	; 63
    3648:	cd bf       	out	0x3d, r28	; 61
    364a:	cf 91       	pop	r28
    364c:	df 91       	pop	r29
    364e:	08 95       	ret

00003650 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    3650:	ef 92       	push	r14
    3652:	ff 92       	push	r15
    3654:	0f 93       	push	r16
    3656:	df 93       	push	r29
    3658:	cf 93       	push	r28
    365a:	0f 92       	push	r0
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    3660:	8c e7       	ldi	r24, 0x7C	; 124
    3662:	9f e1       	ldi	r25, 0x1F	; 31
    3664:	20 e6       	ldi	r18, 0x60	; 96
    3666:	30 e0       	ldi	r19, 0x00	; 0
    3668:	e6 ef       	ldi	r30, 0xF6	; 246
    366a:	f6 e0       	ldi	r31, 0x06	; 6
    366c:	b9 01       	movw	r22, r18
    366e:	45 e5       	ldi	r20, 0x55	; 85
    3670:	50 e0       	ldi	r21, 0x00	; 0
    3672:	20 e0       	ldi	r18, 0x00	; 0
    3674:	30 e0       	ldi	r19, 0x00	; 0
    3676:	00 e0       	ldi	r16, 0x00	; 0
    3678:	7f 01       	movw	r14, r30
    367a:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>
    367e:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    3680:	89 81       	ldd	r24, Y+1	; 0x01
    3682:	81 30       	cpi	r24, 0x01	; 1
    3684:	81 f4       	brne	.+32     	; 0x36a6 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    3686:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    3688:	8f ef       	ldi	r24, 0xFF	; 255
    368a:	9f ef       	ldi	r25, 0xFF	; 255
    368c:	90 93 f5 06 	sts	0x06F5, r25
    3690:	80 93 f4 06 	sts	0x06F4, r24
		xSchedulerRunning = pdTRUE;
    3694:	81 e0       	ldi	r24, 0x01	; 1
    3696:	80 93 ef 06 	sts	0x06EF, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    369a:	10 92 ed 06 	sts	0x06ED, r1
    369e:	10 92 ec 06 	sts	0x06EC, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    36a2:	0e 94 c3 06 	call	0xd86	; 0xd86 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    36a6:	0f 90       	pop	r0
    36a8:	cf 91       	pop	r28
    36aa:	df 91       	pop	r29
    36ac:	0f 91       	pop	r16
    36ae:	ff 90       	pop	r15
    36b0:	ef 90       	pop	r14
    36b2:	08 95       	ret

000036b4 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    36b4:	df 93       	push	r29
    36b6:	cf 93       	push	r28
    36b8:	cd b7       	in	r28, 0x3d	; 61
    36ba:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    36bc:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    36be:	10 92 ef 06 	sts	0x06EF, r1
	vPortEndScheduler();
    36c2:	0e 94 f8 06 	call	0xdf0	; 0xdf0 <vPortEndScheduler>
}
    36c6:	cf 91       	pop	r28
    36c8:	df 91       	pop	r29
    36ca:	08 95       	ret

000036cc <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    36cc:	df 93       	push	r29
    36ce:	cf 93       	push	r28
    36d0:	cd b7       	in	r28, 0x3d	; 61
    36d2:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    36d4:	80 91 f8 06 	lds	r24, 0x06F8
    36d8:	8f 5f       	subi	r24, 0xFF	; 255
    36da:	80 93 f8 06 	sts	0x06F8, r24
}
    36de:	cf 91       	pop	r28
    36e0:	df 91       	pop	r29
    36e2:	08 95       	ret

000036e4 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    36e4:	df 93       	push	r29
    36e6:	cf 93       	push	r28
    36e8:	00 d0       	rcall	.+0      	; 0x36ea <xTaskResumeAll+0x6>
    36ea:	00 d0       	rcall	.+0      	; 0x36ec <xTaskResumeAll+0x8>
    36ec:	cd b7       	in	r28, 0x3d	; 61
    36ee:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    36f0:	1c 82       	std	Y+4, r1	; 0x04
    36f2:	1b 82       	std	Y+3, r1	; 0x03
BaseType_t xAlreadyYielded = pdFALSE;
    36f4:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    36f6:	0f b6       	in	r0, 0x3f	; 63
    36f8:	f8 94       	cli
    36fa:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    36fc:	80 91 f8 06 	lds	r24, 0x06F8
    3700:	81 50       	subi	r24, 0x01	; 1
    3702:	80 93 f8 06 	sts	0x06F8, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3706:	80 91 f8 06 	lds	r24, 0x06F8
    370a:	88 23       	and	r24, r24
    370c:	09 f0       	breq	.+2      	; 0x3710 <xTaskResumeAll+0x2c>
    370e:	73 c0       	rjmp	.+230    	; 0x37f6 <xTaskResumeAll+0x112>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3710:	80 91 eb 06 	lds	r24, 0x06EB
    3714:	88 23       	and	r24, r24
    3716:	09 f4       	brne	.+2      	; 0x371a <xTaskResumeAll+0x36>
    3718:	6e c0       	rjmp	.+220    	; 0x37f6 <xTaskResumeAll+0x112>
    371a:	45 c0       	rjmp	.+138    	; 0x37a6 <xTaskResumeAll+0xc2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    371c:	e0 91 38 07 	lds	r30, 0x0738
    3720:	f0 91 39 07 	lds	r31, 0x0739
    3724:	86 81       	ldd	r24, Z+6	; 0x06
    3726:	97 81       	ldd	r25, Z+7	; 0x07
    3728:	9c 83       	std	Y+4, r25	; 0x04
    372a:	8b 83       	std	Y+3, r24	; 0x03
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    372c:	8b 81       	ldd	r24, Y+3	; 0x03
    372e:	9c 81       	ldd	r25, Y+4	; 0x04
    3730:	0c 96       	adiw	r24, 0x0c	; 12
    3732:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3736:	8b 81       	ldd	r24, Y+3	; 0x03
    3738:	9c 81       	ldd	r25, Y+4	; 0x04
    373a:	02 96       	adiw	r24, 0x02	; 2
    373c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3740:	eb 81       	ldd	r30, Y+3	; 0x03
    3742:	fc 81       	ldd	r31, Y+4	; 0x04
    3744:	96 89       	ldd	r25, Z+22	; 0x16
    3746:	80 91 ee 06 	lds	r24, 0x06EE
    374a:	89 17       	cp	r24, r25
    374c:	28 f4       	brcc	.+10     	; 0x3758 <xTaskResumeAll+0x74>
    374e:	eb 81       	ldd	r30, Y+3	; 0x03
    3750:	fc 81       	ldd	r31, Y+4	; 0x04
    3752:	86 89       	ldd	r24, Z+22	; 0x16
    3754:	80 93 ee 06 	sts	0x06EE, r24
    3758:	eb 81       	ldd	r30, Y+3	; 0x03
    375a:	fc 81       	ldd	r31, Y+4	; 0x04
    375c:	86 89       	ldd	r24, Z+22	; 0x16
    375e:	28 2f       	mov	r18, r24
    3760:	30 e0       	ldi	r19, 0x00	; 0
    3762:	c9 01       	movw	r24, r18
    3764:	88 0f       	add	r24, r24
    3766:	99 1f       	adc	r25, r25
    3768:	88 0f       	add	r24, r24
    376a:	99 1f       	adc	r25, r25
    376c:	88 0f       	add	r24, r24
    376e:	99 1f       	adc	r25, r25
    3770:	82 0f       	add	r24, r18
    3772:	93 1f       	adc	r25, r19
    3774:	ac 01       	movw	r20, r24
    3776:	47 50       	subi	r20, 0x07	; 7
    3778:	59 4f       	sbci	r21, 0xF9	; 249
    377a:	8b 81       	ldd	r24, Y+3	; 0x03
    377c:	9c 81       	ldd	r25, Y+4	; 0x04
    377e:	9c 01       	movw	r18, r24
    3780:	2e 5f       	subi	r18, 0xFE	; 254
    3782:	3f 4f       	sbci	r19, 0xFF	; 255
    3784:	ca 01       	movw	r24, r20
    3786:	b9 01       	movw	r22, r18
    3788:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    378c:	eb 81       	ldd	r30, Y+3	; 0x03
    378e:	fc 81       	ldd	r31, Y+4	; 0x04
    3790:	96 89       	ldd	r25, Z+22	; 0x16
    3792:	e0 91 e8 06 	lds	r30, 0x06E8
    3796:	f0 91 e9 06 	lds	r31, 0x06E9
    379a:	86 89       	ldd	r24, Z+22	; 0x16
    379c:	98 17       	cp	r25, r24
    379e:	18 f0       	brcs	.+6      	; 0x37a6 <xTaskResumeAll+0xc2>
					{
						xYieldPending = pdTRUE;
    37a0:	81 e0       	ldi	r24, 0x01	; 1
    37a2:	80 93 f1 06 	sts	0x06F1, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    37a6:	80 91 33 07 	lds	r24, 0x0733
    37aa:	88 23       	and	r24, r24
    37ac:	09 f0       	breq	.+2      	; 0x37b0 <xTaskResumeAll+0xcc>
    37ae:	b6 cf       	rjmp	.-148    	; 0x371c <xTaskResumeAll+0x38>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    37b0:	8b 81       	ldd	r24, Y+3	; 0x03
    37b2:	9c 81       	ldd	r25, Y+4	; 0x04
    37b4:	00 97       	sbiw	r24, 0x00	; 0
    37b6:	11 f0       	breq	.+4      	; 0x37bc <xTaskResumeAll+0xd8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    37b8:	0e 94 0c 20 	call	0x4018	; 0x4018 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
    37bc:	80 91 f0 06 	lds	r24, 0x06F0
    37c0:	89 83       	std	Y+1, r24	; 0x01

					if( uxPendedCounts > ( UBaseType_t ) 0U )
    37c2:	89 81       	ldd	r24, Y+1	; 0x01
    37c4:	88 23       	and	r24, r24
    37c6:	79 f0       	breq	.+30     	; 0x37e6 <xTaskResumeAll+0x102>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    37c8:	0e 94 62 1c 	call	0x38c4	; 0x38c4 <xTaskIncrementTick>
    37cc:	88 23       	and	r24, r24
    37ce:	19 f0       	breq	.+6      	; 0x37d6 <xTaskResumeAll+0xf2>
							{
								xYieldPending = pdTRUE;
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	80 93 f1 06 	sts	0x06F1, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
    37d6:	89 81       	ldd	r24, Y+1	; 0x01
    37d8:	81 50       	subi	r24, 0x01	; 1
    37da:	89 83       	std	Y+1, r24	; 0x01
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
    37dc:	89 81       	ldd	r24, Y+1	; 0x01
    37de:	88 23       	and	r24, r24
    37e0:	99 f7       	brne	.-26     	; 0x37c8 <xTaskResumeAll+0xe4>

						uxPendedTicks = 0;
    37e2:	10 92 f0 06 	sts	0x06F0, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    37e6:	80 91 f1 06 	lds	r24, 0x06F1
    37ea:	88 23       	and	r24, r24
    37ec:	21 f0       	breq	.+8      	; 0x37f6 <xTaskResumeAll+0x112>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    37ee:	81 e0       	ldi	r24, 0x01	; 1
    37f0:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    37f2:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    37f6:	0f 90       	pop	r0
    37f8:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    37fa:	8a 81       	ldd	r24, Y+2	; 0x02
}
    37fc:	0f 90       	pop	r0
    37fe:	0f 90       	pop	r0
    3800:	0f 90       	pop	r0
    3802:	0f 90       	pop	r0
    3804:	cf 91       	pop	r28
    3806:	df 91       	pop	r29
    3808:	08 95       	ret

0000380a <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    380a:	df 93       	push	r29
    380c:	cf 93       	push	r28
    380e:	00 d0       	rcall	.+0      	; 0x3810 <xTaskGetTickCount+0x6>
    3810:	cd b7       	in	r28, 0x3d	; 61
    3812:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    3814:	0f b6       	in	r0, 0x3f	; 63
    3816:	f8 94       	cli
    3818:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    381a:	80 91 ec 06 	lds	r24, 0x06EC
    381e:	90 91 ed 06 	lds	r25, 0x06ED
    3822:	9a 83       	std	Y+2, r25	; 0x02
    3824:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    3826:	0f 90       	pop	r0
    3828:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    382a:	89 81       	ldd	r24, Y+1	; 0x01
    382c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    382e:	0f 90       	pop	r0
    3830:	0f 90       	pop	r0
    3832:	cf 91       	pop	r28
    3834:	df 91       	pop	r29
    3836:	08 95       	ret

00003838 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    3838:	df 93       	push	r29
    383a:	cf 93       	push	r28
    383c:	00 d0       	rcall	.+0      	; 0x383e <xTaskGetTickCountFromISR+0x6>
    383e:	0f 92       	push	r0
    3840:	cd b7       	in	r28, 0x3d	; 61
    3842:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    3844:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    3846:	80 91 ec 06 	lds	r24, 0x06EC
    384a:	90 91 ed 06 	lds	r25, 0x06ED
    384e:	9b 83       	std	Y+3, r25	; 0x03
    3850:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3852:	8a 81       	ldd	r24, Y+2	; 0x02
    3854:	9b 81       	ldd	r25, Y+3	; 0x03
}
    3856:	0f 90       	pop	r0
    3858:	0f 90       	pop	r0
    385a:	0f 90       	pop	r0
    385c:	cf 91       	pop	r28
    385e:	df 91       	pop	r29
    3860:	08 95       	ret

00003862 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    3862:	df 93       	push	r29
    3864:	cf 93       	push	r28
    3866:	cd b7       	in	r28, 0x3d	; 61
    3868:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    386a:	80 91 eb 06 	lds	r24, 0x06EB
}
    386e:	cf 91       	pop	r28
    3870:	df 91       	pop	r29
    3872:	08 95       	ret

00003874 <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    3874:	df 93       	push	r29
    3876:	cf 93       	push	r28
    3878:	00 d0       	rcall	.+0      	; 0x387a <pcTaskGetName+0x6>
    387a:	00 d0       	rcall	.+0      	; 0x387c <pcTaskGetName+0x8>
    387c:	00 d0       	rcall	.+0      	; 0x387e <pcTaskGetName+0xa>
    387e:	cd b7       	in	r28, 0x3d	; 61
    3880:	de b7       	in	r29, 0x3e	; 62
    3882:	9c 83       	std	Y+4, r25	; 0x04
    3884:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    3886:	8b 81       	ldd	r24, Y+3	; 0x03
    3888:	9c 81       	ldd	r25, Y+4	; 0x04
    388a:	00 97       	sbiw	r24, 0x00	; 0
    388c:	39 f4       	brne	.+14     	; 0x389c <pcTaskGetName+0x28>
    388e:	80 91 e8 06 	lds	r24, 0x06E8
    3892:	90 91 e9 06 	lds	r25, 0x06E9
    3896:	9e 83       	std	Y+6, r25	; 0x06
    3898:	8d 83       	std	Y+5, r24	; 0x05
    389a:	04 c0       	rjmp	.+8      	; 0x38a4 <pcTaskGetName+0x30>
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	9e 83       	std	Y+6, r25	; 0x06
    38a2:	8d 83       	std	Y+5, r24	; 0x05
    38a4:	8d 81       	ldd	r24, Y+5	; 0x05
    38a6:	9e 81       	ldd	r25, Y+6	; 0x06
    38a8:	9a 83       	std	Y+2, r25	; 0x02
    38aa:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
    38b0:	49 96       	adiw	r24, 0x19	; 25
}
    38b2:	26 96       	adiw	r28, 0x06	; 6
    38b4:	0f b6       	in	r0, 0x3f	; 63
    38b6:	f8 94       	cli
    38b8:	de bf       	out	0x3e, r29	; 62
    38ba:	0f be       	out	0x3f, r0	; 63
    38bc:	cd bf       	out	0x3d, r28	; 61
    38be:	cf 91       	pop	r28
    38c0:	df 91       	pop	r29
    38c2:	08 95       	ret

000038c4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    38c4:	df 93       	push	r29
    38c6:	cf 93       	push	r28
    38c8:	cd b7       	in	r28, 0x3d	; 61
    38ca:	de b7       	in	r29, 0x3e	; 62
    38cc:	29 97       	sbiw	r28, 0x09	; 9
    38ce:	0f b6       	in	r0, 0x3f	; 63
    38d0:	f8 94       	cli
    38d2:	de bf       	out	0x3e, r29	; 62
    38d4:	0f be       	out	0x3f, r0	; 63
    38d6:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    38d8:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    38da:	80 91 f8 06 	lds	r24, 0x06F8
    38de:	88 23       	and	r24, r24
    38e0:	09 f0       	breq	.+2      	; 0x38e4 <xTaskIncrementTick+0x20>
    38e2:	c0 c0       	rjmp	.+384    	; 0x3a64 <xTaskIncrementTick+0x1a0>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    38e4:	80 91 ec 06 	lds	r24, 0x06EC
    38e8:	90 91 ed 06 	lds	r25, 0x06ED
    38ec:	01 96       	adiw	r24, 0x01	; 1
    38ee:	9c 83       	std	Y+4, r25	; 0x04
    38f0:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    38f2:	8b 81       	ldd	r24, Y+3	; 0x03
    38f4:	9c 81       	ldd	r25, Y+4	; 0x04
    38f6:	90 93 ed 06 	sts	0x06ED, r25
    38fa:	80 93 ec 06 	sts	0x06EC, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    38fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3900:	9c 81       	ldd	r25, Y+4	; 0x04
    3902:	00 97       	sbiw	r24, 0x00	; 0
    3904:	d9 f4       	brne	.+54     	; 0x393c <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    3906:	80 91 2f 07 	lds	r24, 0x072F
    390a:	90 91 30 07 	lds	r25, 0x0730
    390e:	9a 83       	std	Y+2, r25	; 0x02
    3910:	89 83       	std	Y+1, r24	; 0x01
    3912:	80 91 31 07 	lds	r24, 0x0731
    3916:	90 91 32 07 	lds	r25, 0x0732
    391a:	90 93 30 07 	sts	0x0730, r25
    391e:	80 93 2f 07 	sts	0x072F, r24
    3922:	89 81       	ldd	r24, Y+1	; 0x01
    3924:	9a 81       	ldd	r25, Y+2	; 0x02
    3926:	90 93 32 07 	sts	0x0732, r25
    392a:	80 93 31 07 	sts	0x0731, r24
    392e:	80 91 f2 06 	lds	r24, 0x06F2
    3932:	8f 5f       	subi	r24, 0xFF	; 255
    3934:	80 93 f2 06 	sts	0x06F2, r24
    3938:	0e 94 0c 20 	call	0x4018	; 0x4018 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    393c:	20 91 f4 06 	lds	r18, 0x06F4
    3940:	30 91 f5 06 	lds	r19, 0x06F5
    3944:	8b 81       	ldd	r24, Y+3	; 0x03
    3946:	9c 81       	ldd	r25, Y+4	; 0x04
    3948:	82 17       	cp	r24, r18
    394a:	93 07       	cpc	r25, r19
    394c:	08 f4       	brcc	.+2      	; 0x3950 <xTaskIncrementTick+0x8c>
    394e:	71 c0       	rjmp	.+226    	; 0x3a32 <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3950:	e0 91 2f 07 	lds	r30, 0x072F
    3954:	f0 91 30 07 	lds	r31, 0x0730
    3958:	80 81       	ld	r24, Z
    395a:	88 23       	and	r24, r24
    395c:	39 f4       	brne	.+14     	; 0x396c <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    395e:	8f ef       	ldi	r24, 0xFF	; 255
    3960:	9f ef       	ldi	r25, 0xFF	; 255
    3962:	90 93 f5 06 	sts	0x06F5, r25
    3966:	80 93 f4 06 	sts	0x06F4, r24
    396a:	63 c0       	rjmp	.+198    	; 0x3a32 <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    396c:	e0 91 2f 07 	lds	r30, 0x072F
    3970:	f0 91 30 07 	lds	r31, 0x0730
    3974:	05 80       	ldd	r0, Z+5	; 0x05
    3976:	f6 81       	ldd	r31, Z+6	; 0x06
    3978:	e0 2d       	mov	r30, r0
    397a:	86 81       	ldd	r24, Z+6	; 0x06
    397c:	97 81       	ldd	r25, Z+7	; 0x07
    397e:	99 87       	std	Y+9, r25	; 0x09
    3980:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    3982:	e8 85       	ldd	r30, Y+8	; 0x08
    3984:	f9 85       	ldd	r31, Y+9	; 0x09
    3986:	82 81       	ldd	r24, Z+2	; 0x02
    3988:	93 81       	ldd	r25, Z+3	; 0x03
    398a:	9f 83       	std	Y+7, r25	; 0x07
    398c:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    398e:	2b 81       	ldd	r18, Y+3	; 0x03
    3990:	3c 81       	ldd	r19, Y+4	; 0x04
    3992:	8e 81       	ldd	r24, Y+6	; 0x06
    3994:	9f 81       	ldd	r25, Y+7	; 0x07
    3996:	28 17       	cp	r18, r24
    3998:	39 07       	cpc	r19, r25
    399a:	38 f4       	brcc	.+14     	; 0x39aa <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    399c:	8e 81       	ldd	r24, Y+6	; 0x06
    399e:	9f 81       	ldd	r25, Y+7	; 0x07
    39a0:	90 93 f5 06 	sts	0x06F5, r25
    39a4:	80 93 f4 06 	sts	0x06F4, r24
    39a8:	44 c0       	rjmp	.+136    	; 0x3a32 <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    39aa:	88 85       	ldd	r24, Y+8	; 0x08
    39ac:	99 85       	ldd	r25, Y+9	; 0x09
    39ae:	02 96       	adiw	r24, 0x02	; 2
    39b0:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    39b4:	e8 85       	ldd	r30, Y+8	; 0x08
    39b6:	f9 85       	ldd	r31, Y+9	; 0x09
    39b8:	84 89       	ldd	r24, Z+20	; 0x14
    39ba:	95 89       	ldd	r25, Z+21	; 0x15
    39bc:	00 97       	sbiw	r24, 0x00	; 0
    39be:	29 f0       	breq	.+10     	; 0x39ca <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    39c0:	88 85       	ldd	r24, Y+8	; 0x08
    39c2:	99 85       	ldd	r25, Y+9	; 0x09
    39c4:	0c 96       	adiw	r24, 0x0c	; 12
    39c6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    39ca:	e8 85       	ldd	r30, Y+8	; 0x08
    39cc:	f9 85       	ldd	r31, Y+9	; 0x09
    39ce:	96 89       	ldd	r25, Z+22	; 0x16
    39d0:	80 91 ee 06 	lds	r24, 0x06EE
    39d4:	89 17       	cp	r24, r25
    39d6:	28 f4       	brcc	.+10     	; 0x39e2 <xTaskIncrementTick+0x11e>
    39d8:	e8 85       	ldd	r30, Y+8	; 0x08
    39da:	f9 85       	ldd	r31, Y+9	; 0x09
    39dc:	86 89       	ldd	r24, Z+22	; 0x16
    39de:	80 93 ee 06 	sts	0x06EE, r24
    39e2:	e8 85       	ldd	r30, Y+8	; 0x08
    39e4:	f9 85       	ldd	r31, Y+9	; 0x09
    39e6:	86 89       	ldd	r24, Z+22	; 0x16
    39e8:	28 2f       	mov	r18, r24
    39ea:	30 e0       	ldi	r19, 0x00	; 0
    39ec:	c9 01       	movw	r24, r18
    39ee:	88 0f       	add	r24, r24
    39f0:	99 1f       	adc	r25, r25
    39f2:	88 0f       	add	r24, r24
    39f4:	99 1f       	adc	r25, r25
    39f6:	88 0f       	add	r24, r24
    39f8:	99 1f       	adc	r25, r25
    39fa:	82 0f       	add	r24, r18
    39fc:	93 1f       	adc	r25, r19
    39fe:	ac 01       	movw	r20, r24
    3a00:	47 50       	subi	r20, 0x07	; 7
    3a02:	59 4f       	sbci	r21, 0xF9	; 249
    3a04:	88 85       	ldd	r24, Y+8	; 0x08
    3a06:	99 85       	ldd	r25, Y+9	; 0x09
    3a08:	9c 01       	movw	r18, r24
    3a0a:	2e 5f       	subi	r18, 0xFE	; 254
    3a0c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a0e:	ca 01       	movw	r24, r20
    3a10:	b9 01       	movw	r22, r18
    3a12:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3a16:	e8 85       	ldd	r30, Y+8	; 0x08
    3a18:	f9 85       	ldd	r31, Y+9	; 0x09
    3a1a:	96 89       	ldd	r25, Z+22	; 0x16
    3a1c:	e0 91 e8 06 	lds	r30, 0x06E8
    3a20:	f0 91 e9 06 	lds	r31, 0x06E9
    3a24:	86 89       	ldd	r24, Z+22	; 0x16
    3a26:	98 17       	cp	r25, r24
    3a28:	08 f4       	brcc	.+2      	; 0x3a2c <xTaskIncrementTick+0x168>
    3a2a:	92 cf       	rjmp	.-220    	; 0x3950 <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    3a2c:	81 e0       	ldi	r24, 0x01	; 1
    3a2e:	8d 83       	std	Y+5, r24	; 0x05
    3a30:	8f cf       	rjmp	.-226    	; 0x3950 <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    3a32:	e0 91 e8 06 	lds	r30, 0x06E8
    3a36:	f0 91 e9 06 	lds	r31, 0x06E9
    3a3a:	86 89       	ldd	r24, Z+22	; 0x16
    3a3c:	28 2f       	mov	r18, r24
    3a3e:	30 e0       	ldi	r19, 0x00	; 0
    3a40:	c9 01       	movw	r24, r18
    3a42:	88 0f       	add	r24, r24
    3a44:	99 1f       	adc	r25, r25
    3a46:	88 0f       	add	r24, r24
    3a48:	99 1f       	adc	r25, r25
    3a4a:	88 0f       	add	r24, r24
    3a4c:	99 1f       	adc	r25, r25
    3a4e:	82 0f       	add	r24, r18
    3a50:	93 1f       	adc	r25, r19
    3a52:	fc 01       	movw	r30, r24
    3a54:	e7 50       	subi	r30, 0x07	; 7
    3a56:	f9 4f       	sbci	r31, 0xF9	; 249
    3a58:	80 81       	ld	r24, Z
    3a5a:	82 30       	cpi	r24, 0x02	; 2
    3a5c:	40 f0       	brcs	.+16     	; 0x3a6e <xTaskIncrementTick+0x1aa>
			{
				xSwitchRequired = pdTRUE;
    3a5e:	81 e0       	ldi	r24, 0x01	; 1
    3a60:	8d 83       	std	Y+5, r24	; 0x05
    3a62:	05 c0       	rjmp	.+10     	; 0x3a6e <xTaskIncrementTick+0x1aa>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    3a64:	80 91 f0 06 	lds	r24, 0x06F0
    3a68:	8f 5f       	subi	r24, 0xFF	; 255
    3a6a:	80 93 f0 06 	sts	0x06F0, r24
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    3a6e:	80 91 f1 06 	lds	r24, 0x06F1
    3a72:	88 23       	and	r24, r24
    3a74:	11 f0       	breq	.+4      	; 0x3a7a <xTaskIncrementTick+0x1b6>
		{
			xSwitchRequired = pdTRUE;
    3a76:	81 e0       	ldi	r24, 0x01	; 1
    3a78:	8d 83       	std	Y+5, r24	; 0x05
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
    3a7a:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3a7c:	29 96       	adiw	r28, 0x09	; 9
    3a7e:	0f b6       	in	r0, 0x3f	; 63
    3a80:	f8 94       	cli
    3a82:	de bf       	out	0x3e, r29	; 62
    3a84:	0f be       	out	0x3f, r0	; 63
    3a86:	cd bf       	out	0x3d, r28	; 61
    3a88:	cf 91       	pop	r28
    3a8a:	df 91       	pop	r29
    3a8c:	08 95       	ret

00003a8e <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3a8e:	df 93       	push	r29
    3a90:	cf 93       	push	r28
    3a92:	00 d0       	rcall	.+0      	; 0x3a94 <vTaskSwitchContext+0x6>
    3a94:	0f 92       	push	r0
    3a96:	cd b7       	in	r28, 0x3d	; 61
    3a98:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3a9a:	80 91 f8 06 	lds	r24, 0x06F8
    3a9e:	88 23       	and	r24, r24
    3aa0:	21 f0       	breq	.+8      	; 0x3aaa <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3aa2:	81 e0       	ldi	r24, 0x01	; 1
    3aa4:	80 93 f1 06 	sts	0x06F1, r24
    3aa8:	59 c0       	rjmp	.+178    	; 0x3b5c <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3aaa:	10 92 f1 06 	sts	0x06F1, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3aae:	80 91 ee 06 	lds	r24, 0x06EE
    3ab2:	8b 83       	std	Y+3, r24	; 0x03
    3ab4:	03 c0       	rjmp	.+6      	; 0x3abc <vTaskSwitchContext+0x2e>
    3ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ab8:	81 50       	subi	r24, 0x01	; 1
    3aba:	8b 83       	std	Y+3, r24	; 0x03
    3abc:	8b 81       	ldd	r24, Y+3	; 0x03
    3abe:	28 2f       	mov	r18, r24
    3ac0:	30 e0       	ldi	r19, 0x00	; 0
    3ac2:	c9 01       	movw	r24, r18
    3ac4:	88 0f       	add	r24, r24
    3ac6:	99 1f       	adc	r25, r25
    3ac8:	88 0f       	add	r24, r24
    3aca:	99 1f       	adc	r25, r25
    3acc:	88 0f       	add	r24, r24
    3ace:	99 1f       	adc	r25, r25
    3ad0:	82 0f       	add	r24, r18
    3ad2:	93 1f       	adc	r25, r19
    3ad4:	fc 01       	movw	r30, r24
    3ad6:	e7 50       	subi	r30, 0x07	; 7
    3ad8:	f9 4f       	sbci	r31, 0xF9	; 249
    3ada:	80 81       	ld	r24, Z
    3adc:	88 23       	and	r24, r24
    3ade:	59 f3       	breq	.-42     	; 0x3ab6 <vTaskSwitchContext+0x28>
    3ae0:	8b 81       	ldd	r24, Y+3	; 0x03
    3ae2:	28 2f       	mov	r18, r24
    3ae4:	30 e0       	ldi	r19, 0x00	; 0
    3ae6:	c9 01       	movw	r24, r18
    3ae8:	88 0f       	add	r24, r24
    3aea:	99 1f       	adc	r25, r25
    3aec:	88 0f       	add	r24, r24
    3aee:	99 1f       	adc	r25, r25
    3af0:	88 0f       	add	r24, r24
    3af2:	99 1f       	adc	r25, r25
    3af4:	82 0f       	add	r24, r18
    3af6:	93 1f       	adc	r25, r19
    3af8:	87 50       	subi	r24, 0x07	; 7
    3afa:	99 4f       	sbci	r25, 0xF9	; 249
    3afc:	9a 83       	std	Y+2, r25	; 0x02
    3afe:	89 83       	std	Y+1, r24	; 0x01
    3b00:	e9 81       	ldd	r30, Y+1	; 0x01
    3b02:	fa 81       	ldd	r31, Y+2	; 0x02
    3b04:	01 80       	ldd	r0, Z+1	; 0x01
    3b06:	f2 81       	ldd	r31, Z+2	; 0x02
    3b08:	e0 2d       	mov	r30, r0
    3b0a:	82 81       	ldd	r24, Z+2	; 0x02
    3b0c:	93 81       	ldd	r25, Z+3	; 0x03
    3b0e:	e9 81       	ldd	r30, Y+1	; 0x01
    3b10:	fa 81       	ldd	r31, Y+2	; 0x02
    3b12:	92 83       	std	Z+2, r25	; 0x02
    3b14:	81 83       	std	Z+1, r24	; 0x01
    3b16:	e9 81       	ldd	r30, Y+1	; 0x01
    3b18:	fa 81       	ldd	r31, Y+2	; 0x02
    3b1a:	21 81       	ldd	r18, Z+1	; 0x01
    3b1c:	32 81       	ldd	r19, Z+2	; 0x02
    3b1e:	89 81       	ldd	r24, Y+1	; 0x01
    3b20:	9a 81       	ldd	r25, Y+2	; 0x02
    3b22:	03 96       	adiw	r24, 0x03	; 3
    3b24:	28 17       	cp	r18, r24
    3b26:	39 07       	cpc	r19, r25
    3b28:	59 f4       	brne	.+22     	; 0x3b40 <vTaskSwitchContext+0xb2>
    3b2a:	e9 81       	ldd	r30, Y+1	; 0x01
    3b2c:	fa 81       	ldd	r31, Y+2	; 0x02
    3b2e:	01 80       	ldd	r0, Z+1	; 0x01
    3b30:	f2 81       	ldd	r31, Z+2	; 0x02
    3b32:	e0 2d       	mov	r30, r0
    3b34:	82 81       	ldd	r24, Z+2	; 0x02
    3b36:	93 81       	ldd	r25, Z+3	; 0x03
    3b38:	e9 81       	ldd	r30, Y+1	; 0x01
    3b3a:	fa 81       	ldd	r31, Y+2	; 0x02
    3b3c:	92 83       	std	Z+2, r25	; 0x02
    3b3e:	81 83       	std	Z+1, r24	; 0x01
    3b40:	e9 81       	ldd	r30, Y+1	; 0x01
    3b42:	fa 81       	ldd	r31, Y+2	; 0x02
    3b44:	01 80       	ldd	r0, Z+1	; 0x01
    3b46:	f2 81       	ldd	r31, Z+2	; 0x02
    3b48:	e0 2d       	mov	r30, r0
    3b4a:	86 81       	ldd	r24, Z+6	; 0x06
    3b4c:	97 81       	ldd	r25, Z+7	; 0x07
    3b4e:	90 93 e9 06 	sts	0x06E9, r25
    3b52:	80 93 e8 06 	sts	0x06E8, r24
    3b56:	8b 81       	ldd	r24, Y+3	; 0x03
    3b58:	80 93 ee 06 	sts	0x06EE, r24
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3b5c:	0f 90       	pop	r0
    3b5e:	0f 90       	pop	r0
    3b60:	0f 90       	pop	r0
    3b62:	cf 91       	pop	r28
    3b64:	df 91       	pop	r29
    3b66:	08 95       	ret

00003b68 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3b68:	df 93       	push	r29
    3b6a:	cf 93       	push	r28
    3b6c:	00 d0       	rcall	.+0      	; 0x3b6e <vTaskPlaceOnEventList+0x6>
    3b6e:	00 d0       	rcall	.+0      	; 0x3b70 <vTaskPlaceOnEventList+0x8>
    3b70:	cd b7       	in	r28, 0x3d	; 61
    3b72:	de b7       	in	r29, 0x3e	; 62
    3b74:	9a 83       	std	Y+2, r25	; 0x02
    3b76:	89 83       	std	Y+1, r24	; 0x01
    3b78:	7c 83       	std	Y+4, r23	; 0x04
    3b7a:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b7c:	80 91 e8 06 	lds	r24, 0x06E8
    3b80:	90 91 e9 06 	lds	r25, 0x06E9
    3b84:	9c 01       	movw	r18, r24
    3b86:	24 5f       	subi	r18, 0xF4	; 244
    3b88:	3f 4f       	sbci	r19, 0xFF	; 255
    3b8a:	89 81       	ldd	r24, Y+1	; 0x01
    3b8c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b8e:	b9 01       	movw	r22, r18
    3b90:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3b94:	8b 81       	ldd	r24, Y+3	; 0x03
    3b96:	9c 81       	ldd	r25, Y+4	; 0x04
    3b98:	61 e0       	ldi	r22, 0x01	; 1
    3b9a:	0e 94 d5 25 	call	0x4baa	; 0x4baa <prvAddCurrentTaskToDelayedList>
}
    3b9e:	0f 90       	pop	r0
    3ba0:	0f 90       	pop	r0
    3ba2:	0f 90       	pop	r0
    3ba4:	0f 90       	pop	r0
    3ba6:	cf 91       	pop	r28
    3ba8:	df 91       	pop	r29
    3baa:	08 95       	ret

00003bac <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3bac:	df 93       	push	r29
    3bae:	cf 93       	push	r28
    3bb0:	00 d0       	rcall	.+0      	; 0x3bb2 <vTaskPlaceOnUnorderedEventList+0x6>
    3bb2:	00 d0       	rcall	.+0      	; 0x3bb4 <vTaskPlaceOnUnorderedEventList+0x8>
    3bb4:	00 d0       	rcall	.+0      	; 0x3bb6 <vTaskPlaceOnUnorderedEventList+0xa>
    3bb6:	cd b7       	in	r28, 0x3d	; 61
    3bb8:	de b7       	in	r29, 0x3e	; 62
    3bba:	9a 83       	std	Y+2, r25	; 0x02
    3bbc:	89 83       	std	Y+1, r24	; 0x01
    3bbe:	7c 83       	std	Y+4, r23	; 0x04
    3bc0:	6b 83       	std	Y+3, r22	; 0x03
    3bc2:	5e 83       	std	Y+6, r21	; 0x06
    3bc4:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3bc6:	e0 91 e8 06 	lds	r30, 0x06E8
    3bca:	f0 91 e9 06 	lds	r31, 0x06E9
    3bce:	8b 81       	ldd	r24, Y+3	; 0x03
    3bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    3bd2:	90 68       	ori	r25, 0x80	; 128
    3bd4:	95 87       	std	Z+13, r25	; 0x0d
    3bd6:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3bd8:	80 91 e8 06 	lds	r24, 0x06E8
    3bdc:	90 91 e9 06 	lds	r25, 0x06E9
    3be0:	9c 01       	movw	r18, r24
    3be2:	24 5f       	subi	r18, 0xF4	; 244
    3be4:	3f 4f       	sbci	r19, 0xFF	; 255
    3be6:	89 81       	ldd	r24, Y+1	; 0x01
    3be8:	9a 81       	ldd	r25, Y+2	; 0x02
    3bea:	b9 01       	movw	r22, r18
    3bec:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3bf0:	8d 81       	ldd	r24, Y+5	; 0x05
    3bf2:	9e 81       	ldd	r25, Y+6	; 0x06
    3bf4:	61 e0       	ldi	r22, 0x01	; 1
    3bf6:	0e 94 d5 25 	call	0x4baa	; 0x4baa <prvAddCurrentTaskToDelayedList>
}
    3bfa:	26 96       	adiw	r28, 0x06	; 6
    3bfc:	0f b6       	in	r0, 0x3f	; 63
    3bfe:	f8 94       	cli
    3c00:	de bf       	out	0x3e, r29	; 62
    3c02:	0f be       	out	0x3f, r0	; 63
    3c04:	cd bf       	out	0x3d, r28	; 61
    3c06:	cf 91       	pop	r28
    3c08:	df 91       	pop	r29
    3c0a:	08 95       	ret

00003c0c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3c0c:	df 93       	push	r29
    3c0e:	cf 93       	push	r28
    3c10:	00 d0       	rcall	.+0      	; 0x3c12 <xTaskRemoveFromEventList+0x6>
    3c12:	00 d0       	rcall	.+0      	; 0x3c14 <xTaskRemoveFromEventList+0x8>
    3c14:	0f 92       	push	r0
    3c16:	cd b7       	in	r28, 0x3d	; 61
    3c18:	de b7       	in	r29, 0x3e	; 62
    3c1a:	9d 83       	std	Y+5, r25	; 0x05
    3c1c:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3c1e:	ec 81       	ldd	r30, Y+4	; 0x04
    3c20:	fd 81       	ldd	r31, Y+5	; 0x05
    3c22:	05 80       	ldd	r0, Z+5	; 0x05
    3c24:	f6 81       	ldd	r31, Z+6	; 0x06
    3c26:	e0 2d       	mov	r30, r0
    3c28:	86 81       	ldd	r24, Z+6	; 0x06
    3c2a:	97 81       	ldd	r25, Z+7	; 0x07
    3c2c:	9b 83       	std	Y+3, r25	; 0x03
    3c2e:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3c30:	8a 81       	ldd	r24, Y+2	; 0x02
    3c32:	9b 81       	ldd	r25, Y+3	; 0x03
    3c34:	0c 96       	adiw	r24, 0x0c	; 12
    3c36:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3c3a:	80 91 f8 06 	lds	r24, 0x06F8
    3c3e:	88 23       	and	r24, r24
    3c40:	61 f5       	brne	.+88     	; 0x3c9a <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3c42:	8a 81       	ldd	r24, Y+2	; 0x02
    3c44:	9b 81       	ldd	r25, Y+3	; 0x03
    3c46:	02 96       	adiw	r24, 0x02	; 2
    3c48:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3c4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c50:	96 89       	ldd	r25, Z+22	; 0x16
    3c52:	80 91 ee 06 	lds	r24, 0x06EE
    3c56:	89 17       	cp	r24, r25
    3c58:	28 f4       	brcc	.+10     	; 0x3c64 <xTaskRemoveFromEventList+0x58>
    3c5a:	ea 81       	ldd	r30, Y+2	; 0x02
    3c5c:	fb 81       	ldd	r31, Y+3	; 0x03
    3c5e:	86 89       	ldd	r24, Z+22	; 0x16
    3c60:	80 93 ee 06 	sts	0x06EE, r24
    3c64:	ea 81       	ldd	r30, Y+2	; 0x02
    3c66:	fb 81       	ldd	r31, Y+3	; 0x03
    3c68:	86 89       	ldd	r24, Z+22	; 0x16
    3c6a:	28 2f       	mov	r18, r24
    3c6c:	30 e0       	ldi	r19, 0x00	; 0
    3c6e:	c9 01       	movw	r24, r18
    3c70:	88 0f       	add	r24, r24
    3c72:	99 1f       	adc	r25, r25
    3c74:	88 0f       	add	r24, r24
    3c76:	99 1f       	adc	r25, r25
    3c78:	88 0f       	add	r24, r24
    3c7a:	99 1f       	adc	r25, r25
    3c7c:	82 0f       	add	r24, r18
    3c7e:	93 1f       	adc	r25, r19
    3c80:	ac 01       	movw	r20, r24
    3c82:	47 50       	subi	r20, 0x07	; 7
    3c84:	59 4f       	sbci	r21, 0xF9	; 249
    3c86:	8a 81       	ldd	r24, Y+2	; 0x02
    3c88:	9b 81       	ldd	r25, Y+3	; 0x03
    3c8a:	9c 01       	movw	r18, r24
    3c8c:	2e 5f       	subi	r18, 0xFE	; 254
    3c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c90:	ca 01       	movw	r24, r20
    3c92:	b9 01       	movw	r22, r18
    3c94:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    3c98:	0a c0       	rjmp	.+20     	; 0x3cae <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c9e:	9c 01       	movw	r18, r24
    3ca0:	24 5f       	subi	r18, 0xF4	; 244
    3ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ca4:	83 e3       	ldi	r24, 0x33	; 51
    3ca6:	97 e0       	ldi	r25, 0x07	; 7
    3ca8:	b9 01       	movw	r22, r18
    3caa:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3cae:	ea 81       	ldd	r30, Y+2	; 0x02
    3cb0:	fb 81       	ldd	r31, Y+3	; 0x03
    3cb2:	96 89       	ldd	r25, Z+22	; 0x16
    3cb4:	e0 91 e8 06 	lds	r30, 0x06E8
    3cb8:	f0 91 e9 06 	lds	r31, 0x06E9
    3cbc:	86 89       	ldd	r24, Z+22	; 0x16
    3cbe:	89 17       	cp	r24, r25
    3cc0:	30 f4       	brcc	.+12     	; 0x3cce <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3cc2:	81 e0       	ldi	r24, 0x01	; 1
    3cc4:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3cc6:	81 e0       	ldi	r24, 0x01	; 1
    3cc8:	80 93 f1 06 	sts	0x06F1, r24
    3ccc:	01 c0       	rjmp	.+2      	; 0x3cd0 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3cce:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3cd0:	89 81       	ldd	r24, Y+1	; 0x01
}
    3cd2:	0f 90       	pop	r0
    3cd4:	0f 90       	pop	r0
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	cf 91       	pop	r28
    3cde:	df 91       	pop	r29
    3ce0:	08 95       	ret

00003ce2 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3ce2:	df 93       	push	r29
    3ce4:	cf 93       	push	r28
    3ce6:	00 d0       	rcall	.+0      	; 0x3ce8 <vTaskRemoveFromUnorderedEventList+0x6>
    3ce8:	00 d0       	rcall	.+0      	; 0x3cea <vTaskRemoveFromUnorderedEventList+0x8>
    3cea:	00 d0       	rcall	.+0      	; 0x3cec <vTaskRemoveFromUnorderedEventList+0xa>
    3cec:	cd b7       	in	r28, 0x3d	; 61
    3cee:	de b7       	in	r29, 0x3e	; 62
    3cf0:	9c 83       	std	Y+4, r25	; 0x04
    3cf2:	8b 83       	std	Y+3, r24	; 0x03
    3cf4:	7e 83       	std	Y+6, r23	; 0x06
    3cf6:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3cf8:	8d 81       	ldd	r24, Y+5	; 0x05
    3cfa:	9e 81       	ldd	r25, Y+6	; 0x06
    3cfc:	90 68       	ori	r25, 0x80	; 128
    3cfe:	eb 81       	ldd	r30, Y+3	; 0x03
    3d00:	fc 81       	ldd	r31, Y+4	; 0x04
    3d02:	91 83       	std	Z+1, r25	; 0x01
    3d04:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3d06:	eb 81       	ldd	r30, Y+3	; 0x03
    3d08:	fc 81       	ldd	r31, Y+4	; 0x04
    3d0a:	86 81       	ldd	r24, Z+6	; 0x06
    3d0c:	97 81       	ldd	r25, Z+7	; 0x07
    3d0e:	9a 83       	std	Y+2, r25	; 0x02
    3d10:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3d12:	8b 81       	ldd	r24, Y+3	; 0x03
    3d14:	9c 81       	ldd	r25, Y+4	; 0x04
    3d16:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3d1a:	89 81       	ldd	r24, Y+1	; 0x01
    3d1c:	9a 81       	ldd	r25, Y+2	; 0x02
    3d1e:	02 96       	adiw	r24, 0x02	; 2
    3d20:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3d24:	e9 81       	ldd	r30, Y+1	; 0x01
    3d26:	fa 81       	ldd	r31, Y+2	; 0x02
    3d28:	96 89       	ldd	r25, Z+22	; 0x16
    3d2a:	80 91 ee 06 	lds	r24, 0x06EE
    3d2e:	89 17       	cp	r24, r25
    3d30:	28 f4       	brcc	.+10     	; 0x3d3c <vTaskRemoveFromUnorderedEventList+0x5a>
    3d32:	e9 81       	ldd	r30, Y+1	; 0x01
    3d34:	fa 81       	ldd	r31, Y+2	; 0x02
    3d36:	86 89       	ldd	r24, Z+22	; 0x16
    3d38:	80 93 ee 06 	sts	0x06EE, r24
    3d3c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d3e:	fa 81       	ldd	r31, Y+2	; 0x02
    3d40:	86 89       	ldd	r24, Z+22	; 0x16
    3d42:	28 2f       	mov	r18, r24
    3d44:	30 e0       	ldi	r19, 0x00	; 0
    3d46:	c9 01       	movw	r24, r18
    3d48:	88 0f       	add	r24, r24
    3d4a:	99 1f       	adc	r25, r25
    3d4c:	88 0f       	add	r24, r24
    3d4e:	99 1f       	adc	r25, r25
    3d50:	88 0f       	add	r24, r24
    3d52:	99 1f       	adc	r25, r25
    3d54:	82 0f       	add	r24, r18
    3d56:	93 1f       	adc	r25, r19
    3d58:	ac 01       	movw	r20, r24
    3d5a:	47 50       	subi	r20, 0x07	; 7
    3d5c:	59 4f       	sbci	r21, 0xF9	; 249
    3d5e:	89 81       	ldd	r24, Y+1	; 0x01
    3d60:	9a 81       	ldd	r25, Y+2	; 0x02
    3d62:	9c 01       	movw	r18, r24
    3d64:	2e 5f       	subi	r18, 0xFE	; 254
    3d66:	3f 4f       	sbci	r19, 0xFF	; 255
    3d68:	ca 01       	movw	r24, r20
    3d6a:	b9 01       	movw	r22, r18
    3d6c:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3d70:	e9 81       	ldd	r30, Y+1	; 0x01
    3d72:	fa 81       	ldd	r31, Y+2	; 0x02
    3d74:	96 89       	ldd	r25, Z+22	; 0x16
    3d76:	e0 91 e8 06 	lds	r30, 0x06E8
    3d7a:	f0 91 e9 06 	lds	r31, 0x06E9
    3d7e:	86 89       	ldd	r24, Z+22	; 0x16
    3d80:	89 17       	cp	r24, r25
    3d82:	18 f4       	brcc	.+6      	; 0x3d8a <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3d84:	81 e0       	ldi	r24, 0x01	; 1
    3d86:	80 93 f1 06 	sts	0x06F1, r24
	}
}
    3d8a:	26 96       	adiw	r28, 0x06	; 6
    3d8c:	0f b6       	in	r0, 0x3f	; 63
    3d8e:	f8 94       	cli
    3d90:	de bf       	out	0x3e, r29	; 62
    3d92:	0f be       	out	0x3f, r0	; 63
    3d94:	cd bf       	out	0x3d, r28	; 61
    3d96:	cf 91       	pop	r28
    3d98:	df 91       	pop	r29
    3d9a:	08 95       	ret

00003d9c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3d9c:	df 93       	push	r29
    3d9e:	cf 93       	push	r28
    3da0:	00 d0       	rcall	.+0      	; 0x3da2 <vTaskSetTimeOutState+0x6>
    3da2:	cd b7       	in	r28, 0x3d	; 61
    3da4:	de b7       	in	r29, 0x3e	; 62
    3da6:	9a 83       	std	Y+2, r25	; 0x02
    3da8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3daa:	0f b6       	in	r0, 0x3f	; 63
    3dac:	f8 94       	cli
    3dae:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3db0:	80 91 f2 06 	lds	r24, 0x06F2
    3db4:	e9 81       	ldd	r30, Y+1	; 0x01
    3db6:	fa 81       	ldd	r31, Y+2	; 0x02
    3db8:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3dba:	80 91 ec 06 	lds	r24, 0x06EC
    3dbe:	90 91 ed 06 	lds	r25, 0x06ED
    3dc2:	e9 81       	ldd	r30, Y+1	; 0x01
    3dc4:	fa 81       	ldd	r31, Y+2	; 0x02
    3dc6:	92 83       	std	Z+2, r25	; 0x02
    3dc8:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3dca:	0f 90       	pop	r0
    3dcc:	0f be       	out	0x3f, r0	; 63
}
    3dce:	0f 90       	pop	r0
    3dd0:	0f 90       	pop	r0
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	08 95       	ret

00003dd8 <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3dd8:	df 93       	push	r29
    3dda:	cf 93       	push	r28
    3ddc:	00 d0       	rcall	.+0      	; 0x3dde <vTaskInternalSetTimeOutState+0x6>
    3dde:	cd b7       	in	r28, 0x3d	; 61
    3de0:	de b7       	in	r29, 0x3e	; 62
    3de2:	9a 83       	std	Y+2, r25	; 0x02
    3de4:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3de6:	80 91 f2 06 	lds	r24, 0x06F2
    3dea:	e9 81       	ldd	r30, Y+1	; 0x01
    3dec:	fa 81       	ldd	r31, Y+2	; 0x02
    3dee:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3df0:	80 91 ec 06 	lds	r24, 0x06EC
    3df4:	90 91 ed 06 	lds	r25, 0x06ED
    3df8:	e9 81       	ldd	r30, Y+1	; 0x01
    3dfa:	fa 81       	ldd	r31, Y+2	; 0x02
    3dfc:	92 83       	std	Z+2, r25	; 0x02
    3dfe:	81 83       	std	Z+1, r24	; 0x01
}
    3e00:	0f 90       	pop	r0
    3e02:	0f 90       	pop	r0
    3e04:	cf 91       	pop	r28
    3e06:	df 91       	pop	r29
    3e08:	08 95       	ret

00003e0a <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3e0a:	df 93       	push	r29
    3e0c:	cf 93       	push	r28
    3e0e:	cd b7       	in	r28, 0x3d	; 61
    3e10:	de b7       	in	r29, 0x3e	; 62
    3e12:	29 97       	sbiw	r28, 0x09	; 9
    3e14:	0f b6       	in	r0, 0x3f	; 63
    3e16:	f8 94       	cli
    3e18:	de bf       	out	0x3e, r29	; 62
    3e1a:	0f be       	out	0x3f, r0	; 63
    3e1c:	cd bf       	out	0x3d, r28	; 61
    3e1e:	9f 83       	std	Y+7, r25	; 0x07
    3e20:	8e 83       	std	Y+6, r24	; 0x06
    3e22:	79 87       	std	Y+9, r23	; 0x09
    3e24:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3e26:	0f b6       	in	r0, 0x3f	; 63
    3e28:	f8 94       	cli
    3e2a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3e2c:	80 91 ec 06 	lds	r24, 0x06EC
    3e30:	90 91 ed 06 	lds	r25, 0x06ED
    3e34:	9c 83       	std	Y+4, r25	; 0x04
    3e36:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3e38:	ee 81       	ldd	r30, Y+6	; 0x06
    3e3a:	ff 81       	ldd	r31, Y+7	; 0x07
    3e3c:	21 81       	ldd	r18, Z+1	; 0x01
    3e3e:	32 81       	ldd	r19, Z+2	; 0x02
    3e40:	8b 81       	ldd	r24, Y+3	; 0x03
    3e42:	9c 81       	ldd	r25, Y+4	; 0x04
    3e44:	82 1b       	sub	r24, r18
    3e46:	93 0b       	sbc	r25, r19
    3e48:	9a 83       	std	Y+2, r25	; 0x02
    3e4a:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3e4c:	e8 85       	ldd	r30, Y+8	; 0x08
    3e4e:	f9 85       	ldd	r31, Y+9	; 0x09
    3e50:	80 81       	ld	r24, Z
    3e52:	91 81       	ldd	r25, Z+1	; 0x01
    3e54:	2f ef       	ldi	r18, 0xFF	; 255
    3e56:	8f 3f       	cpi	r24, 0xFF	; 255
    3e58:	92 07       	cpc	r25, r18
    3e5a:	11 f4       	brne	.+4      	; 0x3e60 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3e5c:	1d 82       	std	Y+5, r1	; 0x05
    3e5e:	36 c0       	rjmp	.+108    	; 0x3ecc <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3e60:	ee 81       	ldd	r30, Y+6	; 0x06
    3e62:	ff 81       	ldd	r31, Y+7	; 0x07
    3e64:	90 81       	ld	r25, Z
    3e66:	80 91 f2 06 	lds	r24, 0x06F2
    3e6a:	98 17       	cp	r25, r24
    3e6c:	61 f0       	breq	.+24     	; 0x3e86 <xTaskCheckForTimeOut+0x7c>
    3e6e:	ee 81       	ldd	r30, Y+6	; 0x06
    3e70:	ff 81       	ldd	r31, Y+7	; 0x07
    3e72:	21 81       	ldd	r18, Z+1	; 0x01
    3e74:	32 81       	ldd	r19, Z+2	; 0x02
    3e76:	8b 81       	ldd	r24, Y+3	; 0x03
    3e78:	9c 81       	ldd	r25, Y+4	; 0x04
    3e7a:	82 17       	cp	r24, r18
    3e7c:	93 07       	cpc	r25, r19
    3e7e:	18 f0       	brcs	.+6      	; 0x3e86 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3e80:	81 e0       	ldi	r24, 0x01	; 1
    3e82:	8d 83       	std	Y+5, r24	; 0x05
    3e84:	23 c0       	rjmp	.+70     	; 0x3ecc <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3e86:	e8 85       	ldd	r30, Y+8	; 0x08
    3e88:	f9 85       	ldd	r31, Y+9	; 0x09
    3e8a:	20 81       	ld	r18, Z
    3e8c:	31 81       	ldd	r19, Z+1	; 0x01
    3e8e:	89 81       	ldd	r24, Y+1	; 0x01
    3e90:	9a 81       	ldd	r25, Y+2	; 0x02
    3e92:	82 17       	cp	r24, r18
    3e94:	93 07       	cpc	r25, r19
    3e96:	a0 f4       	brcc	.+40     	; 0x3ec0 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3e98:	e8 85       	ldd	r30, Y+8	; 0x08
    3e9a:	f9 85       	ldd	r31, Y+9	; 0x09
    3e9c:	20 81       	ld	r18, Z
    3e9e:	31 81       	ldd	r19, Z+1	; 0x01
    3ea0:	89 81       	ldd	r24, Y+1	; 0x01
    3ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ea4:	a9 01       	movw	r20, r18
    3ea6:	48 1b       	sub	r20, r24
    3ea8:	59 0b       	sbc	r21, r25
    3eaa:	ca 01       	movw	r24, r20
    3eac:	e8 85       	ldd	r30, Y+8	; 0x08
    3eae:	f9 85       	ldd	r31, Y+9	; 0x09
    3eb0:	91 83       	std	Z+1, r25	; 0x01
    3eb2:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3eb4:	8e 81       	ldd	r24, Y+6	; 0x06
    3eb6:	9f 81       	ldd	r25, Y+7	; 0x07
    3eb8:	0e 94 ec 1e 	call	0x3dd8	; 0x3dd8 <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3ebc:	1d 82       	std	Y+5, r1	; 0x05
    3ebe:	06 c0       	rjmp	.+12     	; 0x3ecc <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3ec0:	e8 85       	ldd	r30, Y+8	; 0x08
    3ec2:	f9 85       	ldd	r31, Y+9	; 0x09
    3ec4:	11 82       	std	Z+1, r1	; 0x01
    3ec6:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3ec8:	81 e0       	ldi	r24, 0x01	; 1
    3eca:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3ecc:	0f 90       	pop	r0
    3ece:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3ed0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3ed2:	29 96       	adiw	r28, 0x09	; 9
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	de bf       	out	0x3e, r29	; 62
    3eda:	0f be       	out	0x3f, r0	; 63
    3edc:	cd bf       	out	0x3d, r28	; 61
    3ede:	cf 91       	pop	r28
    3ee0:	df 91       	pop	r29
    3ee2:	08 95       	ret

00003ee4 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3ee4:	df 93       	push	r29
    3ee6:	cf 93       	push	r28
    3ee8:	cd b7       	in	r28, 0x3d	; 61
    3eea:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3eec:	81 e0       	ldi	r24, 0x01	; 1
    3eee:	80 93 f1 06 	sts	0x06F1, r24
}
    3ef2:	cf 91       	pop	r28
    3ef4:	df 91       	pop	r29
    3ef6:	08 95       	ret

00003ef8 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3ef8:	df 93       	push	r29
    3efa:	cf 93       	push	r28
    3efc:	00 d0       	rcall	.+0      	; 0x3efe <prvIdleTask+0x6>
    3efe:	cd b7       	in	r28, 0x3d	; 61
    3f00:	de b7       	in	r29, 0x3e	; 62
    3f02:	9a 83       	std	Y+2, r25	; 0x02
    3f04:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3f06:	0e 94 c7 1f 	call	0x3f8e	; 0x3f8e <prvCheckTasksWaitingTermination>
    3f0a:	fd cf       	rjmp	.-6      	; 0x3f06 <prvIdleTask+0xe>

00003f0c <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3f0c:	df 93       	push	r29
    3f0e:	cf 93       	push	r28
    3f10:	0f 92       	push	r0
    3f12:	cd b7       	in	r28, 0x3d	; 61
    3f14:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f16:	19 82       	std	Y+1, r1	; 0x01
    3f18:	13 c0       	rjmp	.+38     	; 0x3f40 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3f1a:	89 81       	ldd	r24, Y+1	; 0x01
    3f1c:	28 2f       	mov	r18, r24
    3f1e:	30 e0       	ldi	r19, 0x00	; 0
    3f20:	c9 01       	movw	r24, r18
    3f22:	88 0f       	add	r24, r24
    3f24:	99 1f       	adc	r25, r25
    3f26:	88 0f       	add	r24, r24
    3f28:	99 1f       	adc	r25, r25
    3f2a:	88 0f       	add	r24, r24
    3f2c:	99 1f       	adc	r25, r25
    3f2e:	82 0f       	add	r24, r18
    3f30:	93 1f       	adc	r25, r19
    3f32:	87 50       	subi	r24, 0x07	; 7
    3f34:	99 4f       	sbci	r25, 0xF9	; 249
    3f36:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3f3a:	89 81       	ldd	r24, Y+1	; 0x01
    3f3c:	8f 5f       	subi	r24, 0xFF	; 255
    3f3e:	89 83       	std	Y+1, r24	; 0x01
    3f40:	89 81       	ldd	r24, Y+1	; 0x01
    3f42:	84 30       	cpi	r24, 0x04	; 4
    3f44:	50 f3       	brcs	.-44     	; 0x3f1a <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3f46:	8d e1       	ldi	r24, 0x1D	; 29
    3f48:	97 e0       	ldi	r25, 0x07	; 7
    3f4a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3f4e:	86 e2       	ldi	r24, 0x26	; 38
    3f50:	97 e0       	ldi	r25, 0x07	; 7
    3f52:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3f56:	83 e3       	ldi	r24, 0x33	; 51
    3f58:	97 e0       	ldi	r25, 0x07	; 7
    3f5a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3f5e:	8c e3       	ldi	r24, 0x3C	; 60
    3f60:	97 e0       	ldi	r25, 0x07	; 7
    3f62:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    3f66:	85 e4       	ldi	r24, 0x45	; 69
    3f68:	97 e0       	ldi	r25, 0x07	; 7
    3f6a:	0e 94 0a 04 	call	0x814	; 0x814 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3f6e:	8d e1       	ldi	r24, 0x1D	; 29
    3f70:	97 e0       	ldi	r25, 0x07	; 7
    3f72:	90 93 30 07 	sts	0x0730, r25
    3f76:	80 93 2f 07 	sts	0x072F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3f7a:	86 e2       	ldi	r24, 0x26	; 38
    3f7c:	97 e0       	ldi	r25, 0x07	; 7
    3f7e:	90 93 32 07 	sts	0x0732, r25
    3f82:	80 93 31 07 	sts	0x0731, r24
}
    3f86:	0f 90       	pop	r0
    3f88:	cf 91       	pop	r28
    3f8a:	df 91       	pop	r29
    3f8c:	08 95       	ret

00003f8e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3f8e:	df 93       	push	r29
    3f90:	cf 93       	push	r28
    3f92:	00 d0       	rcall	.+0      	; 0x3f94 <prvCheckTasksWaitingTermination+0x6>
    3f94:	cd b7       	in	r28, 0x3d	; 61
    3f96:	de b7       	in	r29, 0x3e	; 62
    3f98:	20 c0       	rjmp	.+64     	; 0x3fda <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3fa0:	e0 91 41 07 	lds	r30, 0x0741
    3fa4:	f0 91 42 07 	lds	r31, 0x0742
    3fa8:	86 81       	ldd	r24, Z+6	; 0x06
    3faa:	97 81       	ldd	r25, Z+7	; 0x07
    3fac:	9a 83       	std	Y+2, r25	; 0x02
    3fae:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3fb0:	89 81       	ldd	r24, Y+1	; 0x01
    3fb2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb4:	02 96       	adiw	r24, 0x02	; 2
    3fb6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
				--uxCurrentNumberOfTasks;
    3fba:	80 91 eb 06 	lds	r24, 0x06EB
    3fbe:	81 50       	subi	r24, 0x01	; 1
    3fc0:	80 93 eb 06 	sts	0x06EB, r24
				--uxDeletedTasksWaitingCleanUp;
    3fc4:	80 91 ea 06 	lds	r24, 0x06EA
    3fc8:	81 50       	subi	r24, 0x01	; 1
    3fca:	80 93 ea 06 	sts	0x06EA, r24
			}
			taskEXIT_CRITICAL();
    3fce:	0f 90       	pop	r0
    3fd0:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3fd2:	89 81       	ldd	r24, Y+1	; 0x01
    3fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd6:	0e 94 f6 1f 	call	0x3fec	; 0x3fec <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3fda:	80 91 ea 06 	lds	r24, 0x06EA
    3fde:	88 23       	and	r24, r24
    3fe0:	e1 f6       	brne	.-72     	; 0x3f9a <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3fe2:	0f 90       	pop	r0
    3fe4:	0f 90       	pop	r0
    3fe6:	cf 91       	pop	r28
    3fe8:	df 91       	pop	r29
    3fea:	08 95       	ret

00003fec <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    3fec:	df 93       	push	r29
    3fee:	cf 93       	push	r28
    3ff0:	00 d0       	rcall	.+0      	; 0x3ff2 <prvDeleteTCB+0x6>
    3ff2:	cd b7       	in	r28, 0x3d	; 61
    3ff4:	de b7       	in	r29, 0x3e	; 62
    3ff6:	9a 83       	std	Y+2, r25	; 0x02
    3ff8:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3ffa:	e9 81       	ldd	r30, Y+1	; 0x01
    3ffc:	fa 81       	ldd	r31, Y+2	; 0x02
    3ffe:	87 89       	ldd	r24, Z+23	; 0x17
    4000:	90 8d       	ldd	r25, Z+24	; 0x18
    4002:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
			vPortFree( pxTCB );
    4006:	89 81       	ldd	r24, Y+1	; 0x01
    4008:	9a 81       	ldd	r25, Y+2	; 0x02
    400a:	0e 94 e4 03 	call	0x7c8	; 0x7c8 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    400e:	0f 90       	pop	r0
    4010:	0f 90       	pop	r0
    4012:	cf 91       	pop	r28
    4014:	df 91       	pop	r29
    4016:	08 95       	ret

00004018 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    4018:	df 93       	push	r29
    401a:	cf 93       	push	r28
    401c:	00 d0       	rcall	.+0      	; 0x401e <prvResetNextTaskUnblockTime+0x6>
    401e:	cd b7       	in	r28, 0x3d	; 61
    4020:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4022:	e0 91 2f 07 	lds	r30, 0x072F
    4026:	f0 91 30 07 	lds	r31, 0x0730
    402a:	80 81       	ld	r24, Z
    402c:	88 23       	and	r24, r24
    402e:	39 f4       	brne	.+14     	; 0x403e <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    4030:	8f ef       	ldi	r24, 0xFF	; 255
    4032:	9f ef       	ldi	r25, 0xFF	; 255
    4034:	90 93 f5 06 	sts	0x06F5, r25
    4038:	80 93 f4 06 	sts	0x06F4, r24
    403c:	13 c0       	rjmp	.+38     	; 0x4064 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    403e:	e0 91 2f 07 	lds	r30, 0x072F
    4042:	f0 91 30 07 	lds	r31, 0x0730
    4046:	05 80       	ldd	r0, Z+5	; 0x05
    4048:	f6 81       	ldd	r31, Z+6	; 0x06
    404a:	e0 2d       	mov	r30, r0
    404c:	86 81       	ldd	r24, Z+6	; 0x06
    404e:	97 81       	ldd	r25, Z+7	; 0x07
    4050:	9a 83       	std	Y+2, r25	; 0x02
    4052:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4054:	e9 81       	ldd	r30, Y+1	; 0x01
    4056:	fa 81       	ldd	r31, Y+2	; 0x02
    4058:	82 81       	ldd	r24, Z+2	; 0x02
    405a:	93 81       	ldd	r25, Z+3	; 0x03
    405c:	90 93 f5 06 	sts	0x06F5, r25
    4060:	80 93 f4 06 	sts	0x06F4, r24
	}
}
    4064:	0f 90       	pop	r0
    4066:	0f 90       	pop	r0
    4068:	cf 91       	pop	r28
    406a:	df 91       	pop	r29
    406c:	08 95       	ret

0000406e <xTaskGetCurrentTaskHandle>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )

	TaskHandle_t xTaskGetCurrentTaskHandle( void )
	{
    406e:	df 93       	push	r29
    4070:	cf 93       	push	r28
    4072:	00 d0       	rcall	.+0      	; 0x4074 <xTaskGetCurrentTaskHandle+0x6>
    4074:	cd b7       	in	r28, 0x3d	; 61
    4076:	de b7       	in	r29, 0x3e	; 62
	TaskHandle_t xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    4078:	80 91 e8 06 	lds	r24, 0x06E8
    407c:	90 91 e9 06 	lds	r25, 0x06E9
    4080:	9a 83       	std	Y+2, r25	; 0x02
    4082:	89 83       	std	Y+1, r24	; 0x01

		return xReturn;
    4084:	89 81       	ldd	r24, Y+1	; 0x01
    4086:	9a 81       	ldd	r25, Y+2	; 0x02
	}
    4088:	0f 90       	pop	r0
    408a:	0f 90       	pop	r0
    408c:	cf 91       	pop	r28
    408e:	df 91       	pop	r29
    4090:	08 95       	ret

00004092 <xTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    4092:	df 93       	push	r29
    4094:	cf 93       	push	r28
    4096:	00 d0       	rcall	.+0      	; 0x4098 <xTaskPriorityInherit+0x6>
    4098:	00 d0       	rcall	.+0      	; 0x409a <xTaskPriorityInherit+0x8>
    409a:	0f 92       	push	r0
    409c:	cd b7       	in	r28, 0x3d	; 61
    409e:	de b7       	in	r29, 0x3e	; 62
    40a0:	9d 83       	std	Y+5, r25	; 0x05
    40a2:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxMutexHolderTCB = pxMutexHolder;
    40a4:	8c 81       	ldd	r24, Y+4	; 0x04
    40a6:	9d 81       	ldd	r25, Y+5	; 0x05
    40a8:	9b 83       	std	Y+3, r25	; 0x03
    40aa:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    40ac:	19 82       	std	Y+1, r1	; 0x01

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL.  _RB_ Is this still
		needed as interrupts can no longer use mutexes? */
		if( pxMutexHolder != NULL )
    40ae:	8c 81       	ldd	r24, Y+4	; 0x04
    40b0:	9d 81       	ldd	r25, Y+5	; 0x05
    40b2:	00 97       	sbiw	r24, 0x00	; 0
    40b4:	09 f4       	brne	.+2      	; 0x40b8 <xTaskPriorityInherit+0x26>
    40b6:	82 c0       	rjmp	.+260    	; 0x41bc <xTaskPriorityInherit+0x12a>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
    40b8:	ea 81       	ldd	r30, Y+2	; 0x02
    40ba:	fb 81       	ldd	r31, Y+3	; 0x03
    40bc:	96 89       	ldd	r25, Z+22	; 0x16
    40be:	e0 91 e8 06 	lds	r30, 0x06E8
    40c2:	f0 91 e9 06 	lds	r31, 0x06E9
    40c6:	86 89       	ldd	r24, Z+22	; 0x16
    40c8:	98 17       	cp	r25, r24
    40ca:	08 f0       	brcs	.+2      	; 0x40ce <xTaskPriorityInherit+0x3c>
    40cc:	6b c0       	rjmp	.+214    	; 0x41a4 <xTaskPriorityInherit+0x112>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    40ce:	ea 81       	ldd	r30, Y+2	; 0x02
    40d0:	fb 81       	ldd	r31, Y+3	; 0x03
    40d2:	84 85       	ldd	r24, Z+12	; 0x0c
    40d4:	95 85       	ldd	r25, Z+13	; 0x0d
    40d6:	99 23       	and	r25, r25
    40d8:	7c f0       	brlt	.+30     	; 0x40f8 <xTaskPriorityInherit+0x66>
				{
					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    40da:	e0 91 e8 06 	lds	r30, 0x06E8
    40de:	f0 91 e9 06 	lds	r31, 0x06E9
    40e2:	86 89       	ldd	r24, Z+22	; 0x16
    40e4:	28 2f       	mov	r18, r24
    40e6:	30 e0       	ldi	r19, 0x00	; 0
    40e8:	84 e0       	ldi	r24, 0x04	; 4
    40ea:	90 e0       	ldi	r25, 0x00	; 0
    40ec:	82 1b       	sub	r24, r18
    40ee:	93 0b       	sbc	r25, r19
    40f0:	ea 81       	ldd	r30, Y+2	; 0x02
    40f2:	fb 81       	ldd	r31, Y+3	; 0x03
    40f4:	95 87       	std	Z+13, r25	; 0x0d
    40f6:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
    40f8:	ea 81       	ldd	r30, Y+2	; 0x02
    40fa:	fb 81       	ldd	r31, Y+3	; 0x03
    40fc:	42 85       	ldd	r20, Z+10	; 0x0a
    40fe:	53 85       	ldd	r21, Z+11	; 0x0b
    4100:	ea 81       	ldd	r30, Y+2	; 0x02
    4102:	fb 81       	ldd	r31, Y+3	; 0x03
    4104:	86 89       	ldd	r24, Z+22	; 0x16
    4106:	28 2f       	mov	r18, r24
    4108:	30 e0       	ldi	r19, 0x00	; 0
    410a:	c9 01       	movw	r24, r18
    410c:	88 0f       	add	r24, r24
    410e:	99 1f       	adc	r25, r25
    4110:	88 0f       	add	r24, r24
    4112:	99 1f       	adc	r25, r25
    4114:	88 0f       	add	r24, r24
    4116:	99 1f       	adc	r25, r25
    4118:	82 0f       	add	r24, r18
    411a:	93 1f       	adc	r25, r19
    411c:	87 50       	subi	r24, 0x07	; 7
    411e:	99 4f       	sbci	r25, 0xF9	; 249
    4120:	48 17       	cp	r20, r24
    4122:	59 07       	cpc	r21, r25
    4124:	a1 f5       	brne	.+104    	; 0x418e <xTaskPriorityInherit+0xfc>
				{
					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4126:	8a 81       	ldd	r24, Y+2	; 0x02
    4128:	9b 81       	ldd	r25, Y+3	; 0x03
    412a:	02 96       	adiw	r24, 0x02	; 2
    412c:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    4130:	e0 91 e8 06 	lds	r30, 0x06E8
    4134:	f0 91 e9 06 	lds	r31, 0x06E9
    4138:	86 89       	ldd	r24, Z+22	; 0x16
    413a:	ea 81       	ldd	r30, Y+2	; 0x02
    413c:	fb 81       	ldd	r31, Y+3	; 0x03
    413e:	86 8b       	std	Z+22, r24	; 0x16
					prvAddTaskToReadyList( pxMutexHolderTCB );
    4140:	ea 81       	ldd	r30, Y+2	; 0x02
    4142:	fb 81       	ldd	r31, Y+3	; 0x03
    4144:	96 89       	ldd	r25, Z+22	; 0x16
    4146:	80 91 ee 06 	lds	r24, 0x06EE
    414a:	89 17       	cp	r24, r25
    414c:	28 f4       	brcc	.+10     	; 0x4158 <xTaskPriorityInherit+0xc6>
    414e:	ea 81       	ldd	r30, Y+2	; 0x02
    4150:	fb 81       	ldd	r31, Y+3	; 0x03
    4152:	86 89       	ldd	r24, Z+22	; 0x16
    4154:	80 93 ee 06 	sts	0x06EE, r24
    4158:	ea 81       	ldd	r30, Y+2	; 0x02
    415a:	fb 81       	ldd	r31, Y+3	; 0x03
    415c:	86 89       	ldd	r24, Z+22	; 0x16
    415e:	28 2f       	mov	r18, r24
    4160:	30 e0       	ldi	r19, 0x00	; 0
    4162:	c9 01       	movw	r24, r18
    4164:	88 0f       	add	r24, r24
    4166:	99 1f       	adc	r25, r25
    4168:	88 0f       	add	r24, r24
    416a:	99 1f       	adc	r25, r25
    416c:	88 0f       	add	r24, r24
    416e:	99 1f       	adc	r25, r25
    4170:	82 0f       	add	r24, r18
    4172:	93 1f       	adc	r25, r19
    4174:	ac 01       	movw	r20, r24
    4176:	47 50       	subi	r20, 0x07	; 7
    4178:	59 4f       	sbci	r21, 0xF9	; 249
    417a:	8a 81       	ldd	r24, Y+2	; 0x02
    417c:	9b 81       	ldd	r25, Y+3	; 0x03
    417e:	9c 01       	movw	r18, r24
    4180:	2e 5f       	subi	r18, 0xFE	; 254
    4182:	3f 4f       	sbci	r19, 0xFF	; 255
    4184:	ca 01       	movw	r24, r20
    4186:	b9 01       	movw	r22, r18
    4188:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    418c:	08 c0       	rjmp	.+16     	; 0x419e <xTaskPriorityInherit+0x10c>
				}
				else
				{
					/* Just inherit the priority. */
					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
    418e:	e0 91 e8 06 	lds	r30, 0x06E8
    4192:	f0 91 e9 06 	lds	r31, 0x06E9
    4196:	86 89       	ldd	r24, Z+22	; 0x16
    4198:	ea 81       	ldd	r30, Y+2	; 0x02
    419a:	fb 81       	ldd	r31, Y+3	; 0x03
    419c:	86 8b       	std	Z+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );

				/* Inheritance occurred. */
				xReturn = pdTRUE;
    419e:	81 e0       	ldi	r24, 0x01	; 1
    41a0:	89 83       	std	Y+1, r24	; 0x01
    41a2:	0c c0       	rjmp	.+24     	; 0x41bc <xTaskPriorityInherit+0x12a>
			}
			else
			{
				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
    41a4:	ea 81       	ldd	r30, Y+2	; 0x02
    41a6:	fb 81       	ldd	r31, Y+3	; 0x03
    41a8:	91 a1       	ldd	r25, Z+33	; 0x21
    41aa:	e0 91 e8 06 	lds	r30, 0x06E8
    41ae:	f0 91 e9 06 	lds	r31, 0x06E9
    41b2:	86 89       	ldd	r24, Z+22	; 0x16
    41b4:	98 17       	cp	r25, r24
    41b6:	10 f4       	brcc	.+4      	; 0x41bc <xTaskPriorityInherit+0x12a>
					current priority of the mutex holder is not lower than the
					priority of the task attempting to take the mutex.
					Therefore the mutex holder must have already inherited a
					priority, but inheritance would have occurred if that had
					not been the case. */
					xReturn = pdTRUE;
    41b8:	81 e0       	ldi	r24, 0x01	; 1
    41ba:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    41bc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    41be:	0f 90       	pop	r0
    41c0:	0f 90       	pop	r0
    41c2:	0f 90       	pop	r0
    41c4:	0f 90       	pop	r0
    41c6:	0f 90       	pop	r0
    41c8:	cf 91       	pop	r28
    41ca:	df 91       	pop	r29
    41cc:	08 95       	ret

000041ce <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    41ce:	df 93       	push	r29
    41d0:	cf 93       	push	r28
    41d2:	00 d0       	rcall	.+0      	; 0x41d4 <xTaskPriorityDisinherit+0x6>
    41d4:	00 d0       	rcall	.+0      	; 0x41d6 <xTaskPriorityDisinherit+0x8>
    41d6:	0f 92       	push	r0
    41d8:	cd b7       	in	r28, 0x3d	; 61
    41da:	de b7       	in	r29, 0x3e	; 62
    41dc:	9d 83       	std	Y+5, r25	; 0x05
    41de:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t * const pxTCB = pxMutexHolder;
    41e0:	8c 81       	ldd	r24, Y+4	; 0x04
    41e2:	9d 81       	ldd	r25, Y+5	; 0x05
    41e4:	9b 83       	std	Y+3, r25	; 0x03
    41e6:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xReturn = pdFALSE;
    41e8:	19 82       	std	Y+1, r1	; 0x01

		if( pxMutexHolder != NULL )
    41ea:	8c 81       	ldd	r24, Y+4	; 0x04
    41ec:	9d 81       	ldd	r25, Y+5	; 0x05
    41ee:	00 97       	sbiw	r24, 0x00	; 0
    41f0:	09 f4       	brne	.+2      	; 0x41f4 <xTaskPriorityDisinherit+0x26>
    41f2:	56 c0       	rjmp	.+172    	; 0x42a0 <xTaskPriorityDisinherit+0xd2>
			If the mutex is held by a task then it cannot be given from an
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );
			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    41f4:	ea 81       	ldd	r30, Y+2	; 0x02
    41f6:	fb 81       	ldd	r31, Y+3	; 0x03
    41f8:	82 a1       	ldd	r24, Z+34	; 0x22
    41fa:	81 50       	subi	r24, 0x01	; 1
    41fc:	ea 81       	ldd	r30, Y+2	; 0x02
    41fe:	fb 81       	ldd	r31, Y+3	; 0x03
    4200:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    4202:	ea 81       	ldd	r30, Y+2	; 0x02
    4204:	fb 81       	ldd	r31, Y+3	; 0x03
    4206:	96 89       	ldd	r25, Z+22	; 0x16
    4208:	ea 81       	ldd	r30, Y+2	; 0x02
    420a:	fb 81       	ldd	r31, Y+3	; 0x03
    420c:	81 a1       	ldd	r24, Z+33	; 0x21
    420e:	98 17       	cp	r25, r24
    4210:	09 f4       	brne	.+2      	; 0x4214 <xTaskPriorityDisinherit+0x46>
    4212:	46 c0       	rjmp	.+140    	; 0x42a0 <xTaskPriorityDisinherit+0xd2>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    4214:	ea 81       	ldd	r30, Y+2	; 0x02
    4216:	fb 81       	ldd	r31, Y+3	; 0x03
    4218:	82 a1       	ldd	r24, Z+34	; 0x22
    421a:	88 23       	and	r24, r24
    421c:	09 f0       	breq	.+2      	; 0x4220 <xTaskPriorityDisinherit+0x52>
    421e:	40 c0       	rjmp	.+128    	; 0x42a0 <xTaskPriorityDisinherit+0xd2>
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding task then it must be the running state task.  Remove
					the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4220:	8a 81       	ldd	r24, Y+2	; 0x02
    4222:	9b 81       	ldd	r25, Y+3	; 0x03
    4224:	02 96       	adiw	r24, 0x02	; 2
    4226:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    422a:	ea 81       	ldd	r30, Y+2	; 0x02
    422c:	fb 81       	ldd	r31, Y+3	; 0x03
    422e:	81 a1       	ldd	r24, Z+33	; 0x21
    4230:	ea 81       	ldd	r30, Y+2	; 0x02
    4232:	fb 81       	ldd	r31, Y+3	; 0x03
    4234:	86 8b       	std	Z+22, r24	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4236:	ea 81       	ldd	r30, Y+2	; 0x02
    4238:	fb 81       	ldd	r31, Y+3	; 0x03
    423a:	86 89       	ldd	r24, Z+22	; 0x16
    423c:	28 2f       	mov	r18, r24
    423e:	30 e0       	ldi	r19, 0x00	; 0
    4240:	84 e0       	ldi	r24, 0x04	; 4
    4242:	90 e0       	ldi	r25, 0x00	; 0
    4244:	82 1b       	sub	r24, r18
    4246:	93 0b       	sbc	r25, r19
    4248:	ea 81       	ldd	r30, Y+2	; 0x02
    424a:	fb 81       	ldd	r31, Y+3	; 0x03
    424c:	95 87       	std	Z+13, r25	; 0x0d
    424e:	84 87       	std	Z+12, r24	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    4250:	ea 81       	ldd	r30, Y+2	; 0x02
    4252:	fb 81       	ldd	r31, Y+3	; 0x03
    4254:	96 89       	ldd	r25, Z+22	; 0x16
    4256:	80 91 ee 06 	lds	r24, 0x06EE
    425a:	89 17       	cp	r24, r25
    425c:	28 f4       	brcc	.+10     	; 0x4268 <xTaskPriorityDisinherit+0x9a>
    425e:	ea 81       	ldd	r30, Y+2	; 0x02
    4260:	fb 81       	ldd	r31, Y+3	; 0x03
    4262:	86 89       	ldd	r24, Z+22	; 0x16
    4264:	80 93 ee 06 	sts	0x06EE, r24
    4268:	ea 81       	ldd	r30, Y+2	; 0x02
    426a:	fb 81       	ldd	r31, Y+3	; 0x03
    426c:	86 89       	ldd	r24, Z+22	; 0x16
    426e:	28 2f       	mov	r18, r24
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	c9 01       	movw	r24, r18
    4274:	88 0f       	add	r24, r24
    4276:	99 1f       	adc	r25, r25
    4278:	88 0f       	add	r24, r24
    427a:	99 1f       	adc	r25, r25
    427c:	88 0f       	add	r24, r24
    427e:	99 1f       	adc	r25, r25
    4280:	82 0f       	add	r24, r18
    4282:	93 1f       	adc	r25, r19
    4284:	ac 01       	movw	r20, r24
    4286:	47 50       	subi	r20, 0x07	; 7
    4288:	59 4f       	sbci	r21, 0xF9	; 249
    428a:	8a 81       	ldd	r24, Y+2	; 0x02
    428c:	9b 81       	ldd	r25, Y+3	; 0x03
    428e:	9c 01       	movw	r18, r24
    4290:	2e 5f       	subi	r18, 0xFE	; 254
    4292:	3f 4f       	sbci	r19, 0xFF	; 255
    4294:	ca 01       	movw	r24, r20
    4296:	b9 01       	movw	r22, r18
    4298:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    429c:	81 e0       	ldi	r24, 0x01	; 1
    429e:	89 83       	std	Y+1, r24	; 0x01
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    42a0:	89 81       	ldd	r24, Y+1	; 0x01
	}
    42a2:	0f 90       	pop	r0
    42a4:	0f 90       	pop	r0
    42a6:	0f 90       	pop	r0
    42a8:	0f 90       	pop	r0
    42aa:	0f 90       	pop	r0
    42ac:	cf 91       	pop	r28
    42ae:	df 91       	pop	r29
    42b0:	08 95       	ret

000042b2 <vTaskPriorityDisinheritAfterTimeout>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
	{
    42b2:	df 93       	push	r29
    42b4:	cf 93       	push	r28
    42b6:	cd b7       	in	r28, 0x3d	; 61
    42b8:	de b7       	in	r29, 0x3e	; 62
    42ba:	28 97       	sbiw	r28, 0x08	; 8
    42bc:	0f b6       	in	r0, 0x3f	; 63
    42be:	f8 94       	cli
    42c0:	de bf       	out	0x3e, r29	; 62
    42c2:	0f be       	out	0x3f, r0	; 63
    42c4:	cd bf       	out	0x3d, r28	; 61
    42c6:	9f 83       	std	Y+7, r25	; 0x07
    42c8:	8e 83       	std	Y+6, r24	; 0x06
    42ca:	68 87       	std	Y+8, r22	; 0x08
	TCB_t * const pxTCB = pxMutexHolder;
    42cc:	8e 81       	ldd	r24, Y+6	; 0x06
    42ce:	9f 81       	ldd	r25, Y+7	; 0x07
    42d0:	9d 83       	std	Y+5, r25	; 0x05
    42d2:	8c 83       	std	Y+4, r24	; 0x04
	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
    42d4:	81 e0       	ldi	r24, 0x01	; 1
    42d6:	89 83       	std	Y+1, r24	; 0x01

		if( pxMutexHolder != NULL )
    42d8:	8e 81       	ldd	r24, Y+6	; 0x06
    42da:	9f 81       	ldd	r25, Y+7	; 0x07
    42dc:	00 97       	sbiw	r24, 0x00	; 0
    42de:	09 f4       	brne	.+2      	; 0x42e2 <vTaskPriorityDisinheritAfterTimeout+0x30>
    42e0:	74 c0       	rjmp	.+232    	; 0x43ca <vTaskPriorityDisinheritAfterTimeout+0x118>

			/* Determine the priority to which the priority of the task that
			holds the mutex should be set.  This will be the greater of the
			holding task's base priority and the priority of the highest
			priority task that is waiting to obtain the mutex. */
			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
    42e2:	ec 81       	ldd	r30, Y+4	; 0x04
    42e4:	fd 81       	ldd	r31, Y+5	; 0x05
    42e6:	91 a1       	ldd	r25, Z+33	; 0x21
    42e8:	88 85       	ldd	r24, Y+8	; 0x08
    42ea:	98 17       	cp	r25, r24
    42ec:	18 f4       	brcc	.+6      	; 0x42f4 <vTaskPriorityDisinheritAfterTimeout+0x42>
			{
				uxPriorityToUse = uxHighestPriorityWaitingTask;
    42ee:	88 85       	ldd	r24, Y+8	; 0x08
    42f0:	8a 83       	std	Y+2, r24	; 0x02
    42f2:	04 c0       	rjmp	.+8      	; 0x42fc <vTaskPriorityDisinheritAfterTimeout+0x4a>
			}
			else
			{
				uxPriorityToUse = pxTCB->uxBasePriority;
    42f4:	ec 81       	ldd	r30, Y+4	; 0x04
    42f6:	fd 81       	ldd	r31, Y+5	; 0x05
    42f8:	81 a1       	ldd	r24, Z+33	; 0x21
    42fa:	8a 83       	std	Y+2, r24	; 0x02
			}

			/* Does the priority need to change? */
			if( pxTCB->uxPriority != uxPriorityToUse )
    42fc:	ec 81       	ldd	r30, Y+4	; 0x04
    42fe:	fd 81       	ldd	r31, Y+5	; 0x05
    4300:	96 89       	ldd	r25, Z+22	; 0x16
    4302:	8a 81       	ldd	r24, Y+2	; 0x02
    4304:	98 17       	cp	r25, r24
    4306:	09 f4       	brne	.+2      	; 0x430a <vTaskPriorityDisinheritAfterTimeout+0x58>
    4308:	60 c0       	rjmp	.+192    	; 0x43ca <vTaskPriorityDisinheritAfterTimeout+0x118>
			{
				/* Only disinherit if no other mutexes are held.  This is a
				simplification in the priority inheritance implementation.  If
				the task that holds the mutex is also holding other mutexes then
				the other mutexes may have caused the priority inheritance. */
				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
    430a:	ec 81       	ldd	r30, Y+4	; 0x04
    430c:	fd 81       	ldd	r31, Y+5	; 0x05
    430e:	92 a1       	ldd	r25, Z+34	; 0x22
    4310:	89 81       	ldd	r24, Y+1	; 0x01
    4312:	98 17       	cp	r25, r24
    4314:	09 f0       	breq	.+2      	; 0x4318 <vTaskPriorityDisinheritAfterTimeout+0x66>
    4316:	59 c0       	rjmp	.+178    	; 0x43ca <vTaskPriorityDisinheritAfterTimeout+0x118>

					/* Disinherit the priority, remembering the previous
					priority to facilitate determining the subject task's
					state. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					uxPriorityUsedOnEntry = pxTCB->uxPriority;
    4318:	ec 81       	ldd	r30, Y+4	; 0x04
    431a:	fd 81       	ldd	r31, Y+5	; 0x05
    431c:	86 89       	ldd	r24, Z+22	; 0x16
    431e:	8b 83       	std	Y+3, r24	; 0x03
					pxTCB->uxPriority = uxPriorityToUse;
    4320:	ec 81       	ldd	r30, Y+4	; 0x04
    4322:	fd 81       	ldd	r31, Y+5	; 0x05
    4324:	8a 81       	ldd	r24, Y+2	; 0x02
    4326:	86 8b       	std	Z+22, r24	; 0x16

					/* Only reset the event list item value if the value is not
					being used for anything else. */
					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    4328:	ec 81       	ldd	r30, Y+4	; 0x04
    432a:	fd 81       	ldd	r31, Y+5	; 0x05
    432c:	84 85       	ldd	r24, Z+12	; 0x0c
    432e:	95 85       	ldd	r25, Z+13	; 0x0d
    4330:	99 23       	and	r25, r25
    4332:	5c f0       	brlt	.+22     	; 0x434a <vTaskPriorityDisinheritAfterTimeout+0x98>
					{
						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4334:	8a 81       	ldd	r24, Y+2	; 0x02
    4336:	28 2f       	mov	r18, r24
    4338:	30 e0       	ldi	r19, 0x00	; 0
    433a:	84 e0       	ldi	r24, 0x04	; 4
    433c:	90 e0       	ldi	r25, 0x00	; 0
    433e:	82 1b       	sub	r24, r18
    4340:	93 0b       	sbc	r25, r19
    4342:	ec 81       	ldd	r30, Y+4	; 0x04
    4344:	fd 81       	ldd	r31, Y+5	; 0x05
    4346:	95 87       	std	Z+13, r25	; 0x0d
    4348:	84 87       	std	Z+12, r24	; 0x0c
					then the task that holds the mutex could be in either the
					Ready, Blocked or Suspended states.  Only remove the task
					from its current state list if it is in the Ready state as
					the task's priority is going to change and there is one
					Ready list per priority. */
					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    434a:	ec 81       	ldd	r30, Y+4	; 0x04
    434c:	fd 81       	ldd	r31, Y+5	; 0x05
    434e:	42 85       	ldd	r20, Z+10	; 0x0a
    4350:	53 85       	ldd	r21, Z+11	; 0x0b
    4352:	8b 81       	ldd	r24, Y+3	; 0x03
    4354:	28 2f       	mov	r18, r24
    4356:	30 e0       	ldi	r19, 0x00	; 0
    4358:	c9 01       	movw	r24, r18
    435a:	88 0f       	add	r24, r24
    435c:	99 1f       	adc	r25, r25
    435e:	88 0f       	add	r24, r24
    4360:	99 1f       	adc	r25, r25
    4362:	88 0f       	add	r24, r24
    4364:	99 1f       	adc	r25, r25
    4366:	82 0f       	add	r24, r18
    4368:	93 1f       	adc	r25, r19
    436a:	87 50       	subi	r24, 0x07	; 7
    436c:	99 4f       	sbci	r25, 0xF9	; 249
    436e:	48 17       	cp	r20, r24
    4370:	59 07       	cpc	r21, r25
    4372:	59 f5       	brne	.+86     	; 0x43ca <vTaskPriorityDisinheritAfterTimeout+0x118>
					{
						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4374:	8c 81       	ldd	r24, Y+4	; 0x04
    4376:	9d 81       	ldd	r25, Y+5	; 0x05
    4378:	02 96       	adiw	r24, 0x02	; 2
    437a:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}

						prvAddTaskToReadyList( pxTCB );
    437e:	ec 81       	ldd	r30, Y+4	; 0x04
    4380:	fd 81       	ldd	r31, Y+5	; 0x05
    4382:	96 89       	ldd	r25, Z+22	; 0x16
    4384:	80 91 ee 06 	lds	r24, 0x06EE
    4388:	89 17       	cp	r24, r25
    438a:	28 f4       	brcc	.+10     	; 0x4396 <vTaskPriorityDisinheritAfterTimeout+0xe4>
    438c:	ec 81       	ldd	r30, Y+4	; 0x04
    438e:	fd 81       	ldd	r31, Y+5	; 0x05
    4390:	86 89       	ldd	r24, Z+22	; 0x16
    4392:	80 93 ee 06 	sts	0x06EE, r24
    4396:	ec 81       	ldd	r30, Y+4	; 0x04
    4398:	fd 81       	ldd	r31, Y+5	; 0x05
    439a:	86 89       	ldd	r24, Z+22	; 0x16
    439c:	28 2f       	mov	r18, r24
    439e:	30 e0       	ldi	r19, 0x00	; 0
    43a0:	c9 01       	movw	r24, r18
    43a2:	88 0f       	add	r24, r24
    43a4:	99 1f       	adc	r25, r25
    43a6:	88 0f       	add	r24, r24
    43a8:	99 1f       	adc	r25, r25
    43aa:	88 0f       	add	r24, r24
    43ac:	99 1f       	adc	r25, r25
    43ae:	82 0f       	add	r24, r18
    43b0:	93 1f       	adc	r25, r19
    43b2:	ac 01       	movw	r20, r24
    43b4:	47 50       	subi	r20, 0x07	; 7
    43b6:	59 4f       	sbci	r21, 0xF9	; 249
    43b8:	8c 81       	ldd	r24, Y+4	; 0x04
    43ba:	9d 81       	ldd	r25, Y+5	; 0x05
    43bc:	9c 01       	movw	r18, r24
    43be:	2e 5f       	subi	r18, 0xFE	; 254
    43c0:	3f 4f       	sbci	r19, 0xFF	; 255
    43c2:	ca 01       	movw	r24, r20
    43c4:	b9 01       	movw	r22, r18
    43c6:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    43ca:	28 96       	adiw	r28, 0x08	; 8
    43cc:	0f b6       	in	r0, 0x3f	; 63
    43ce:	f8 94       	cli
    43d0:	de bf       	out	0x3e, r29	; 62
    43d2:	0f be       	out	0x3f, r0	; 63
    43d4:	cd bf       	out	0x3d, r28	; 61
    43d6:	cf 91       	pop	r28
    43d8:	df 91       	pop	r29
    43da:	08 95       	ret

000043dc <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    43dc:	df 93       	push	r29
    43de:	cf 93       	push	r28
    43e0:	00 d0       	rcall	.+0      	; 0x43e2 <uxTaskResetEventItemValue+0x6>
    43e2:	cd b7       	in	r28, 0x3d	; 61
    43e4:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    43e6:	e0 91 e8 06 	lds	r30, 0x06E8
    43ea:	f0 91 e9 06 	lds	r31, 0x06E9
    43ee:	84 85       	ldd	r24, Z+12	; 0x0c
    43f0:	95 85       	ldd	r25, Z+13	; 0x0d
    43f2:	9a 83       	std	Y+2, r25	; 0x02
    43f4:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    43f6:	a0 91 e8 06 	lds	r26, 0x06E8
    43fa:	b0 91 e9 06 	lds	r27, 0x06E9
    43fe:	e0 91 e8 06 	lds	r30, 0x06E8
    4402:	f0 91 e9 06 	lds	r31, 0x06E9
    4406:	86 89       	ldd	r24, Z+22	; 0x16
    4408:	28 2f       	mov	r18, r24
    440a:	30 e0       	ldi	r19, 0x00	; 0
    440c:	84 e0       	ldi	r24, 0x04	; 4
    440e:	90 e0       	ldi	r25, 0x00	; 0
    4410:	82 1b       	sub	r24, r18
    4412:	93 0b       	sbc	r25, r19
    4414:	1d 96       	adiw	r26, 0x0d	; 13
    4416:	9c 93       	st	X, r25
    4418:	8e 93       	st	-X, r24
    441a:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    441c:	89 81       	ldd	r24, Y+1	; 0x01
    441e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4420:	0f 90       	pop	r0
    4422:	0f 90       	pop	r0
    4424:	cf 91       	pop	r28
    4426:	df 91       	pop	r29
    4428:	08 95       	ret

0000442a <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
    442a:	df 93       	push	r29
    442c:	cf 93       	push	r28
    442e:	cd b7       	in	r28, 0x3d	; 61
    4430:	de b7       	in	r29, 0x3e	; 62
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    4432:	80 91 e8 06 	lds	r24, 0x06E8
    4436:	90 91 e9 06 	lds	r25, 0x06E9
    443a:	00 97       	sbiw	r24, 0x00	; 0
    443c:	39 f0       	breq	.+14     	; 0x444c <pvTaskIncrementMutexHeldCount+0x22>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    443e:	e0 91 e8 06 	lds	r30, 0x06E8
    4442:	f0 91 e9 06 	lds	r31, 0x06E9
    4446:	82 a1       	ldd	r24, Z+34	; 0x22
    4448:	8f 5f       	subi	r24, 0xFF	; 255
    444a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    444c:	80 91 e8 06 	lds	r24, 0x06E8
    4450:	90 91 e9 06 	lds	r25, 0x06E9
	}
    4454:	cf 91       	pop	r28
    4456:	df 91       	pop	r29
    4458:	08 95       	ret

0000445a <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    445a:	df 93       	push	r29
    445c:	cf 93       	push	r28
    445e:	cd b7       	in	r28, 0x3d	; 61
    4460:	de b7       	in	r29, 0x3e	; 62
    4462:	27 97       	sbiw	r28, 0x07	; 7
    4464:	0f b6       	in	r0, 0x3f	; 63
    4466:	f8 94       	cli
    4468:	de bf       	out	0x3e, r29	; 62
    446a:	0f be       	out	0x3f, r0	; 63
    446c:	cd bf       	out	0x3d, r28	; 61
    446e:	8d 83       	std	Y+5, r24	; 0x05
    4470:	7f 83       	std	Y+7, r23	; 0x07
    4472:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4474:	0f b6       	in	r0, 0x3f	; 63
    4476:	f8 94       	cli
    4478:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    447a:	e0 91 e8 06 	lds	r30, 0x06E8
    447e:	f0 91 e9 06 	lds	r31, 0x06E9
    4482:	83 a1       	ldd	r24, Z+35	; 0x23
    4484:	94 a1       	ldd	r25, Z+36	; 0x24
    4486:	a5 a1       	ldd	r26, Z+37	; 0x25
    4488:	b6 a1       	ldd	r27, Z+38	; 0x26
    448a:	00 97       	sbiw	r24, 0x00	; 0
    448c:	a1 05       	cpc	r26, r1
    448e:	b1 05       	cpc	r27, r1
    4490:	89 f4       	brne	.+34     	; 0x44b4 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    4492:	e0 91 e8 06 	lds	r30, 0x06E8
    4496:	f0 91 e9 06 	lds	r31, 0x06E9
    449a:	81 e0       	ldi	r24, 0x01	; 1
    449c:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    449e:	8e 81       	ldd	r24, Y+6	; 0x06
    44a0:	9f 81       	ldd	r25, Y+7	; 0x07
    44a2:	00 97       	sbiw	r24, 0x00	; 0
    44a4:	39 f0       	breq	.+14     	; 0x44b4 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    44a6:	8e 81       	ldd	r24, Y+6	; 0x06
    44a8:	9f 81       	ldd	r25, Y+7	; 0x07
    44aa:	61 e0       	ldi	r22, 0x01	; 1
    44ac:	0e 94 d5 25 	call	0x4baa	; 0x4baa <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    44b0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    44b4:	0f 90       	pop	r0
    44b6:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    44b8:	0f b6       	in	r0, 0x3f	; 63
    44ba:	f8 94       	cli
    44bc:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    44be:	e0 91 e8 06 	lds	r30, 0x06E8
    44c2:	f0 91 e9 06 	lds	r31, 0x06E9
    44c6:	83 a1       	ldd	r24, Z+35	; 0x23
    44c8:	94 a1       	ldd	r25, Z+36	; 0x24
    44ca:	a5 a1       	ldd	r26, Z+37	; 0x25
    44cc:	b6 a1       	ldd	r27, Z+38	; 0x26
    44ce:	89 83       	std	Y+1, r24	; 0x01
    44d0:	9a 83       	std	Y+2, r25	; 0x02
    44d2:	ab 83       	std	Y+3, r26	; 0x03
    44d4:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    44d6:	89 81       	ldd	r24, Y+1	; 0x01
    44d8:	9a 81       	ldd	r25, Y+2	; 0x02
    44da:	ab 81       	ldd	r26, Y+3	; 0x03
    44dc:	bc 81       	ldd	r27, Y+4	; 0x04
    44de:	00 97       	sbiw	r24, 0x00	; 0
    44e0:	a1 05       	cpc	r26, r1
    44e2:	b1 05       	cpc	r27, r1
    44e4:	d9 f0       	breq	.+54     	; 0x451c <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    44e6:	8d 81       	ldd	r24, Y+5	; 0x05
    44e8:	88 23       	and	r24, r24
    44ea:	49 f0       	breq	.+18     	; 0x44fe <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    44ec:	e0 91 e8 06 	lds	r30, 0x06E8
    44f0:	f0 91 e9 06 	lds	r31, 0x06E9
    44f4:	13 a2       	std	Z+35, r1	; 0x23
    44f6:	14 a2       	std	Z+36, r1	; 0x24
    44f8:	15 a2       	std	Z+37, r1	; 0x25
    44fa:	16 a2       	std	Z+38, r1	; 0x26
    44fc:	0f c0       	rjmp	.+30     	; 0x451c <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    44fe:	e0 91 e8 06 	lds	r30, 0x06E8
    4502:	f0 91 e9 06 	lds	r31, 0x06E9
    4506:	89 81       	ldd	r24, Y+1	; 0x01
    4508:	9a 81       	ldd	r25, Y+2	; 0x02
    450a:	ab 81       	ldd	r26, Y+3	; 0x03
    450c:	bc 81       	ldd	r27, Y+4	; 0x04
    450e:	01 97       	sbiw	r24, 0x01	; 1
    4510:	a1 09       	sbc	r26, r1
    4512:	b1 09       	sbc	r27, r1
    4514:	83 a3       	std	Z+35, r24	; 0x23
    4516:	94 a3       	std	Z+36, r25	; 0x24
    4518:	a5 a3       	std	Z+37, r26	; 0x25
    451a:	b6 a3       	std	Z+38, r27	; 0x26
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    451c:	e0 91 e8 06 	lds	r30, 0x06E8
    4520:	f0 91 e9 06 	lds	r31, 0x06E9
    4524:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    4526:	0f 90       	pop	r0
    4528:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    452a:	89 81       	ldd	r24, Y+1	; 0x01
    452c:	9a 81       	ldd	r25, Y+2	; 0x02
    452e:	ab 81       	ldd	r26, Y+3	; 0x03
    4530:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4532:	bc 01       	movw	r22, r24
    4534:	cd 01       	movw	r24, r26
    4536:	27 96       	adiw	r28, 0x07	; 7
    4538:	0f b6       	in	r0, 0x3f	; 63
    453a:	f8 94       	cli
    453c:	de bf       	out	0x3e, r29	; 62
    453e:	0f be       	out	0x3f, r0	; 63
    4540:	cd bf       	out	0x3d, r28	; 61
    4542:	cf 91       	pop	r28
    4544:	df 91       	pop	r29
    4546:	08 95       	ret

00004548 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    4548:	ef 92       	push	r14
    454a:	ff 92       	push	r15
    454c:	0f 93       	push	r16
    454e:	1f 93       	push	r17
    4550:	df 93       	push	r29
    4552:	cf 93       	push	r28
    4554:	cd b7       	in	r28, 0x3d	; 61
    4556:	de b7       	in	r29, 0x3e	; 62
    4558:	2d 97       	sbiw	r28, 0x0d	; 13
    455a:	0f b6       	in	r0, 0x3f	; 63
    455c:	f8 94       	cli
    455e:	de bf       	out	0x3e, r29	; 62
    4560:	0f be       	out	0x3f, r0	; 63
    4562:	cd bf       	out	0x3d, r28	; 61
    4564:	6a 83       	std	Y+2, r22	; 0x02
    4566:	7b 83       	std	Y+3, r23	; 0x03
    4568:	8c 83       	std	Y+4, r24	; 0x04
    456a:	9d 83       	std	Y+5, r25	; 0x05
    456c:	2e 83       	std	Y+6, r18	; 0x06
    456e:	3f 83       	std	Y+7, r19	; 0x07
    4570:	48 87       	std	Y+8, r20	; 0x08
    4572:	59 87       	std	Y+9, r21	; 0x09
    4574:	1b 87       	std	Y+11, r17	; 0x0b
    4576:	0a 87       	std	Y+10, r16	; 0x0a
    4578:	fd 86       	std	Y+13, r15	; 0x0d
    457a:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    457c:	0f b6       	in	r0, 0x3f	; 63
    457e:	f8 94       	cli
    4580:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4582:	e0 91 e8 06 	lds	r30, 0x06E8
    4586:	f0 91 e9 06 	lds	r31, 0x06E9
    458a:	87 a1       	ldd	r24, Z+39	; 0x27
    458c:	82 30       	cpi	r24, 0x02	; 2
    458e:	49 f1       	breq	.+82     	; 0x45e2 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    4590:	e0 91 e8 06 	lds	r30, 0x06E8
    4594:	f0 91 e9 06 	lds	r31, 0x06E9
    4598:	23 a1       	ldd	r18, Z+35	; 0x23
    459a:	34 a1       	ldd	r19, Z+36	; 0x24
    459c:	45 a1       	ldd	r20, Z+37	; 0x25
    459e:	56 a1       	ldd	r21, Z+38	; 0x26
    45a0:	8a 81       	ldd	r24, Y+2	; 0x02
    45a2:	9b 81       	ldd	r25, Y+3	; 0x03
    45a4:	ac 81       	ldd	r26, Y+4	; 0x04
    45a6:	bd 81       	ldd	r27, Y+5	; 0x05
    45a8:	80 95       	com	r24
    45aa:	90 95       	com	r25
    45ac:	a0 95       	com	r26
    45ae:	b0 95       	com	r27
    45b0:	82 23       	and	r24, r18
    45b2:	93 23       	and	r25, r19
    45b4:	a4 23       	and	r26, r20
    45b6:	b5 23       	and	r27, r21
    45b8:	83 a3       	std	Z+35, r24	; 0x23
    45ba:	94 a3       	std	Z+36, r25	; 0x24
    45bc:	a5 a3       	std	Z+37, r26	; 0x25
    45be:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    45c0:	e0 91 e8 06 	lds	r30, 0x06E8
    45c4:	f0 91 e9 06 	lds	r31, 0x06E9
    45c8:	81 e0       	ldi	r24, 0x01	; 1
    45ca:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    45cc:	8c 85       	ldd	r24, Y+12	; 0x0c
    45ce:	9d 85       	ldd	r25, Y+13	; 0x0d
    45d0:	00 97       	sbiw	r24, 0x00	; 0
    45d2:	39 f0       	breq	.+14     	; 0x45e2 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    45d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    45d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    45d8:	61 e0       	ldi	r22, 0x01	; 1
    45da:	0e 94 d5 25 	call	0x4baa	; 0x4baa <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    45de:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    45e2:	0f 90       	pop	r0
    45e4:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    45e6:	0f b6       	in	r0, 0x3f	; 63
    45e8:	f8 94       	cli
    45ea:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    45ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    45ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    45f0:	00 97       	sbiw	r24, 0x00	; 0
    45f2:	71 f0       	breq	.+28     	; 0x4610 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    45f4:	e0 91 e8 06 	lds	r30, 0x06E8
    45f8:	f0 91 e9 06 	lds	r31, 0x06E9
    45fc:	83 a1       	ldd	r24, Z+35	; 0x23
    45fe:	94 a1       	ldd	r25, Z+36	; 0x24
    4600:	a5 a1       	ldd	r26, Z+37	; 0x25
    4602:	b6 a1       	ldd	r27, Z+38	; 0x26
    4604:	ea 85       	ldd	r30, Y+10	; 0x0a
    4606:	fb 85       	ldd	r31, Y+11	; 0x0b
    4608:	80 83       	st	Z, r24
    460a:	91 83       	std	Z+1, r25	; 0x01
    460c:	a2 83       	std	Z+2, r26	; 0x02
    460e:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4610:	e0 91 e8 06 	lds	r30, 0x06E8
    4614:	f0 91 e9 06 	lds	r31, 0x06E9
    4618:	87 a1       	ldd	r24, Z+39	; 0x27
    461a:	82 30       	cpi	r24, 0x02	; 2
    461c:	11 f0       	breq	.+4      	; 0x4622 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    461e:	19 82       	std	Y+1, r1	; 0x01
    4620:	1a c0       	rjmp	.+52     	; 0x4656 <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4622:	e0 91 e8 06 	lds	r30, 0x06E8
    4626:	f0 91 e9 06 	lds	r31, 0x06E9
    462a:	23 a1       	ldd	r18, Z+35	; 0x23
    462c:	34 a1       	ldd	r19, Z+36	; 0x24
    462e:	45 a1       	ldd	r20, Z+37	; 0x25
    4630:	56 a1       	ldd	r21, Z+38	; 0x26
    4632:	8e 81       	ldd	r24, Y+6	; 0x06
    4634:	9f 81       	ldd	r25, Y+7	; 0x07
    4636:	a8 85       	ldd	r26, Y+8	; 0x08
    4638:	b9 85       	ldd	r27, Y+9	; 0x09
    463a:	80 95       	com	r24
    463c:	90 95       	com	r25
    463e:	a0 95       	com	r26
    4640:	b0 95       	com	r27
    4642:	82 23       	and	r24, r18
    4644:	93 23       	and	r25, r19
    4646:	a4 23       	and	r26, r20
    4648:	b5 23       	and	r27, r21
    464a:	83 a3       	std	Z+35, r24	; 0x23
    464c:	94 a3       	std	Z+36, r25	; 0x24
    464e:	a5 a3       	std	Z+37, r26	; 0x25
    4650:	b6 a3       	std	Z+38, r27	; 0x26
				xReturn = pdTRUE;
    4652:	81 e0       	ldi	r24, 0x01	; 1
    4654:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4656:	e0 91 e8 06 	lds	r30, 0x06E8
    465a:	f0 91 e9 06 	lds	r31, 0x06E9
    465e:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    4660:	0f 90       	pop	r0
    4662:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4664:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4666:	2d 96       	adiw	r28, 0x0d	; 13
    4668:	0f b6       	in	r0, 0x3f	; 63
    466a:	f8 94       	cli
    466c:	de bf       	out	0x3e, r29	; 62
    466e:	0f be       	out	0x3f, r0	; 63
    4670:	cd bf       	out	0x3d, r28	; 61
    4672:	cf 91       	pop	r28
    4674:	df 91       	pop	r29
    4676:	1f 91       	pop	r17
    4678:	0f 91       	pop	r16
    467a:	ff 90       	pop	r15
    467c:	ef 90       	pop	r14
    467e:	08 95       	ret

00004680 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4680:	0f 93       	push	r16
    4682:	1f 93       	push	r17
    4684:	df 93       	push	r29
    4686:	cf 93       	push	r28
    4688:	cd b7       	in	r28, 0x3d	; 61
    468a:	de b7       	in	r29, 0x3e	; 62
    468c:	2f 97       	sbiw	r28, 0x0f	; 15
    468e:	0f b6       	in	r0, 0x3f	; 63
    4690:	f8 94       	cli
    4692:	de bf       	out	0x3e, r29	; 62
    4694:	0f be       	out	0x3f, r0	; 63
    4696:	cd bf       	out	0x3d, r28	; 61
    4698:	9e 83       	std	Y+6, r25	; 0x06
    469a:	8d 83       	std	Y+5, r24	; 0x05
    469c:	4f 83       	std	Y+7, r20	; 0x07
    469e:	58 87       	std	Y+8, r21	; 0x08
    46a0:	69 87       	std	Y+9, r22	; 0x09
    46a2:	7a 87       	std	Y+10, r23	; 0x0a
    46a4:	2b 87       	std	Y+11, r18	; 0x0b
    46a6:	1d 87       	std	Y+13, r17	; 0x0d
    46a8:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    46aa:	81 e0       	ldi	r24, 0x01	; 1
    46ac:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    46ae:	8d 81       	ldd	r24, Y+5	; 0x05
    46b0:	9e 81       	ldd	r25, Y+6	; 0x06
    46b2:	9c 83       	std	Y+4, r25	; 0x04
    46b4:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    46b6:	0f b6       	in	r0, 0x3f	; 63
    46b8:	f8 94       	cli
    46ba:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    46bc:	8c 85       	ldd	r24, Y+12	; 0x0c
    46be:	9d 85       	ldd	r25, Y+13	; 0x0d
    46c0:	00 97       	sbiw	r24, 0x00	; 0
    46c2:	61 f0       	breq	.+24     	; 0x46dc <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    46c4:	eb 81       	ldd	r30, Y+3	; 0x03
    46c6:	fc 81       	ldd	r31, Y+4	; 0x04
    46c8:	83 a1       	ldd	r24, Z+35	; 0x23
    46ca:	94 a1       	ldd	r25, Z+36	; 0x24
    46cc:	a5 a1       	ldd	r26, Z+37	; 0x25
    46ce:	b6 a1       	ldd	r27, Z+38	; 0x26
    46d0:	ec 85       	ldd	r30, Y+12	; 0x0c
    46d2:	fd 85       	ldd	r31, Y+13	; 0x0d
    46d4:	80 83       	st	Z, r24
    46d6:	91 83       	std	Z+1, r25	; 0x01
    46d8:	a2 83       	std	Z+2, r26	; 0x02
    46da:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    46dc:	eb 81       	ldd	r30, Y+3	; 0x03
    46de:	fc 81       	ldd	r31, Y+4	; 0x04
    46e0:	87 a1       	ldd	r24, Z+39	; 0x27
    46e2:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    46e4:	eb 81       	ldd	r30, Y+3	; 0x03
    46e6:	fc 81       	ldd	r31, Y+4	; 0x04
    46e8:	82 e0       	ldi	r24, 0x02	; 2
    46ea:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    46ec:	8b 85       	ldd	r24, Y+11	; 0x0b
    46ee:	28 2f       	mov	r18, r24
    46f0:	30 e0       	ldi	r19, 0x00	; 0
    46f2:	3f 87       	std	Y+15, r19	; 0x0f
    46f4:	2e 87       	std	Y+14, r18	; 0x0e
    46f6:	8e 85       	ldd	r24, Y+14	; 0x0e
    46f8:	9f 85       	ldd	r25, Y+15	; 0x0f
    46fa:	82 30       	cpi	r24, 0x02	; 2
    46fc:	91 05       	cpc	r25, r1
    46fe:	59 f1       	breq	.+86     	; 0x4756 <xTaskGenericNotify+0xd6>
    4700:	2e 85       	ldd	r18, Y+14	; 0x0e
    4702:	3f 85       	ldd	r19, Y+15	; 0x0f
    4704:	23 30       	cpi	r18, 0x03	; 3
    4706:	31 05       	cpc	r19, r1
    4708:	34 f4       	brge	.+12     	; 0x4716 <xTaskGenericNotify+0x96>
    470a:	8e 85       	ldd	r24, Y+14	; 0x0e
    470c:	9f 85       	ldd	r25, Y+15	; 0x0f
    470e:	81 30       	cpi	r24, 0x01	; 1
    4710:	91 05       	cpc	r25, r1
    4712:	61 f0       	breq	.+24     	; 0x472c <xTaskGenericNotify+0xac>
    4714:	4a c0       	rjmp	.+148    	; 0x47aa <xTaskGenericNotify+0x12a>
    4716:	2e 85       	ldd	r18, Y+14	; 0x0e
    4718:	3f 85       	ldd	r19, Y+15	; 0x0f
    471a:	23 30       	cpi	r18, 0x03	; 3
    471c:	31 05       	cpc	r19, r1
    471e:	59 f1       	breq	.+86     	; 0x4776 <xTaskGenericNotify+0xf6>
    4720:	8e 85       	ldd	r24, Y+14	; 0x0e
    4722:	9f 85       	ldd	r25, Y+15	; 0x0f
    4724:	84 30       	cpi	r24, 0x04	; 4
    4726:	91 05       	cpc	r25, r1
    4728:	89 f1       	breq	.+98     	; 0x478c <xTaskGenericNotify+0x10c>
    472a:	3f c0       	rjmp	.+126    	; 0x47aa <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    472c:	eb 81       	ldd	r30, Y+3	; 0x03
    472e:	fc 81       	ldd	r31, Y+4	; 0x04
    4730:	23 a1       	ldd	r18, Z+35	; 0x23
    4732:	34 a1       	ldd	r19, Z+36	; 0x24
    4734:	45 a1       	ldd	r20, Z+37	; 0x25
    4736:	56 a1       	ldd	r21, Z+38	; 0x26
    4738:	8f 81       	ldd	r24, Y+7	; 0x07
    473a:	98 85       	ldd	r25, Y+8	; 0x08
    473c:	a9 85       	ldd	r26, Y+9	; 0x09
    473e:	ba 85       	ldd	r27, Y+10	; 0x0a
    4740:	82 2b       	or	r24, r18
    4742:	93 2b       	or	r25, r19
    4744:	a4 2b       	or	r26, r20
    4746:	b5 2b       	or	r27, r21
    4748:	eb 81       	ldd	r30, Y+3	; 0x03
    474a:	fc 81       	ldd	r31, Y+4	; 0x04
    474c:	83 a3       	std	Z+35, r24	; 0x23
    474e:	94 a3       	std	Z+36, r25	; 0x24
    4750:	a5 a3       	std	Z+37, r26	; 0x25
    4752:	b6 a3       	std	Z+38, r27	; 0x26
    4754:	2a c0       	rjmp	.+84     	; 0x47aa <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4756:	eb 81       	ldd	r30, Y+3	; 0x03
    4758:	fc 81       	ldd	r31, Y+4	; 0x04
    475a:	83 a1       	ldd	r24, Z+35	; 0x23
    475c:	94 a1       	ldd	r25, Z+36	; 0x24
    475e:	a5 a1       	ldd	r26, Z+37	; 0x25
    4760:	b6 a1       	ldd	r27, Z+38	; 0x26
    4762:	01 96       	adiw	r24, 0x01	; 1
    4764:	a1 1d       	adc	r26, r1
    4766:	b1 1d       	adc	r27, r1
    4768:	eb 81       	ldd	r30, Y+3	; 0x03
    476a:	fc 81       	ldd	r31, Y+4	; 0x04
    476c:	83 a3       	std	Z+35, r24	; 0x23
    476e:	94 a3       	std	Z+36, r25	; 0x24
    4770:	a5 a3       	std	Z+37, r26	; 0x25
    4772:	b6 a3       	std	Z+38, r27	; 0x26
    4774:	1a c0       	rjmp	.+52     	; 0x47aa <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4776:	eb 81       	ldd	r30, Y+3	; 0x03
    4778:	fc 81       	ldd	r31, Y+4	; 0x04
    477a:	8f 81       	ldd	r24, Y+7	; 0x07
    477c:	98 85       	ldd	r25, Y+8	; 0x08
    477e:	a9 85       	ldd	r26, Y+9	; 0x09
    4780:	ba 85       	ldd	r27, Y+10	; 0x0a
    4782:	83 a3       	std	Z+35, r24	; 0x23
    4784:	94 a3       	std	Z+36, r25	; 0x24
    4786:	a5 a3       	std	Z+37, r26	; 0x25
    4788:	b6 a3       	std	Z+38, r27	; 0x26
    478a:	0f c0       	rjmp	.+30     	; 0x47aa <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    478c:	89 81       	ldd	r24, Y+1	; 0x01
    478e:	82 30       	cpi	r24, 0x02	; 2
    4790:	59 f0       	breq	.+22     	; 0x47a8 <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4792:	eb 81       	ldd	r30, Y+3	; 0x03
    4794:	fc 81       	ldd	r31, Y+4	; 0x04
    4796:	8f 81       	ldd	r24, Y+7	; 0x07
    4798:	98 85       	ldd	r25, Y+8	; 0x08
    479a:	a9 85       	ldd	r26, Y+9	; 0x09
    479c:	ba 85       	ldd	r27, Y+10	; 0x0a
    479e:	83 a3       	std	Z+35, r24	; 0x23
    47a0:	94 a3       	std	Z+36, r25	; 0x24
    47a2:	a5 a3       	std	Z+37, r26	; 0x25
    47a4:	b6 a3       	std	Z+38, r27	; 0x26
    47a6:	01 c0       	rjmp	.+2      	; 0x47aa <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    47a8:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    47aa:	89 81       	ldd	r24, Y+1	; 0x01
    47ac:	81 30       	cpi	r24, 0x01	; 1
    47ae:	b9 f5       	brne	.+110    	; 0x481e <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    47b0:	8b 81       	ldd	r24, Y+3	; 0x03
    47b2:	9c 81       	ldd	r25, Y+4	; 0x04
    47b4:	02 96       	adiw	r24, 0x02	; 2
    47b6:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    47ba:	eb 81       	ldd	r30, Y+3	; 0x03
    47bc:	fc 81       	ldd	r31, Y+4	; 0x04
    47be:	96 89       	ldd	r25, Z+22	; 0x16
    47c0:	80 91 ee 06 	lds	r24, 0x06EE
    47c4:	89 17       	cp	r24, r25
    47c6:	28 f4       	brcc	.+10     	; 0x47d2 <xTaskGenericNotify+0x152>
    47c8:	eb 81       	ldd	r30, Y+3	; 0x03
    47ca:	fc 81       	ldd	r31, Y+4	; 0x04
    47cc:	86 89       	ldd	r24, Z+22	; 0x16
    47ce:	80 93 ee 06 	sts	0x06EE, r24
    47d2:	eb 81       	ldd	r30, Y+3	; 0x03
    47d4:	fc 81       	ldd	r31, Y+4	; 0x04
    47d6:	86 89       	ldd	r24, Z+22	; 0x16
    47d8:	28 2f       	mov	r18, r24
    47da:	30 e0       	ldi	r19, 0x00	; 0
    47dc:	c9 01       	movw	r24, r18
    47de:	88 0f       	add	r24, r24
    47e0:	99 1f       	adc	r25, r25
    47e2:	88 0f       	add	r24, r24
    47e4:	99 1f       	adc	r25, r25
    47e6:	88 0f       	add	r24, r24
    47e8:	99 1f       	adc	r25, r25
    47ea:	82 0f       	add	r24, r18
    47ec:	93 1f       	adc	r25, r19
    47ee:	ac 01       	movw	r20, r24
    47f0:	47 50       	subi	r20, 0x07	; 7
    47f2:	59 4f       	sbci	r21, 0xF9	; 249
    47f4:	8b 81       	ldd	r24, Y+3	; 0x03
    47f6:	9c 81       	ldd	r25, Y+4	; 0x04
    47f8:	9c 01       	movw	r18, r24
    47fa:	2e 5f       	subi	r18, 0xFE	; 254
    47fc:	3f 4f       	sbci	r19, 0xFF	; 255
    47fe:	ca 01       	movw	r24, r20
    4800:	b9 01       	movw	r22, r18
    4802:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4806:	eb 81       	ldd	r30, Y+3	; 0x03
    4808:	fc 81       	ldd	r31, Y+4	; 0x04
    480a:	96 89       	ldd	r25, Z+22	; 0x16
    480c:	e0 91 e8 06 	lds	r30, 0x06E8
    4810:	f0 91 e9 06 	lds	r31, 0x06E9
    4814:	86 89       	ldd	r24, Z+22	; 0x16
    4816:	89 17       	cp	r24, r25
    4818:	10 f4       	brcc	.+4      	; 0x481e <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    481a:	0e 94 ff 06 	call	0xdfe	; 0xdfe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    481e:	0f 90       	pop	r0
    4820:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4822:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4824:	2f 96       	adiw	r28, 0x0f	; 15
    4826:	0f b6       	in	r0, 0x3f	; 63
    4828:	f8 94       	cli
    482a:	de bf       	out	0x3e, r29	; 62
    482c:	0f be       	out	0x3f, r0	; 63
    482e:	cd bf       	out	0x3d, r28	; 61
    4830:	cf 91       	pop	r28
    4832:	df 91       	pop	r29
    4834:	1f 91       	pop	r17
    4836:	0f 91       	pop	r16
    4838:	08 95       	ret

0000483a <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    483a:	ef 92       	push	r14
    483c:	ff 92       	push	r15
    483e:	0f 93       	push	r16
    4840:	1f 93       	push	r17
    4842:	df 93       	push	r29
    4844:	cf 93       	push	r28
    4846:	cd b7       	in	r28, 0x3d	; 61
    4848:	de b7       	in	r29, 0x3e	; 62
    484a:	62 97       	sbiw	r28, 0x12	; 18
    484c:	0f b6       	in	r0, 0x3f	; 63
    484e:	f8 94       	cli
    4850:	de bf       	out	0x3e, r29	; 62
    4852:	0f be       	out	0x3f, r0	; 63
    4854:	cd bf       	out	0x3d, r28	; 61
    4856:	9f 83       	std	Y+7, r25	; 0x07
    4858:	8e 83       	std	Y+6, r24	; 0x06
    485a:	48 87       	std	Y+8, r20	; 0x08
    485c:	59 87       	std	Y+9, r21	; 0x09
    485e:	6a 87       	std	Y+10, r22	; 0x0a
    4860:	7b 87       	std	Y+11, r23	; 0x0b
    4862:	2c 87       	std	Y+12, r18	; 0x0c
    4864:	1e 87       	std	Y+14, r17	; 0x0e
    4866:	0d 87       	std	Y+13, r16	; 0x0d
    4868:	f8 8a       	std	Y+16, r15	; 0x10
    486a:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    486c:	81 e0       	ldi	r24, 0x01	; 1
    486e:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4870:	8e 81       	ldd	r24, Y+6	; 0x06
    4872:	9f 81       	ldd	r25, Y+7	; 0x07
    4874:	9d 83       	std	Y+5, r25	; 0x05
    4876:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4878:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    487a:	8d 85       	ldd	r24, Y+13	; 0x0d
    487c:	9e 85       	ldd	r25, Y+14	; 0x0e
    487e:	00 97       	sbiw	r24, 0x00	; 0
    4880:	61 f0       	breq	.+24     	; 0x489a <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4882:	ec 81       	ldd	r30, Y+4	; 0x04
    4884:	fd 81       	ldd	r31, Y+5	; 0x05
    4886:	83 a1       	ldd	r24, Z+35	; 0x23
    4888:	94 a1       	ldd	r25, Z+36	; 0x24
    488a:	a5 a1       	ldd	r26, Z+37	; 0x25
    488c:	b6 a1       	ldd	r27, Z+38	; 0x26
    488e:	ed 85       	ldd	r30, Y+13	; 0x0d
    4890:	fe 85       	ldd	r31, Y+14	; 0x0e
    4892:	80 83       	st	Z, r24
    4894:	91 83       	std	Z+1, r25	; 0x01
    4896:	a2 83       	std	Z+2, r26	; 0x02
    4898:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    489a:	ec 81       	ldd	r30, Y+4	; 0x04
    489c:	fd 81       	ldd	r31, Y+5	; 0x05
    489e:	87 a1       	ldd	r24, Z+39	; 0x27
    48a0:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    48a2:	ec 81       	ldd	r30, Y+4	; 0x04
    48a4:	fd 81       	ldd	r31, Y+5	; 0x05
    48a6:	82 e0       	ldi	r24, 0x02	; 2
    48a8:	87 a3       	std	Z+39, r24	; 0x27

			switch( eAction )
    48aa:	8c 85       	ldd	r24, Y+12	; 0x0c
    48ac:	28 2f       	mov	r18, r24
    48ae:	30 e0       	ldi	r19, 0x00	; 0
    48b0:	3a 8b       	std	Y+18, r19	; 0x12
    48b2:	29 8b       	std	Y+17, r18	; 0x11
    48b4:	89 89       	ldd	r24, Y+17	; 0x11
    48b6:	9a 89       	ldd	r25, Y+18	; 0x12
    48b8:	82 30       	cpi	r24, 0x02	; 2
    48ba:	91 05       	cpc	r25, r1
    48bc:	59 f1       	breq	.+86     	; 0x4914 <xTaskGenericNotifyFromISR+0xda>
    48be:	29 89       	ldd	r18, Y+17	; 0x11
    48c0:	3a 89       	ldd	r19, Y+18	; 0x12
    48c2:	23 30       	cpi	r18, 0x03	; 3
    48c4:	31 05       	cpc	r19, r1
    48c6:	34 f4       	brge	.+12     	; 0x48d4 <xTaskGenericNotifyFromISR+0x9a>
    48c8:	89 89       	ldd	r24, Y+17	; 0x11
    48ca:	9a 89       	ldd	r25, Y+18	; 0x12
    48cc:	81 30       	cpi	r24, 0x01	; 1
    48ce:	91 05       	cpc	r25, r1
    48d0:	61 f0       	breq	.+24     	; 0x48ea <xTaskGenericNotifyFromISR+0xb0>
    48d2:	4a c0       	rjmp	.+148    	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
    48d4:	29 89       	ldd	r18, Y+17	; 0x11
    48d6:	3a 89       	ldd	r19, Y+18	; 0x12
    48d8:	23 30       	cpi	r18, 0x03	; 3
    48da:	31 05       	cpc	r19, r1
    48dc:	59 f1       	breq	.+86     	; 0x4934 <xTaskGenericNotifyFromISR+0xfa>
    48de:	89 89       	ldd	r24, Y+17	; 0x11
    48e0:	9a 89       	ldd	r25, Y+18	; 0x12
    48e2:	84 30       	cpi	r24, 0x04	; 4
    48e4:	91 05       	cpc	r25, r1
    48e6:	89 f1       	breq	.+98     	; 0x494a <xTaskGenericNotifyFromISR+0x110>
    48e8:	3f c0       	rjmp	.+126    	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    48ea:	ec 81       	ldd	r30, Y+4	; 0x04
    48ec:	fd 81       	ldd	r31, Y+5	; 0x05
    48ee:	23 a1       	ldd	r18, Z+35	; 0x23
    48f0:	34 a1       	ldd	r19, Z+36	; 0x24
    48f2:	45 a1       	ldd	r20, Z+37	; 0x25
    48f4:	56 a1       	ldd	r21, Z+38	; 0x26
    48f6:	88 85       	ldd	r24, Y+8	; 0x08
    48f8:	99 85       	ldd	r25, Y+9	; 0x09
    48fa:	aa 85       	ldd	r26, Y+10	; 0x0a
    48fc:	bb 85       	ldd	r27, Y+11	; 0x0b
    48fe:	82 2b       	or	r24, r18
    4900:	93 2b       	or	r25, r19
    4902:	a4 2b       	or	r26, r20
    4904:	b5 2b       	or	r27, r21
    4906:	ec 81       	ldd	r30, Y+4	; 0x04
    4908:	fd 81       	ldd	r31, Y+5	; 0x05
    490a:	83 a3       	std	Z+35, r24	; 0x23
    490c:	94 a3       	std	Z+36, r25	; 0x24
    490e:	a5 a3       	std	Z+37, r26	; 0x25
    4910:	b6 a3       	std	Z+38, r27	; 0x26
    4912:	2a c0       	rjmp	.+84     	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4914:	ec 81       	ldd	r30, Y+4	; 0x04
    4916:	fd 81       	ldd	r31, Y+5	; 0x05
    4918:	83 a1       	ldd	r24, Z+35	; 0x23
    491a:	94 a1       	ldd	r25, Z+36	; 0x24
    491c:	a5 a1       	ldd	r26, Z+37	; 0x25
    491e:	b6 a1       	ldd	r27, Z+38	; 0x26
    4920:	01 96       	adiw	r24, 0x01	; 1
    4922:	a1 1d       	adc	r26, r1
    4924:	b1 1d       	adc	r27, r1
    4926:	ec 81       	ldd	r30, Y+4	; 0x04
    4928:	fd 81       	ldd	r31, Y+5	; 0x05
    492a:	83 a3       	std	Z+35, r24	; 0x23
    492c:	94 a3       	std	Z+36, r25	; 0x24
    492e:	a5 a3       	std	Z+37, r26	; 0x25
    4930:	b6 a3       	std	Z+38, r27	; 0x26
    4932:	1a c0       	rjmp	.+52     	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4934:	ec 81       	ldd	r30, Y+4	; 0x04
    4936:	fd 81       	ldd	r31, Y+5	; 0x05
    4938:	88 85       	ldd	r24, Y+8	; 0x08
    493a:	99 85       	ldd	r25, Y+9	; 0x09
    493c:	aa 85       	ldd	r26, Y+10	; 0x0a
    493e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4940:	83 a3       	std	Z+35, r24	; 0x23
    4942:	94 a3       	std	Z+36, r25	; 0x24
    4944:	a5 a3       	std	Z+37, r26	; 0x25
    4946:	b6 a3       	std	Z+38, r27	; 0x26
    4948:	0f c0       	rjmp	.+30     	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    494a:	8b 81       	ldd	r24, Y+3	; 0x03
    494c:	82 30       	cpi	r24, 0x02	; 2
    494e:	59 f0       	breq	.+22     	; 0x4966 <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4950:	ec 81       	ldd	r30, Y+4	; 0x04
    4952:	fd 81       	ldd	r31, Y+5	; 0x05
    4954:	88 85       	ldd	r24, Y+8	; 0x08
    4956:	99 85       	ldd	r25, Y+9	; 0x09
    4958:	aa 85       	ldd	r26, Y+10	; 0x0a
    495a:	bb 85       	ldd	r27, Y+11	; 0x0b
    495c:	83 a3       	std	Z+35, r24	; 0x23
    495e:	94 a3       	std	Z+36, r25	; 0x24
    4960:	a5 a3       	std	Z+37, r26	; 0x25
    4962:	b6 a3       	std	Z+38, r27	; 0x26
    4964:	01 c0       	rjmp	.+2      	; 0x4968 <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    4966:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4968:	8b 81       	ldd	r24, Y+3	; 0x03
    496a:	81 30       	cpi	r24, 0x01	; 1
    496c:	09 f0       	breq	.+2      	; 0x4970 <xTaskGenericNotifyFromISR+0x136>
    496e:	4f c0       	rjmp	.+158    	; 0x4a0e <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4970:	80 91 f8 06 	lds	r24, 0x06F8
    4974:	88 23       	and	r24, r24
    4976:	61 f5       	brne	.+88     	; 0x49d0 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4978:	8c 81       	ldd	r24, Y+4	; 0x04
    497a:	9d 81       	ldd	r25, Y+5	; 0x05
    497c:	02 96       	adiw	r24, 0x02	; 2
    497e:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4982:	ec 81       	ldd	r30, Y+4	; 0x04
    4984:	fd 81       	ldd	r31, Y+5	; 0x05
    4986:	96 89       	ldd	r25, Z+22	; 0x16
    4988:	80 91 ee 06 	lds	r24, 0x06EE
    498c:	89 17       	cp	r24, r25
    498e:	28 f4       	brcc	.+10     	; 0x499a <xTaskGenericNotifyFromISR+0x160>
    4990:	ec 81       	ldd	r30, Y+4	; 0x04
    4992:	fd 81       	ldd	r31, Y+5	; 0x05
    4994:	86 89       	ldd	r24, Z+22	; 0x16
    4996:	80 93 ee 06 	sts	0x06EE, r24
    499a:	ec 81       	ldd	r30, Y+4	; 0x04
    499c:	fd 81       	ldd	r31, Y+5	; 0x05
    499e:	86 89       	ldd	r24, Z+22	; 0x16
    49a0:	28 2f       	mov	r18, r24
    49a2:	30 e0       	ldi	r19, 0x00	; 0
    49a4:	c9 01       	movw	r24, r18
    49a6:	88 0f       	add	r24, r24
    49a8:	99 1f       	adc	r25, r25
    49aa:	88 0f       	add	r24, r24
    49ac:	99 1f       	adc	r25, r25
    49ae:	88 0f       	add	r24, r24
    49b0:	99 1f       	adc	r25, r25
    49b2:	82 0f       	add	r24, r18
    49b4:	93 1f       	adc	r25, r19
    49b6:	ac 01       	movw	r20, r24
    49b8:	47 50       	subi	r20, 0x07	; 7
    49ba:	59 4f       	sbci	r21, 0xF9	; 249
    49bc:	8c 81       	ldd	r24, Y+4	; 0x04
    49be:	9d 81       	ldd	r25, Y+5	; 0x05
    49c0:	9c 01       	movw	r18, r24
    49c2:	2e 5f       	subi	r18, 0xFE	; 254
    49c4:	3f 4f       	sbci	r19, 0xFF	; 255
    49c6:	ca 01       	movw	r24, r20
    49c8:	b9 01       	movw	r22, r18
    49ca:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    49ce:	0a c0       	rjmp	.+20     	; 0x49e4 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    49d0:	8c 81       	ldd	r24, Y+4	; 0x04
    49d2:	9d 81       	ldd	r25, Y+5	; 0x05
    49d4:	9c 01       	movw	r18, r24
    49d6:	24 5f       	subi	r18, 0xF4	; 244
    49d8:	3f 4f       	sbci	r19, 0xFF	; 255
    49da:	83 e3       	ldi	r24, 0x33	; 51
    49dc:	97 e0       	ldi	r25, 0x07	; 7
    49de:	b9 01       	movw	r22, r18
    49e0:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    49e4:	ec 81       	ldd	r30, Y+4	; 0x04
    49e6:	fd 81       	ldd	r31, Y+5	; 0x05
    49e8:	96 89       	ldd	r25, Z+22	; 0x16
    49ea:	e0 91 e8 06 	lds	r30, 0x06E8
    49ee:	f0 91 e9 06 	lds	r31, 0x06E9
    49f2:	86 89       	ldd	r24, Z+22	; 0x16
    49f4:	89 17       	cp	r24, r25
    49f6:	58 f4       	brcc	.+22     	; 0x4a0e <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    49f8:	8f 85       	ldd	r24, Y+15	; 0x0f
    49fa:	98 89       	ldd	r25, Y+16	; 0x10
    49fc:	00 97       	sbiw	r24, 0x00	; 0
    49fe:	21 f0       	breq	.+8      	; 0x4a08 <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4a00:	ef 85       	ldd	r30, Y+15	; 0x0f
    4a02:	f8 89       	ldd	r31, Y+16	; 0x10
    4a04:	81 e0       	ldi	r24, 0x01	; 1
    4a06:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4a08:	81 e0       	ldi	r24, 0x01	; 1
    4a0a:	80 93 f1 06 	sts	0x06F1, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4a0e:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4a10:	62 96       	adiw	r28, 0x12	; 18
    4a12:	0f b6       	in	r0, 0x3f	; 63
    4a14:	f8 94       	cli
    4a16:	de bf       	out	0x3e, r29	; 62
    4a18:	0f be       	out	0x3f, r0	; 63
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	cf 91       	pop	r28
    4a1e:	df 91       	pop	r29
    4a20:	1f 91       	pop	r17
    4a22:	0f 91       	pop	r16
    4a24:	ff 90       	pop	r15
    4a26:	ef 90       	pop	r14
    4a28:	08 95       	ret

00004a2a <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    4a2a:	df 93       	push	r29
    4a2c:	cf 93       	push	r28
    4a2e:	cd b7       	in	r28, 0x3d	; 61
    4a30:	de b7       	in	r29, 0x3e	; 62
    4a32:	28 97       	sbiw	r28, 0x08	; 8
    4a34:	0f b6       	in	r0, 0x3f	; 63
    4a36:	f8 94       	cli
    4a38:	de bf       	out	0x3e, r29	; 62
    4a3a:	0f be       	out	0x3f, r0	; 63
    4a3c:	cd bf       	out	0x3d, r28	; 61
    4a3e:	9e 83       	std	Y+6, r25	; 0x06
    4a40:	8d 83       	std	Y+5, r24	; 0x05
    4a42:	78 87       	std	Y+8, r23	; 0x08
    4a44:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4a46:	8d 81       	ldd	r24, Y+5	; 0x05
    4a48:	9e 81       	ldd	r25, Y+6	; 0x06
    4a4a:	9c 83       	std	Y+4, r25	; 0x04
    4a4c:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4a4e:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4a50:	eb 81       	ldd	r30, Y+3	; 0x03
    4a52:	fc 81       	ldd	r31, Y+4	; 0x04
    4a54:	87 a1       	ldd	r24, Z+39	; 0x27
    4a56:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    4a58:	eb 81       	ldd	r30, Y+3	; 0x03
    4a5a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a5c:	82 e0       	ldi	r24, 0x02	; 2
    4a5e:	87 a3       	std	Z+39, r24	; 0x27

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4a60:	eb 81       	ldd	r30, Y+3	; 0x03
    4a62:	fc 81       	ldd	r31, Y+4	; 0x04
    4a64:	83 a1       	ldd	r24, Z+35	; 0x23
    4a66:	94 a1       	ldd	r25, Z+36	; 0x24
    4a68:	a5 a1       	ldd	r26, Z+37	; 0x25
    4a6a:	b6 a1       	ldd	r27, Z+38	; 0x26
    4a6c:	01 96       	adiw	r24, 0x01	; 1
    4a6e:	a1 1d       	adc	r26, r1
    4a70:	b1 1d       	adc	r27, r1
    4a72:	eb 81       	ldd	r30, Y+3	; 0x03
    4a74:	fc 81       	ldd	r31, Y+4	; 0x04
    4a76:	83 a3       	std	Z+35, r24	; 0x23
    4a78:	94 a3       	std	Z+36, r25	; 0x24
    4a7a:	a5 a3       	std	Z+37, r26	; 0x25
    4a7c:	b6 a3       	std	Z+38, r27	; 0x26

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4a7e:	8a 81       	ldd	r24, Y+2	; 0x02
    4a80:	81 30       	cpi	r24, 0x01	; 1
    4a82:	09 f0       	breq	.+2      	; 0x4a86 <vTaskNotifyGiveFromISR+0x5c>
    4a84:	4f c0       	rjmp	.+158    	; 0x4b24 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4a86:	80 91 f8 06 	lds	r24, 0x06F8
    4a8a:	88 23       	and	r24, r24
    4a8c:	61 f5       	brne	.+88     	; 0x4ae6 <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    4a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    4a90:	9c 81       	ldd	r25, Y+4	; 0x04
    4a92:	02 96       	adiw	r24, 0x02	; 2
    4a94:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4a98:	eb 81       	ldd	r30, Y+3	; 0x03
    4a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    4a9c:	96 89       	ldd	r25, Z+22	; 0x16
    4a9e:	80 91 ee 06 	lds	r24, 0x06EE
    4aa2:	89 17       	cp	r24, r25
    4aa4:	28 f4       	brcc	.+10     	; 0x4ab0 <vTaskNotifyGiveFromISR+0x86>
    4aa6:	eb 81       	ldd	r30, Y+3	; 0x03
    4aa8:	fc 81       	ldd	r31, Y+4	; 0x04
    4aaa:	86 89       	ldd	r24, Z+22	; 0x16
    4aac:	80 93 ee 06 	sts	0x06EE, r24
    4ab0:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab2:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab4:	86 89       	ldd	r24, Z+22	; 0x16
    4ab6:	28 2f       	mov	r18, r24
    4ab8:	30 e0       	ldi	r19, 0x00	; 0
    4aba:	c9 01       	movw	r24, r18
    4abc:	88 0f       	add	r24, r24
    4abe:	99 1f       	adc	r25, r25
    4ac0:	88 0f       	add	r24, r24
    4ac2:	99 1f       	adc	r25, r25
    4ac4:	88 0f       	add	r24, r24
    4ac6:	99 1f       	adc	r25, r25
    4ac8:	82 0f       	add	r24, r18
    4aca:	93 1f       	adc	r25, r19
    4acc:	ac 01       	movw	r20, r24
    4ace:	47 50       	subi	r20, 0x07	; 7
    4ad0:	59 4f       	sbci	r21, 0xF9	; 249
    4ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad6:	9c 01       	movw	r18, r24
    4ad8:	2e 5f       	subi	r18, 0xFE	; 254
    4ada:	3f 4f       	sbci	r19, 0xFF	; 255
    4adc:	ca 01       	movw	r24, r20
    4ade:	b9 01       	movw	r22, r18
    4ae0:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4ae4:	0a c0       	rjmp	.+20     	; 0x4afa <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    4ae6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ae8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aea:	9c 01       	movw	r18, r24
    4aec:	24 5f       	subi	r18, 0xF4	; 244
    4aee:	3f 4f       	sbci	r19, 0xFF	; 255
    4af0:	83 e3       	ldi	r24, 0x33	; 51
    4af2:	97 e0       	ldi	r25, 0x07	; 7
    4af4:	b9 01       	movw	r22, r18
    4af6:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4afa:	eb 81       	ldd	r30, Y+3	; 0x03
    4afc:	fc 81       	ldd	r31, Y+4	; 0x04
    4afe:	96 89       	ldd	r25, Z+22	; 0x16
    4b00:	e0 91 e8 06 	lds	r30, 0x06E8
    4b04:	f0 91 e9 06 	lds	r31, 0x06E9
    4b08:	86 89       	ldd	r24, Z+22	; 0x16
    4b0a:	89 17       	cp	r24, r25
    4b0c:	58 f4       	brcc	.+22     	; 0x4b24 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4b0e:	8f 81       	ldd	r24, Y+7	; 0x07
    4b10:	98 85       	ldd	r25, Y+8	; 0x08
    4b12:	00 97       	sbiw	r24, 0x00	; 0
    4b14:	21 f0       	breq	.+8      	; 0x4b1e <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4b16:	ef 81       	ldd	r30, Y+7	; 0x07
    4b18:	f8 85       	ldd	r31, Y+8	; 0x08
    4b1a:	81 e0       	ldi	r24, 0x01	; 1
    4b1c:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4b1e:	81 e0       	ldi	r24, 0x01	; 1
    4b20:	80 93 f1 06 	sts	0x06F1, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4b24:	28 96       	adiw	r28, 0x08	; 8
    4b26:	0f b6       	in	r0, 0x3f	; 63
    4b28:	f8 94       	cli
    4b2a:	de bf       	out	0x3e, r29	; 62
    4b2c:	0f be       	out	0x3f, r0	; 63
    4b2e:	cd bf       	out	0x3d, r28	; 61
    4b30:	cf 91       	pop	r28
    4b32:	df 91       	pop	r29
    4b34:	08 95       	ret

00004b36 <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    4b36:	df 93       	push	r29
    4b38:	cf 93       	push	r28
    4b3a:	cd b7       	in	r28, 0x3d	; 61
    4b3c:	de b7       	in	r29, 0x3e	; 62
    4b3e:	27 97       	sbiw	r28, 0x07	; 7
    4b40:	0f b6       	in	r0, 0x3f	; 63
    4b42:	f8 94       	cli
    4b44:	de bf       	out	0x3e, r29	; 62
    4b46:	0f be       	out	0x3f, r0	; 63
    4b48:	cd bf       	out	0x3d, r28	; 61
    4b4a:	9d 83       	std	Y+5, r25	; 0x05
    4b4c:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4b4e:	8c 81       	ldd	r24, Y+4	; 0x04
    4b50:	9d 81       	ldd	r25, Y+5	; 0x05
    4b52:	00 97       	sbiw	r24, 0x00	; 0
    4b54:	39 f4       	brne	.+14     	; 0x4b64 <xTaskNotifyStateClear+0x2e>
    4b56:	80 91 e8 06 	lds	r24, 0x06E8
    4b5a:	90 91 e9 06 	lds	r25, 0x06E9
    4b5e:	9f 83       	std	Y+7, r25	; 0x07
    4b60:	8e 83       	std	Y+6, r24	; 0x06
    4b62:	04 c0       	rjmp	.+8      	; 0x4b6c <xTaskNotifyStateClear+0x36>
    4b64:	8c 81       	ldd	r24, Y+4	; 0x04
    4b66:	9d 81       	ldd	r25, Y+5	; 0x05
    4b68:	9f 83       	std	Y+7, r25	; 0x07
    4b6a:	8e 83       	std	Y+6, r24	; 0x06
    4b6c:	8e 81       	ldd	r24, Y+6	; 0x06
    4b6e:	9f 81       	ldd	r25, Y+7	; 0x07
    4b70:	9b 83       	std	Y+3, r25	; 0x03
    4b72:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4b74:	0f b6       	in	r0, 0x3f	; 63
    4b76:	f8 94       	cli
    4b78:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    4b7a:	ea 81       	ldd	r30, Y+2	; 0x02
    4b7c:	fb 81       	ldd	r31, Y+3	; 0x03
    4b7e:	87 a1       	ldd	r24, Z+39	; 0x27
    4b80:	82 30       	cpi	r24, 0x02	; 2
    4b82:	31 f4       	brne	.+12     	; 0x4b90 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4b84:	ea 81       	ldd	r30, Y+2	; 0x02
    4b86:	fb 81       	ldd	r31, Y+3	; 0x03
    4b88:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    4b8a:	81 e0       	ldi	r24, 0x01	; 1
    4b8c:	89 83       	std	Y+1, r24	; 0x01
    4b8e:	01 c0       	rjmp	.+2      	; 0x4b92 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    4b90:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    4b92:	0f 90       	pop	r0
    4b94:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4b96:	89 81       	ldd	r24, Y+1	; 0x01
	}
    4b98:	27 96       	adiw	r28, 0x07	; 7
    4b9a:	0f b6       	in	r0, 0x3f	; 63
    4b9c:	f8 94       	cli
    4b9e:	de bf       	out	0x3e, r29	; 62
    4ba0:	0f be       	out	0x3f, r0	; 63
    4ba2:	cd bf       	out	0x3d, r28	; 61
    4ba4:	cf 91       	pop	r28
    4ba6:	df 91       	pop	r29
    4ba8:	08 95       	ret

00004baa <prvAddCurrentTaskToDelayedList>:
	}
#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4baa:	df 93       	push	r29
    4bac:	cf 93       	push	r28
    4bae:	cd b7       	in	r28, 0x3d	; 61
    4bb0:	de b7       	in	r29, 0x3e	; 62
    4bb2:	27 97       	sbiw	r28, 0x07	; 7
    4bb4:	0f b6       	in	r0, 0x3f	; 63
    4bb6:	f8 94       	cli
    4bb8:	de bf       	out	0x3e, r29	; 62
    4bba:	0f be       	out	0x3f, r0	; 63
    4bbc:	cd bf       	out	0x3d, r28	; 61
    4bbe:	9e 83       	std	Y+6, r25	; 0x06
    4bc0:	8d 83       	std	Y+5, r24	; 0x05
    4bc2:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    4bc4:	80 91 ec 06 	lds	r24, 0x06EC
    4bc8:	90 91 ed 06 	lds	r25, 0x06ED
    4bcc:	9a 83       	std	Y+2, r25	; 0x02
    4bce:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    4bd0:	80 91 e8 06 	lds	r24, 0x06E8
    4bd4:	90 91 e9 06 	lds	r25, 0x06E9
    4bd8:	02 96       	adiw	r24, 0x02	; 2
    4bda:	0e 94 f4 04 	call	0x9e8	; 0x9e8 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    4bde:	8d 81       	ldd	r24, Y+5	; 0x05
    4be0:	9e 81       	ldd	r25, Y+6	; 0x06
    4be2:	2f ef       	ldi	r18, 0xFF	; 255
    4be4:	8f 3f       	cpi	r24, 0xFF	; 255
    4be6:	92 07       	cpc	r25, r18
    4be8:	81 f4       	brne	.+32     	; 0x4c0a <prvAddCurrentTaskToDelayedList+0x60>
    4bea:	8f 81       	ldd	r24, Y+7	; 0x07
    4bec:	88 23       	and	r24, r24
    4bee:	69 f0       	breq	.+26     	; 0x4c0a <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4bf0:	80 91 e8 06 	lds	r24, 0x06E8
    4bf4:	90 91 e9 06 	lds	r25, 0x06E9
    4bf8:	9c 01       	movw	r18, r24
    4bfa:	2e 5f       	subi	r18, 0xFE	; 254
    4bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    4bfe:	85 e4       	ldi	r24, 0x45	; 69
    4c00:	97 e0       	ldi	r25, 0x07	; 7
    4c02:	b9 01       	movw	r22, r18
    4c04:	0e 94 44 04 	call	0x888	; 0x888 <vListInsertEnd>
    4c08:	43 c0       	rjmp	.+134    	; 0x4c90 <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    4c0a:	29 81       	ldd	r18, Y+1	; 0x01
    4c0c:	3a 81       	ldd	r19, Y+2	; 0x02
    4c0e:	8d 81       	ldd	r24, Y+5	; 0x05
    4c10:	9e 81       	ldd	r25, Y+6	; 0x06
    4c12:	82 0f       	add	r24, r18
    4c14:	93 1f       	adc	r25, r19
    4c16:	9c 83       	std	Y+4, r25	; 0x04
    4c18:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    4c1a:	e0 91 e8 06 	lds	r30, 0x06E8
    4c1e:	f0 91 e9 06 	lds	r31, 0x06E9
    4c22:	8b 81       	ldd	r24, Y+3	; 0x03
    4c24:	9c 81       	ldd	r25, Y+4	; 0x04
    4c26:	93 83       	std	Z+3, r25	; 0x03
    4c28:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    4c2a:	2b 81       	ldd	r18, Y+3	; 0x03
    4c2c:	3c 81       	ldd	r19, Y+4	; 0x04
    4c2e:	89 81       	ldd	r24, Y+1	; 0x01
    4c30:	9a 81       	ldd	r25, Y+2	; 0x02
    4c32:	28 17       	cp	r18, r24
    4c34:	39 07       	cpc	r19, r25
    4c36:	70 f4       	brcc	.+28     	; 0x4c54 <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4c38:	80 91 31 07 	lds	r24, 0x0731
    4c3c:	90 91 32 07 	lds	r25, 0x0732
    4c40:	20 91 e8 06 	lds	r18, 0x06E8
    4c44:	30 91 e9 06 	lds	r19, 0x06E9
    4c48:	2e 5f       	subi	r18, 0xFE	; 254
    4c4a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c4c:	b9 01       	movw	r22, r18
    4c4e:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>
    4c52:	1e c0       	rjmp	.+60     	; 0x4c90 <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4c54:	40 91 2f 07 	lds	r20, 0x072F
    4c58:	50 91 30 07 	lds	r21, 0x0730
    4c5c:	80 91 e8 06 	lds	r24, 0x06E8
    4c60:	90 91 e9 06 	lds	r25, 0x06E9
    4c64:	9c 01       	movw	r18, r24
    4c66:	2e 5f       	subi	r18, 0xFE	; 254
    4c68:	3f 4f       	sbci	r19, 0xFF	; 255
    4c6a:	ca 01       	movw	r24, r20
    4c6c:	b9 01       	movw	r22, r18
    4c6e:	0e 94 88 04 	call	0x910	; 0x910 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    4c72:	20 91 f4 06 	lds	r18, 0x06F4
    4c76:	30 91 f5 06 	lds	r19, 0x06F5
    4c7a:	8b 81       	ldd	r24, Y+3	; 0x03
    4c7c:	9c 81       	ldd	r25, Y+4	; 0x04
    4c7e:	82 17       	cp	r24, r18
    4c80:	93 07       	cpc	r25, r19
    4c82:	30 f4       	brcc	.+12     	; 0x4c90 <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    4c84:	8b 81       	ldd	r24, Y+3	; 0x03
    4c86:	9c 81       	ldd	r25, Y+4	; 0x04
    4c88:	90 93 f5 06 	sts	0x06F5, r25
    4c8c:	80 93 f4 06 	sts	0x06F4, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4c90:	27 96       	adiw	r28, 0x07	; 7
    4c92:	0f b6       	in	r0, 0x3f	; 63
    4c94:	f8 94       	cli
    4c96:	de bf       	out	0x3e, r29	; 62
    4c98:	0f be       	out	0x3f, r0	; 63
    4c9a:	cd bf       	out	0x3d, r28	; 61
    4c9c:	cf 91       	pop	r28
    4c9e:	df 91       	pop	r29
    4ca0:	08 95       	ret

00004ca2 <DIO_Init>:
 *      Author: abdelqader
 */

#include"DIO.h"

STD_Fun_t DIO_Init(void) {
    4ca2:	df 93       	push	r29
    4ca4:	cf 93       	push	r28
    4ca6:	00 d0       	rcall	.+0      	; 0x4ca8 <DIO_Init+0x6>
    4ca8:	00 d0       	rcall	.+0      	; 0x4caa <DIO_Init+0x8>
    4caa:	cd b7       	in	r28, 0x3d	; 61
    4cac:	de b7       	in	r29, 0x3e	; 62

	STD_Fun_t RetVal = OK;
    4cae:	81 e0       	ldi	r24, 0x01	; 1
    4cb0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t LoopIndex;

	if (NUM_PINS <= MAX_NUM_PINS) {

		for (LoopIndex = 0; LoopIndex < NUM_PINS; LoopIndex++) {
    4cb2:	19 82       	std	Y+1, r1	; 0x01
    4cb4:	9c c5       	rjmp	.+2872   	; 0x57ee <DIO_Init+0xb4c>
			DIO_Array[LoopIndex].IS_Init = INITIALIZED;
    4cb6:	89 81       	ldd	r24, Y+1	; 0x01
    4cb8:	28 2f       	mov	r18, r24
    4cba:	30 e0       	ldi	r19, 0x00	; 0
    4cbc:	c9 01       	movw	r24, r18
    4cbe:	88 0f       	add	r24, r24
    4cc0:	99 1f       	adc	r25, r25
    4cc2:	82 0f       	add	r24, r18
    4cc4:	93 1f       	adc	r25, r19
    4cc6:	88 0f       	add	r24, r24
    4cc8:	99 1f       	adc	r25, r25
    4cca:	fc 01       	movw	r30, r24
    4ccc:	e5 53       	subi	r30, 0x35	; 53
    4cce:	ff 4f       	sbci	r31, 0xFF	; 255
    4cd0:	81 e0       	ldi	r24, 0x01	; 1
    4cd2:	80 83       	st	Z, r24

			switch (DIO_Array[LoopIndex].PORT) {
    4cd4:	89 81       	ldd	r24, Y+1	; 0x01
    4cd6:	28 2f       	mov	r18, r24
    4cd8:	30 e0       	ldi	r19, 0x00	; 0
    4cda:	c9 01       	movw	r24, r18
    4cdc:	88 0f       	add	r24, r24
    4cde:	99 1f       	adc	r25, r25
    4ce0:	82 0f       	add	r24, r18
    4ce2:	93 1f       	adc	r25, r19
    4ce4:	88 0f       	add	r24, r24
    4ce6:	99 1f       	adc	r25, r25
    4ce8:	fc 01       	movw	r30, r24
    4cea:	ea 53       	subi	r30, 0x3A	; 58
    4cec:	ff 4f       	sbci	r31, 0xFF	; 255
    4cee:	80 81       	ld	r24, Z
    4cf0:	28 2f       	mov	r18, r24
    4cf2:	30 e0       	ldi	r19, 0x00	; 0
    4cf4:	3c 83       	std	Y+4, r19	; 0x04
    4cf6:	2b 83       	std	Y+3, r18	; 0x03
    4cf8:	8b 81       	ldd	r24, Y+3	; 0x03
    4cfa:	9c 81       	ldd	r25, Y+4	; 0x04
    4cfc:	81 30       	cpi	r24, 0x01	; 1
    4cfe:	91 05       	cpc	r25, r1
    4d00:	09 f4       	brne	.+2      	; 0x4d04 <DIO_Init+0x62>
    4d02:	6a c1       	rjmp	.+724    	; 0x4fd8 <DIO_Init+0x336>
    4d04:	2b 81       	ldd	r18, Y+3	; 0x03
    4d06:	3c 81       	ldd	r19, Y+4	; 0x04
    4d08:	22 30       	cpi	r18, 0x02	; 2
    4d0a:	31 05       	cpc	r19, r1
    4d0c:	2c f4       	brge	.+10     	; 0x4d18 <DIO_Init+0x76>
    4d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    4d10:	9c 81       	ldd	r25, Y+4	; 0x04
    4d12:	00 97       	sbiw	r24, 0x00	; 0
    4d14:	71 f0       	breq	.+28     	; 0x4d32 <DIO_Init+0x90>
    4d16:	59 c5       	rjmp	.+2738   	; 0x57ca <DIO_Init+0xb28>
    4d18:	2b 81       	ldd	r18, Y+3	; 0x03
    4d1a:	3c 81       	ldd	r19, Y+4	; 0x04
    4d1c:	22 30       	cpi	r18, 0x02	; 2
    4d1e:	31 05       	cpc	r19, r1
    4d20:	09 f4       	brne	.+2      	; 0x4d24 <DIO_Init+0x82>
    4d22:	ad c2       	rjmp	.+1370   	; 0x527e <DIO_Init+0x5dc>
    4d24:	8b 81       	ldd	r24, Y+3	; 0x03
    4d26:	9c 81       	ldd	r25, Y+4	; 0x04
    4d28:	83 30       	cpi	r24, 0x03	; 3
    4d2a:	91 05       	cpc	r25, r1
    4d2c:	09 f4       	brne	.+2      	; 0x4d30 <DIO_Init+0x8e>
    4d2e:	fa c3       	rjmp	.+2036   	; 0x5524 <DIO_Init+0x882>
    4d30:	4c c5       	rjmp	.+2712   	; 0x57ca <DIO_Init+0xb28>

				case PORT_A:

				if (DIO_Array[LoopIndex].Dir == OUTPUT) {
    4d32:	89 81       	ldd	r24, Y+1	; 0x01
    4d34:	28 2f       	mov	r18, r24
    4d36:	30 e0       	ldi	r19, 0x00	; 0
    4d38:	c9 01       	movw	r24, r18
    4d3a:	88 0f       	add	r24, r24
    4d3c:	99 1f       	adc	r25, r25
    4d3e:	82 0f       	add	r24, r18
    4d40:	93 1f       	adc	r25, r19
    4d42:	01 96       	adiw	r24, 0x01	; 1
    4d44:	88 0f       	add	r24, r24
    4d46:	99 1f       	adc	r25, r25
    4d48:	fc 01       	movw	r30, r24
    4d4a:	ea 53       	subi	r30, 0x3A	; 58
    4d4c:	ff 4f       	sbci	r31, 0xFF	; 255
    4d4e:	80 81       	ld	r24, Z
    4d50:	81 30       	cpi	r24, 0x01	; 1
    4d52:	09 f0       	breq	.+2      	; 0x4d56 <DIO_Init+0xb4>
    4d54:	8f c0       	rjmp	.+286    	; 0x4e74 <DIO_Init+0x1d2>
					DDRA |= (1u << DIO_Array[LoopIndex].PIN);
    4d56:	aa e3       	ldi	r26, 0x3A	; 58
    4d58:	b0 e0       	ldi	r27, 0x00	; 0
    4d5a:	ea e3       	ldi	r30, 0x3A	; 58
    4d5c:	f0 e0       	ldi	r31, 0x00	; 0
    4d5e:	40 81       	ld	r20, Z
    4d60:	89 81       	ldd	r24, Y+1	; 0x01
    4d62:	28 2f       	mov	r18, r24
    4d64:	30 e0       	ldi	r19, 0x00	; 0
    4d66:	c9 01       	movw	r24, r18
    4d68:	88 0f       	add	r24, r24
    4d6a:	99 1f       	adc	r25, r25
    4d6c:	82 0f       	add	r24, r18
    4d6e:	93 1f       	adc	r25, r19
    4d70:	88 0f       	add	r24, r24
    4d72:	99 1f       	adc	r25, r25
    4d74:	fc 01       	movw	r30, r24
    4d76:	e9 53       	subi	r30, 0x39	; 57
    4d78:	ff 4f       	sbci	r31, 0xFF	; 255
    4d7a:	80 81       	ld	r24, Z
    4d7c:	28 2f       	mov	r18, r24
    4d7e:	30 e0       	ldi	r19, 0x00	; 0
    4d80:	81 e0       	ldi	r24, 0x01	; 1
    4d82:	90 e0       	ldi	r25, 0x00	; 0
    4d84:	02 c0       	rjmp	.+4      	; 0x4d8a <DIO_Init+0xe8>
    4d86:	88 0f       	add	r24, r24
    4d88:	99 1f       	adc	r25, r25
    4d8a:	2a 95       	dec	r18
    4d8c:	e2 f7       	brpl	.-8      	; 0x4d86 <DIO_Init+0xe4>
    4d8e:	84 2b       	or	r24, r20
    4d90:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Val == HIGH) {
    4d92:	89 81       	ldd	r24, Y+1	; 0x01
    4d94:	28 2f       	mov	r18, r24
    4d96:	30 e0       	ldi	r19, 0x00	; 0
    4d98:	c9 01       	movw	r24, r18
    4d9a:	88 0f       	add	r24, r24
    4d9c:	99 1f       	adc	r25, r25
    4d9e:	82 0f       	add	r24, r18
    4da0:	93 1f       	adc	r25, r19
    4da2:	88 0f       	add	r24, r24
    4da4:	99 1f       	adc	r25, r25
    4da6:	fc 01       	movw	r30, r24
    4da8:	e7 53       	subi	r30, 0x37	; 55
    4daa:	ff 4f       	sbci	r31, 0xFF	; 255
    4dac:	80 81       	ld	r24, Z
    4dae:	81 30       	cpi	r24, 0x01	; 1
    4db0:	01 f5       	brne	.+64     	; 0x4df2 <DIO_Init+0x150>
						PORTA |= (1u << DIO_Array[LoopIndex].PIN);
    4db2:	ab e3       	ldi	r26, 0x3B	; 59
    4db4:	b0 e0       	ldi	r27, 0x00	; 0
    4db6:	eb e3       	ldi	r30, 0x3B	; 59
    4db8:	f0 e0       	ldi	r31, 0x00	; 0
    4dba:	40 81       	ld	r20, Z
    4dbc:	89 81       	ldd	r24, Y+1	; 0x01
    4dbe:	28 2f       	mov	r18, r24
    4dc0:	30 e0       	ldi	r19, 0x00	; 0
    4dc2:	c9 01       	movw	r24, r18
    4dc4:	88 0f       	add	r24, r24
    4dc6:	99 1f       	adc	r25, r25
    4dc8:	82 0f       	add	r24, r18
    4dca:	93 1f       	adc	r25, r19
    4dcc:	88 0f       	add	r24, r24
    4dce:	99 1f       	adc	r25, r25
    4dd0:	fc 01       	movw	r30, r24
    4dd2:	e9 53       	subi	r30, 0x39	; 57
    4dd4:	ff 4f       	sbci	r31, 0xFF	; 255
    4dd6:	80 81       	ld	r24, Z
    4dd8:	28 2f       	mov	r18, r24
    4dda:	30 e0       	ldi	r19, 0x00	; 0
    4ddc:	81 e0       	ldi	r24, 0x01	; 1
    4dde:	90 e0       	ldi	r25, 0x00	; 0
    4de0:	02 2e       	mov	r0, r18
    4de2:	02 c0       	rjmp	.+4      	; 0x4de8 <DIO_Init+0x146>
    4de4:	88 0f       	add	r24, r24
    4de6:	99 1f       	adc	r25, r25
    4de8:	0a 94       	dec	r0
    4dea:	e2 f7       	brpl	.-8      	; 0x4de4 <DIO_Init+0x142>
    4dec:	84 2b       	or	r24, r20
    4dee:	8c 93       	st	X, r24
    4df0:	fb c4       	rjmp	.+2550   	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Val == LOW) {
    4df2:	89 81       	ldd	r24, Y+1	; 0x01
    4df4:	28 2f       	mov	r18, r24
    4df6:	30 e0       	ldi	r19, 0x00	; 0
    4df8:	c9 01       	movw	r24, r18
    4dfa:	88 0f       	add	r24, r24
    4dfc:	99 1f       	adc	r25, r25
    4dfe:	82 0f       	add	r24, r18
    4e00:	93 1f       	adc	r25, r19
    4e02:	88 0f       	add	r24, r24
    4e04:	99 1f       	adc	r25, r25
    4e06:	fc 01       	movw	r30, r24
    4e08:	e7 53       	subi	r30, 0x37	; 55
    4e0a:	ff 4f       	sbci	r31, 0xFF	; 255
    4e0c:	80 81       	ld	r24, Z
    4e0e:	88 23       	and	r24, r24
    4e10:	09 f5       	brne	.+66     	; 0x4e54 <DIO_Init+0x1b2>
						PORTA &= ~(1u << DIO_Array[LoopIndex].PIN);
    4e12:	ab e3       	ldi	r26, 0x3B	; 59
    4e14:	b0 e0       	ldi	r27, 0x00	; 0
    4e16:	eb e3       	ldi	r30, 0x3B	; 59
    4e18:	f0 e0       	ldi	r31, 0x00	; 0
    4e1a:	40 81       	ld	r20, Z
    4e1c:	89 81       	ldd	r24, Y+1	; 0x01
    4e1e:	28 2f       	mov	r18, r24
    4e20:	30 e0       	ldi	r19, 0x00	; 0
    4e22:	c9 01       	movw	r24, r18
    4e24:	88 0f       	add	r24, r24
    4e26:	99 1f       	adc	r25, r25
    4e28:	82 0f       	add	r24, r18
    4e2a:	93 1f       	adc	r25, r19
    4e2c:	88 0f       	add	r24, r24
    4e2e:	99 1f       	adc	r25, r25
    4e30:	fc 01       	movw	r30, r24
    4e32:	e9 53       	subi	r30, 0x39	; 57
    4e34:	ff 4f       	sbci	r31, 0xFF	; 255
    4e36:	80 81       	ld	r24, Z
    4e38:	28 2f       	mov	r18, r24
    4e3a:	30 e0       	ldi	r19, 0x00	; 0
    4e3c:	81 e0       	ldi	r24, 0x01	; 1
    4e3e:	90 e0       	ldi	r25, 0x00	; 0
    4e40:	02 2e       	mov	r0, r18
    4e42:	02 c0       	rjmp	.+4      	; 0x4e48 <DIO_Init+0x1a6>
    4e44:	88 0f       	add	r24, r24
    4e46:	99 1f       	adc	r25, r25
    4e48:	0a 94       	dec	r0
    4e4a:	e2 f7       	brpl	.-8      	; 0x4e44 <DIO_Init+0x1a2>
    4e4c:	80 95       	com	r24
    4e4e:	84 23       	and	r24, r20
    4e50:	8c 93       	st	X, r24
    4e52:	ca c4       	rjmp	.+2452   	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    4e54:	89 81       	ldd	r24, Y+1	; 0x01
    4e56:	28 2f       	mov	r18, r24
    4e58:	30 e0       	ldi	r19, 0x00	; 0
    4e5a:	c9 01       	movw	r24, r18
    4e5c:	88 0f       	add	r24, r24
    4e5e:	99 1f       	adc	r25, r25
    4e60:	82 0f       	add	r24, r18
    4e62:	93 1f       	adc	r25, r19
    4e64:	88 0f       	add	r24, r24
    4e66:	99 1f       	adc	r25, r25
    4e68:	fc 01       	movw	r30, r24
    4e6a:	e5 53       	subi	r30, 0x35	; 53
    4e6c:	ff 4f       	sbci	r31, 0xFF	; 255
    4e6e:	10 82       	st	Z, r1
						RetVal = NOK;
    4e70:	1a 82       	std	Y+2, r1	; 0x02
    4e72:	ba c4       	rjmp	.+2420   	; 0x57e8 <DIO_Init+0xb46>
					}
					} else if (DIO_Array[LoopIndex].Dir == INPUT) {
    4e74:	89 81       	ldd	r24, Y+1	; 0x01
    4e76:	28 2f       	mov	r18, r24
    4e78:	30 e0       	ldi	r19, 0x00	; 0
    4e7a:	c9 01       	movw	r24, r18
    4e7c:	88 0f       	add	r24, r24
    4e7e:	99 1f       	adc	r25, r25
    4e80:	82 0f       	add	r24, r18
    4e82:	93 1f       	adc	r25, r19
    4e84:	01 96       	adiw	r24, 0x01	; 1
    4e86:	88 0f       	add	r24, r24
    4e88:	99 1f       	adc	r25, r25
    4e8a:	fc 01       	movw	r30, r24
    4e8c:	ea 53       	subi	r30, 0x3A	; 58
    4e8e:	ff 4f       	sbci	r31, 0xFF	; 255
    4e90:	80 81       	ld	r24, Z
    4e92:	88 23       	and	r24, r24
    4e94:	09 f0       	breq	.+2      	; 0x4e98 <DIO_Init+0x1f6>
    4e96:	90 c0       	rjmp	.+288    	; 0x4fb8 <DIO_Init+0x316>
					DDRA &= ~(1u << DIO_Array[LoopIndex].PIN);
    4e98:	aa e3       	ldi	r26, 0x3A	; 58
    4e9a:	b0 e0       	ldi	r27, 0x00	; 0
    4e9c:	ea e3       	ldi	r30, 0x3A	; 58
    4e9e:	f0 e0       	ldi	r31, 0x00	; 0
    4ea0:	40 81       	ld	r20, Z
    4ea2:	89 81       	ldd	r24, Y+1	; 0x01
    4ea4:	28 2f       	mov	r18, r24
    4ea6:	30 e0       	ldi	r19, 0x00	; 0
    4ea8:	c9 01       	movw	r24, r18
    4eaa:	88 0f       	add	r24, r24
    4eac:	99 1f       	adc	r25, r25
    4eae:	82 0f       	add	r24, r18
    4eb0:	93 1f       	adc	r25, r19
    4eb2:	88 0f       	add	r24, r24
    4eb4:	99 1f       	adc	r25, r25
    4eb6:	fc 01       	movw	r30, r24
    4eb8:	e9 53       	subi	r30, 0x39	; 57
    4eba:	ff 4f       	sbci	r31, 0xFF	; 255
    4ebc:	80 81       	ld	r24, Z
    4ebe:	28 2f       	mov	r18, r24
    4ec0:	30 e0       	ldi	r19, 0x00	; 0
    4ec2:	81 e0       	ldi	r24, 0x01	; 1
    4ec4:	90 e0       	ldi	r25, 0x00	; 0
    4ec6:	02 c0       	rjmp	.+4      	; 0x4ecc <DIO_Init+0x22a>
    4ec8:	88 0f       	add	r24, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	2a 95       	dec	r18
    4ece:	e2 f7       	brpl	.-8      	; 0x4ec8 <DIO_Init+0x226>
    4ed0:	80 95       	com	r24
    4ed2:	84 23       	and	r24, r20
    4ed4:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Res == PULLUP) {
    4ed6:	89 81       	ldd	r24, Y+1	; 0x01
    4ed8:	28 2f       	mov	r18, r24
    4eda:	30 e0       	ldi	r19, 0x00	; 0
    4edc:	c9 01       	movw	r24, r18
    4ede:	88 0f       	add	r24, r24
    4ee0:	99 1f       	adc	r25, r25
    4ee2:	82 0f       	add	r24, r18
    4ee4:	93 1f       	adc	r25, r19
    4ee6:	88 0f       	add	r24, r24
    4ee8:	99 1f       	adc	r25, r25
    4eea:	fc 01       	movw	r30, r24
    4eec:	e6 53       	subi	r30, 0x36	; 54
    4eee:	ff 4f       	sbci	r31, 0xFF	; 255
    4ef0:	80 81       	ld	r24, Z
    4ef2:	81 30       	cpi	r24, 0x01	; 1
    4ef4:	01 f5       	brne	.+64     	; 0x4f36 <DIO_Init+0x294>
						PORTA |= (1u << DIO_Array[LoopIndex].PIN);
    4ef6:	ab e3       	ldi	r26, 0x3B	; 59
    4ef8:	b0 e0       	ldi	r27, 0x00	; 0
    4efa:	eb e3       	ldi	r30, 0x3B	; 59
    4efc:	f0 e0       	ldi	r31, 0x00	; 0
    4efe:	40 81       	ld	r20, Z
    4f00:	89 81       	ldd	r24, Y+1	; 0x01
    4f02:	28 2f       	mov	r18, r24
    4f04:	30 e0       	ldi	r19, 0x00	; 0
    4f06:	c9 01       	movw	r24, r18
    4f08:	88 0f       	add	r24, r24
    4f0a:	99 1f       	adc	r25, r25
    4f0c:	82 0f       	add	r24, r18
    4f0e:	93 1f       	adc	r25, r19
    4f10:	88 0f       	add	r24, r24
    4f12:	99 1f       	adc	r25, r25
    4f14:	fc 01       	movw	r30, r24
    4f16:	e9 53       	subi	r30, 0x39	; 57
    4f18:	ff 4f       	sbci	r31, 0xFF	; 255
    4f1a:	80 81       	ld	r24, Z
    4f1c:	28 2f       	mov	r18, r24
    4f1e:	30 e0       	ldi	r19, 0x00	; 0
    4f20:	81 e0       	ldi	r24, 0x01	; 1
    4f22:	90 e0       	ldi	r25, 0x00	; 0
    4f24:	02 2e       	mov	r0, r18
    4f26:	02 c0       	rjmp	.+4      	; 0x4f2c <DIO_Init+0x28a>
    4f28:	88 0f       	add	r24, r24
    4f2a:	99 1f       	adc	r25, r25
    4f2c:	0a 94       	dec	r0
    4f2e:	e2 f7       	brpl	.-8      	; 0x4f28 <DIO_Init+0x286>
    4f30:	84 2b       	or	r24, r20
    4f32:	8c 93       	st	X, r24
    4f34:	59 c4       	rjmp	.+2226   	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Res == EXTRES) {
    4f36:	89 81       	ldd	r24, Y+1	; 0x01
    4f38:	28 2f       	mov	r18, r24
    4f3a:	30 e0       	ldi	r19, 0x00	; 0
    4f3c:	c9 01       	movw	r24, r18
    4f3e:	88 0f       	add	r24, r24
    4f40:	99 1f       	adc	r25, r25
    4f42:	82 0f       	add	r24, r18
    4f44:	93 1f       	adc	r25, r19
    4f46:	88 0f       	add	r24, r24
    4f48:	99 1f       	adc	r25, r25
    4f4a:	fc 01       	movw	r30, r24
    4f4c:	e6 53       	subi	r30, 0x36	; 54
    4f4e:	ff 4f       	sbci	r31, 0xFF	; 255
    4f50:	80 81       	ld	r24, Z
    4f52:	88 23       	and	r24, r24
    4f54:	09 f5       	brne	.+66     	; 0x4f98 <DIO_Init+0x2f6>
						PORTA &= ~(1u << DIO_Array[LoopIndex].PIN);
    4f56:	ab e3       	ldi	r26, 0x3B	; 59
    4f58:	b0 e0       	ldi	r27, 0x00	; 0
    4f5a:	eb e3       	ldi	r30, 0x3B	; 59
    4f5c:	f0 e0       	ldi	r31, 0x00	; 0
    4f5e:	40 81       	ld	r20, Z
    4f60:	89 81       	ldd	r24, Y+1	; 0x01
    4f62:	28 2f       	mov	r18, r24
    4f64:	30 e0       	ldi	r19, 0x00	; 0
    4f66:	c9 01       	movw	r24, r18
    4f68:	88 0f       	add	r24, r24
    4f6a:	99 1f       	adc	r25, r25
    4f6c:	82 0f       	add	r24, r18
    4f6e:	93 1f       	adc	r25, r19
    4f70:	88 0f       	add	r24, r24
    4f72:	99 1f       	adc	r25, r25
    4f74:	fc 01       	movw	r30, r24
    4f76:	e9 53       	subi	r30, 0x39	; 57
    4f78:	ff 4f       	sbci	r31, 0xFF	; 255
    4f7a:	80 81       	ld	r24, Z
    4f7c:	28 2f       	mov	r18, r24
    4f7e:	30 e0       	ldi	r19, 0x00	; 0
    4f80:	81 e0       	ldi	r24, 0x01	; 1
    4f82:	90 e0       	ldi	r25, 0x00	; 0
    4f84:	02 2e       	mov	r0, r18
    4f86:	02 c0       	rjmp	.+4      	; 0x4f8c <DIO_Init+0x2ea>
    4f88:	88 0f       	add	r24, r24
    4f8a:	99 1f       	adc	r25, r25
    4f8c:	0a 94       	dec	r0
    4f8e:	e2 f7       	brpl	.-8      	; 0x4f88 <DIO_Init+0x2e6>
    4f90:	80 95       	com	r24
    4f92:	84 23       	and	r24, r20
    4f94:	8c 93       	st	X, r24
    4f96:	28 c4       	rjmp	.+2128   	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    4f98:	89 81       	ldd	r24, Y+1	; 0x01
    4f9a:	28 2f       	mov	r18, r24
    4f9c:	30 e0       	ldi	r19, 0x00	; 0
    4f9e:	c9 01       	movw	r24, r18
    4fa0:	88 0f       	add	r24, r24
    4fa2:	99 1f       	adc	r25, r25
    4fa4:	82 0f       	add	r24, r18
    4fa6:	93 1f       	adc	r25, r19
    4fa8:	88 0f       	add	r24, r24
    4faa:	99 1f       	adc	r25, r25
    4fac:	fc 01       	movw	r30, r24
    4fae:	e5 53       	subi	r30, 0x35	; 53
    4fb0:	ff 4f       	sbci	r31, 0xFF	; 255
    4fb2:	10 82       	st	Z, r1
						RetVal = NOK;
    4fb4:	1a 82       	std	Y+2, r1	; 0x02
    4fb6:	18 c4       	rjmp	.+2096   	; 0x57e8 <DIO_Init+0xb46>
					}
					} else {
					DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    4fb8:	89 81       	ldd	r24, Y+1	; 0x01
    4fba:	28 2f       	mov	r18, r24
    4fbc:	30 e0       	ldi	r19, 0x00	; 0
    4fbe:	c9 01       	movw	r24, r18
    4fc0:	88 0f       	add	r24, r24
    4fc2:	99 1f       	adc	r25, r25
    4fc4:	82 0f       	add	r24, r18
    4fc6:	93 1f       	adc	r25, r19
    4fc8:	88 0f       	add	r24, r24
    4fca:	99 1f       	adc	r25, r25
    4fcc:	fc 01       	movw	r30, r24
    4fce:	e5 53       	subi	r30, 0x35	; 53
    4fd0:	ff 4f       	sbci	r31, 0xFF	; 255
    4fd2:	10 82       	st	Z, r1
					RetVal = NOK;
    4fd4:	1a 82       	std	Y+2, r1	; 0x02
    4fd6:	08 c4       	rjmp	.+2064   	; 0x57e8 <DIO_Init+0xb46>
				}

				break;
				case PORT_B:

				if (DIO_Array[LoopIndex].Dir == OUTPUT) {
    4fd8:	89 81       	ldd	r24, Y+1	; 0x01
    4fda:	28 2f       	mov	r18, r24
    4fdc:	30 e0       	ldi	r19, 0x00	; 0
    4fde:	c9 01       	movw	r24, r18
    4fe0:	88 0f       	add	r24, r24
    4fe2:	99 1f       	adc	r25, r25
    4fe4:	82 0f       	add	r24, r18
    4fe6:	93 1f       	adc	r25, r19
    4fe8:	01 96       	adiw	r24, 0x01	; 1
    4fea:	88 0f       	add	r24, r24
    4fec:	99 1f       	adc	r25, r25
    4fee:	fc 01       	movw	r30, r24
    4ff0:	ea 53       	subi	r30, 0x3A	; 58
    4ff2:	ff 4f       	sbci	r31, 0xFF	; 255
    4ff4:	80 81       	ld	r24, Z
    4ff6:	81 30       	cpi	r24, 0x01	; 1
    4ff8:	09 f0       	breq	.+2      	; 0x4ffc <DIO_Init+0x35a>
    4ffa:	8f c0       	rjmp	.+286    	; 0x511a <DIO_Init+0x478>
					DDRB |= (1u << DIO_Array[LoopIndex].PIN);
    4ffc:	a7 e3       	ldi	r26, 0x37	; 55
    4ffe:	b0 e0       	ldi	r27, 0x00	; 0
    5000:	e7 e3       	ldi	r30, 0x37	; 55
    5002:	f0 e0       	ldi	r31, 0x00	; 0
    5004:	40 81       	ld	r20, Z
    5006:	89 81       	ldd	r24, Y+1	; 0x01
    5008:	28 2f       	mov	r18, r24
    500a:	30 e0       	ldi	r19, 0x00	; 0
    500c:	c9 01       	movw	r24, r18
    500e:	88 0f       	add	r24, r24
    5010:	99 1f       	adc	r25, r25
    5012:	82 0f       	add	r24, r18
    5014:	93 1f       	adc	r25, r19
    5016:	88 0f       	add	r24, r24
    5018:	99 1f       	adc	r25, r25
    501a:	fc 01       	movw	r30, r24
    501c:	e9 53       	subi	r30, 0x39	; 57
    501e:	ff 4f       	sbci	r31, 0xFF	; 255
    5020:	80 81       	ld	r24, Z
    5022:	28 2f       	mov	r18, r24
    5024:	30 e0       	ldi	r19, 0x00	; 0
    5026:	81 e0       	ldi	r24, 0x01	; 1
    5028:	90 e0       	ldi	r25, 0x00	; 0
    502a:	02 c0       	rjmp	.+4      	; 0x5030 <DIO_Init+0x38e>
    502c:	88 0f       	add	r24, r24
    502e:	99 1f       	adc	r25, r25
    5030:	2a 95       	dec	r18
    5032:	e2 f7       	brpl	.-8      	; 0x502c <DIO_Init+0x38a>
    5034:	84 2b       	or	r24, r20
    5036:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Val == HIGH) {
    5038:	89 81       	ldd	r24, Y+1	; 0x01
    503a:	28 2f       	mov	r18, r24
    503c:	30 e0       	ldi	r19, 0x00	; 0
    503e:	c9 01       	movw	r24, r18
    5040:	88 0f       	add	r24, r24
    5042:	99 1f       	adc	r25, r25
    5044:	82 0f       	add	r24, r18
    5046:	93 1f       	adc	r25, r19
    5048:	88 0f       	add	r24, r24
    504a:	99 1f       	adc	r25, r25
    504c:	fc 01       	movw	r30, r24
    504e:	e7 53       	subi	r30, 0x37	; 55
    5050:	ff 4f       	sbci	r31, 0xFF	; 255
    5052:	80 81       	ld	r24, Z
    5054:	81 30       	cpi	r24, 0x01	; 1
    5056:	01 f5       	brne	.+64     	; 0x5098 <DIO_Init+0x3f6>
						PORTB |= (1u << DIO_Array[LoopIndex].PIN);
    5058:	a8 e3       	ldi	r26, 0x38	; 56
    505a:	b0 e0       	ldi	r27, 0x00	; 0
    505c:	e8 e3       	ldi	r30, 0x38	; 56
    505e:	f0 e0       	ldi	r31, 0x00	; 0
    5060:	40 81       	ld	r20, Z
    5062:	89 81       	ldd	r24, Y+1	; 0x01
    5064:	28 2f       	mov	r18, r24
    5066:	30 e0       	ldi	r19, 0x00	; 0
    5068:	c9 01       	movw	r24, r18
    506a:	88 0f       	add	r24, r24
    506c:	99 1f       	adc	r25, r25
    506e:	82 0f       	add	r24, r18
    5070:	93 1f       	adc	r25, r19
    5072:	88 0f       	add	r24, r24
    5074:	99 1f       	adc	r25, r25
    5076:	fc 01       	movw	r30, r24
    5078:	e9 53       	subi	r30, 0x39	; 57
    507a:	ff 4f       	sbci	r31, 0xFF	; 255
    507c:	80 81       	ld	r24, Z
    507e:	28 2f       	mov	r18, r24
    5080:	30 e0       	ldi	r19, 0x00	; 0
    5082:	81 e0       	ldi	r24, 0x01	; 1
    5084:	90 e0       	ldi	r25, 0x00	; 0
    5086:	02 2e       	mov	r0, r18
    5088:	02 c0       	rjmp	.+4      	; 0x508e <DIO_Init+0x3ec>
    508a:	88 0f       	add	r24, r24
    508c:	99 1f       	adc	r25, r25
    508e:	0a 94       	dec	r0
    5090:	e2 f7       	brpl	.-8      	; 0x508a <DIO_Init+0x3e8>
    5092:	84 2b       	or	r24, r20
    5094:	8c 93       	st	X, r24
    5096:	a8 c3       	rjmp	.+1872   	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Val == LOW) {
    5098:	89 81       	ldd	r24, Y+1	; 0x01
    509a:	28 2f       	mov	r18, r24
    509c:	30 e0       	ldi	r19, 0x00	; 0
    509e:	c9 01       	movw	r24, r18
    50a0:	88 0f       	add	r24, r24
    50a2:	99 1f       	adc	r25, r25
    50a4:	82 0f       	add	r24, r18
    50a6:	93 1f       	adc	r25, r19
    50a8:	88 0f       	add	r24, r24
    50aa:	99 1f       	adc	r25, r25
    50ac:	fc 01       	movw	r30, r24
    50ae:	e7 53       	subi	r30, 0x37	; 55
    50b0:	ff 4f       	sbci	r31, 0xFF	; 255
    50b2:	80 81       	ld	r24, Z
    50b4:	88 23       	and	r24, r24
    50b6:	09 f5       	brne	.+66     	; 0x50fa <DIO_Init+0x458>
						PORTB &= ~(1u << DIO_Array[LoopIndex].PIN);
    50b8:	a8 e3       	ldi	r26, 0x38	; 56
    50ba:	b0 e0       	ldi	r27, 0x00	; 0
    50bc:	e8 e3       	ldi	r30, 0x38	; 56
    50be:	f0 e0       	ldi	r31, 0x00	; 0
    50c0:	40 81       	ld	r20, Z
    50c2:	89 81       	ldd	r24, Y+1	; 0x01
    50c4:	28 2f       	mov	r18, r24
    50c6:	30 e0       	ldi	r19, 0x00	; 0
    50c8:	c9 01       	movw	r24, r18
    50ca:	88 0f       	add	r24, r24
    50cc:	99 1f       	adc	r25, r25
    50ce:	82 0f       	add	r24, r18
    50d0:	93 1f       	adc	r25, r19
    50d2:	88 0f       	add	r24, r24
    50d4:	99 1f       	adc	r25, r25
    50d6:	fc 01       	movw	r30, r24
    50d8:	e9 53       	subi	r30, 0x39	; 57
    50da:	ff 4f       	sbci	r31, 0xFF	; 255
    50dc:	80 81       	ld	r24, Z
    50de:	28 2f       	mov	r18, r24
    50e0:	30 e0       	ldi	r19, 0x00	; 0
    50e2:	81 e0       	ldi	r24, 0x01	; 1
    50e4:	90 e0       	ldi	r25, 0x00	; 0
    50e6:	02 2e       	mov	r0, r18
    50e8:	02 c0       	rjmp	.+4      	; 0x50ee <DIO_Init+0x44c>
    50ea:	88 0f       	add	r24, r24
    50ec:	99 1f       	adc	r25, r25
    50ee:	0a 94       	dec	r0
    50f0:	e2 f7       	brpl	.-8      	; 0x50ea <DIO_Init+0x448>
    50f2:	80 95       	com	r24
    50f4:	84 23       	and	r24, r20
    50f6:	8c 93       	st	X, r24
    50f8:	77 c3       	rjmp	.+1774   	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    50fa:	89 81       	ldd	r24, Y+1	; 0x01
    50fc:	28 2f       	mov	r18, r24
    50fe:	30 e0       	ldi	r19, 0x00	; 0
    5100:	c9 01       	movw	r24, r18
    5102:	88 0f       	add	r24, r24
    5104:	99 1f       	adc	r25, r25
    5106:	82 0f       	add	r24, r18
    5108:	93 1f       	adc	r25, r19
    510a:	88 0f       	add	r24, r24
    510c:	99 1f       	adc	r25, r25
    510e:	fc 01       	movw	r30, r24
    5110:	e5 53       	subi	r30, 0x35	; 53
    5112:	ff 4f       	sbci	r31, 0xFF	; 255
    5114:	10 82       	st	Z, r1
						RetVal = NOK;
    5116:	1a 82       	std	Y+2, r1	; 0x02
    5118:	67 c3       	rjmp	.+1742   	; 0x57e8 <DIO_Init+0xb46>
					}
					} else if (DIO_Array[LoopIndex].Dir == INPUT) {
    511a:	89 81       	ldd	r24, Y+1	; 0x01
    511c:	28 2f       	mov	r18, r24
    511e:	30 e0       	ldi	r19, 0x00	; 0
    5120:	c9 01       	movw	r24, r18
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	82 0f       	add	r24, r18
    5128:	93 1f       	adc	r25, r19
    512a:	01 96       	adiw	r24, 0x01	; 1
    512c:	88 0f       	add	r24, r24
    512e:	99 1f       	adc	r25, r25
    5130:	fc 01       	movw	r30, r24
    5132:	ea 53       	subi	r30, 0x3A	; 58
    5134:	ff 4f       	sbci	r31, 0xFF	; 255
    5136:	80 81       	ld	r24, Z
    5138:	88 23       	and	r24, r24
    513a:	09 f0       	breq	.+2      	; 0x513e <DIO_Init+0x49c>
    513c:	90 c0       	rjmp	.+288    	; 0x525e <DIO_Init+0x5bc>
					DDRB &= ~(1u << DIO_Array[LoopIndex].PIN);
    513e:	a7 e3       	ldi	r26, 0x37	; 55
    5140:	b0 e0       	ldi	r27, 0x00	; 0
    5142:	e7 e3       	ldi	r30, 0x37	; 55
    5144:	f0 e0       	ldi	r31, 0x00	; 0
    5146:	40 81       	ld	r20, Z
    5148:	89 81       	ldd	r24, Y+1	; 0x01
    514a:	28 2f       	mov	r18, r24
    514c:	30 e0       	ldi	r19, 0x00	; 0
    514e:	c9 01       	movw	r24, r18
    5150:	88 0f       	add	r24, r24
    5152:	99 1f       	adc	r25, r25
    5154:	82 0f       	add	r24, r18
    5156:	93 1f       	adc	r25, r19
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	fc 01       	movw	r30, r24
    515e:	e9 53       	subi	r30, 0x39	; 57
    5160:	ff 4f       	sbci	r31, 0xFF	; 255
    5162:	80 81       	ld	r24, Z
    5164:	28 2f       	mov	r18, r24
    5166:	30 e0       	ldi	r19, 0x00	; 0
    5168:	81 e0       	ldi	r24, 0x01	; 1
    516a:	90 e0       	ldi	r25, 0x00	; 0
    516c:	02 c0       	rjmp	.+4      	; 0x5172 <DIO_Init+0x4d0>
    516e:	88 0f       	add	r24, r24
    5170:	99 1f       	adc	r25, r25
    5172:	2a 95       	dec	r18
    5174:	e2 f7       	brpl	.-8      	; 0x516e <DIO_Init+0x4cc>
    5176:	80 95       	com	r24
    5178:	84 23       	and	r24, r20
    517a:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Res == PULLUP) {
    517c:	89 81       	ldd	r24, Y+1	; 0x01
    517e:	28 2f       	mov	r18, r24
    5180:	30 e0       	ldi	r19, 0x00	; 0
    5182:	c9 01       	movw	r24, r18
    5184:	88 0f       	add	r24, r24
    5186:	99 1f       	adc	r25, r25
    5188:	82 0f       	add	r24, r18
    518a:	93 1f       	adc	r25, r19
    518c:	88 0f       	add	r24, r24
    518e:	99 1f       	adc	r25, r25
    5190:	fc 01       	movw	r30, r24
    5192:	e6 53       	subi	r30, 0x36	; 54
    5194:	ff 4f       	sbci	r31, 0xFF	; 255
    5196:	80 81       	ld	r24, Z
    5198:	81 30       	cpi	r24, 0x01	; 1
    519a:	01 f5       	brne	.+64     	; 0x51dc <DIO_Init+0x53a>
						PORTB |= (1u << DIO_Array[LoopIndex].PIN);
    519c:	a8 e3       	ldi	r26, 0x38	; 56
    519e:	b0 e0       	ldi	r27, 0x00	; 0
    51a0:	e8 e3       	ldi	r30, 0x38	; 56
    51a2:	f0 e0       	ldi	r31, 0x00	; 0
    51a4:	40 81       	ld	r20, Z
    51a6:	89 81       	ldd	r24, Y+1	; 0x01
    51a8:	28 2f       	mov	r18, r24
    51aa:	30 e0       	ldi	r19, 0x00	; 0
    51ac:	c9 01       	movw	r24, r18
    51ae:	88 0f       	add	r24, r24
    51b0:	99 1f       	adc	r25, r25
    51b2:	82 0f       	add	r24, r18
    51b4:	93 1f       	adc	r25, r19
    51b6:	88 0f       	add	r24, r24
    51b8:	99 1f       	adc	r25, r25
    51ba:	fc 01       	movw	r30, r24
    51bc:	e9 53       	subi	r30, 0x39	; 57
    51be:	ff 4f       	sbci	r31, 0xFF	; 255
    51c0:	80 81       	ld	r24, Z
    51c2:	28 2f       	mov	r18, r24
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	81 e0       	ldi	r24, 0x01	; 1
    51c8:	90 e0       	ldi	r25, 0x00	; 0
    51ca:	02 2e       	mov	r0, r18
    51cc:	02 c0       	rjmp	.+4      	; 0x51d2 <DIO_Init+0x530>
    51ce:	88 0f       	add	r24, r24
    51d0:	99 1f       	adc	r25, r25
    51d2:	0a 94       	dec	r0
    51d4:	e2 f7       	brpl	.-8      	; 0x51ce <DIO_Init+0x52c>
    51d6:	84 2b       	or	r24, r20
    51d8:	8c 93       	st	X, r24
    51da:	06 c3       	rjmp	.+1548   	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Res == EXTRES) {
    51dc:	89 81       	ldd	r24, Y+1	; 0x01
    51de:	28 2f       	mov	r18, r24
    51e0:	30 e0       	ldi	r19, 0x00	; 0
    51e2:	c9 01       	movw	r24, r18
    51e4:	88 0f       	add	r24, r24
    51e6:	99 1f       	adc	r25, r25
    51e8:	82 0f       	add	r24, r18
    51ea:	93 1f       	adc	r25, r19
    51ec:	88 0f       	add	r24, r24
    51ee:	99 1f       	adc	r25, r25
    51f0:	fc 01       	movw	r30, r24
    51f2:	e6 53       	subi	r30, 0x36	; 54
    51f4:	ff 4f       	sbci	r31, 0xFF	; 255
    51f6:	80 81       	ld	r24, Z
    51f8:	88 23       	and	r24, r24
    51fa:	09 f5       	brne	.+66     	; 0x523e <DIO_Init+0x59c>
						PORTB &= ~(1u << DIO_Array[LoopIndex].PIN);
    51fc:	a8 e3       	ldi	r26, 0x38	; 56
    51fe:	b0 e0       	ldi	r27, 0x00	; 0
    5200:	e8 e3       	ldi	r30, 0x38	; 56
    5202:	f0 e0       	ldi	r31, 0x00	; 0
    5204:	40 81       	ld	r20, Z
    5206:	89 81       	ldd	r24, Y+1	; 0x01
    5208:	28 2f       	mov	r18, r24
    520a:	30 e0       	ldi	r19, 0x00	; 0
    520c:	c9 01       	movw	r24, r18
    520e:	88 0f       	add	r24, r24
    5210:	99 1f       	adc	r25, r25
    5212:	82 0f       	add	r24, r18
    5214:	93 1f       	adc	r25, r19
    5216:	88 0f       	add	r24, r24
    5218:	99 1f       	adc	r25, r25
    521a:	fc 01       	movw	r30, r24
    521c:	e9 53       	subi	r30, 0x39	; 57
    521e:	ff 4f       	sbci	r31, 0xFF	; 255
    5220:	80 81       	ld	r24, Z
    5222:	28 2f       	mov	r18, r24
    5224:	30 e0       	ldi	r19, 0x00	; 0
    5226:	81 e0       	ldi	r24, 0x01	; 1
    5228:	90 e0       	ldi	r25, 0x00	; 0
    522a:	02 2e       	mov	r0, r18
    522c:	02 c0       	rjmp	.+4      	; 0x5232 <DIO_Init+0x590>
    522e:	88 0f       	add	r24, r24
    5230:	99 1f       	adc	r25, r25
    5232:	0a 94       	dec	r0
    5234:	e2 f7       	brpl	.-8      	; 0x522e <DIO_Init+0x58c>
    5236:	80 95       	com	r24
    5238:	84 23       	and	r24, r20
    523a:	8c 93       	st	X, r24
    523c:	d5 c2       	rjmp	.+1450   	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    523e:	89 81       	ldd	r24, Y+1	; 0x01
    5240:	28 2f       	mov	r18, r24
    5242:	30 e0       	ldi	r19, 0x00	; 0
    5244:	c9 01       	movw	r24, r18
    5246:	88 0f       	add	r24, r24
    5248:	99 1f       	adc	r25, r25
    524a:	82 0f       	add	r24, r18
    524c:	93 1f       	adc	r25, r19
    524e:	88 0f       	add	r24, r24
    5250:	99 1f       	adc	r25, r25
    5252:	fc 01       	movw	r30, r24
    5254:	e5 53       	subi	r30, 0x35	; 53
    5256:	ff 4f       	sbci	r31, 0xFF	; 255
    5258:	10 82       	st	Z, r1
						RetVal = NOK;
    525a:	1a 82       	std	Y+2, r1	; 0x02
    525c:	c5 c2       	rjmp	.+1418   	; 0x57e8 <DIO_Init+0xb46>
					}
					} else {
					DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    525e:	89 81       	ldd	r24, Y+1	; 0x01
    5260:	28 2f       	mov	r18, r24
    5262:	30 e0       	ldi	r19, 0x00	; 0
    5264:	c9 01       	movw	r24, r18
    5266:	88 0f       	add	r24, r24
    5268:	99 1f       	adc	r25, r25
    526a:	82 0f       	add	r24, r18
    526c:	93 1f       	adc	r25, r19
    526e:	88 0f       	add	r24, r24
    5270:	99 1f       	adc	r25, r25
    5272:	fc 01       	movw	r30, r24
    5274:	e5 53       	subi	r30, 0x35	; 53
    5276:	ff 4f       	sbci	r31, 0xFF	; 255
    5278:	10 82       	st	Z, r1
					RetVal = NOK;
    527a:	1a 82       	std	Y+2, r1	; 0x02
    527c:	b5 c2       	rjmp	.+1386   	; 0x57e8 <DIO_Init+0xb46>
				}
				break;
				case PORT_C:

				if (DIO_Array[LoopIndex].Dir == OUTPUT) {
    527e:	89 81       	ldd	r24, Y+1	; 0x01
    5280:	28 2f       	mov	r18, r24
    5282:	30 e0       	ldi	r19, 0x00	; 0
    5284:	c9 01       	movw	r24, r18
    5286:	88 0f       	add	r24, r24
    5288:	99 1f       	adc	r25, r25
    528a:	82 0f       	add	r24, r18
    528c:	93 1f       	adc	r25, r19
    528e:	01 96       	adiw	r24, 0x01	; 1
    5290:	88 0f       	add	r24, r24
    5292:	99 1f       	adc	r25, r25
    5294:	fc 01       	movw	r30, r24
    5296:	ea 53       	subi	r30, 0x3A	; 58
    5298:	ff 4f       	sbci	r31, 0xFF	; 255
    529a:	80 81       	ld	r24, Z
    529c:	81 30       	cpi	r24, 0x01	; 1
    529e:	09 f0       	breq	.+2      	; 0x52a2 <DIO_Init+0x600>
    52a0:	8f c0       	rjmp	.+286    	; 0x53c0 <DIO_Init+0x71e>
					DDRC |= (1u << DIO_Array[LoopIndex].PIN);
    52a2:	a4 e3       	ldi	r26, 0x34	; 52
    52a4:	b0 e0       	ldi	r27, 0x00	; 0
    52a6:	e4 e3       	ldi	r30, 0x34	; 52
    52a8:	f0 e0       	ldi	r31, 0x00	; 0
    52aa:	40 81       	ld	r20, Z
    52ac:	89 81       	ldd	r24, Y+1	; 0x01
    52ae:	28 2f       	mov	r18, r24
    52b0:	30 e0       	ldi	r19, 0x00	; 0
    52b2:	c9 01       	movw	r24, r18
    52b4:	88 0f       	add	r24, r24
    52b6:	99 1f       	adc	r25, r25
    52b8:	82 0f       	add	r24, r18
    52ba:	93 1f       	adc	r25, r19
    52bc:	88 0f       	add	r24, r24
    52be:	99 1f       	adc	r25, r25
    52c0:	fc 01       	movw	r30, r24
    52c2:	e9 53       	subi	r30, 0x39	; 57
    52c4:	ff 4f       	sbci	r31, 0xFF	; 255
    52c6:	80 81       	ld	r24, Z
    52c8:	28 2f       	mov	r18, r24
    52ca:	30 e0       	ldi	r19, 0x00	; 0
    52cc:	81 e0       	ldi	r24, 0x01	; 1
    52ce:	90 e0       	ldi	r25, 0x00	; 0
    52d0:	02 c0       	rjmp	.+4      	; 0x52d6 <DIO_Init+0x634>
    52d2:	88 0f       	add	r24, r24
    52d4:	99 1f       	adc	r25, r25
    52d6:	2a 95       	dec	r18
    52d8:	e2 f7       	brpl	.-8      	; 0x52d2 <DIO_Init+0x630>
    52da:	84 2b       	or	r24, r20
    52dc:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Val == HIGH) {
    52de:	89 81       	ldd	r24, Y+1	; 0x01
    52e0:	28 2f       	mov	r18, r24
    52e2:	30 e0       	ldi	r19, 0x00	; 0
    52e4:	c9 01       	movw	r24, r18
    52e6:	88 0f       	add	r24, r24
    52e8:	99 1f       	adc	r25, r25
    52ea:	82 0f       	add	r24, r18
    52ec:	93 1f       	adc	r25, r19
    52ee:	88 0f       	add	r24, r24
    52f0:	99 1f       	adc	r25, r25
    52f2:	fc 01       	movw	r30, r24
    52f4:	e7 53       	subi	r30, 0x37	; 55
    52f6:	ff 4f       	sbci	r31, 0xFF	; 255
    52f8:	80 81       	ld	r24, Z
    52fa:	81 30       	cpi	r24, 0x01	; 1
    52fc:	01 f5       	brne	.+64     	; 0x533e <DIO_Init+0x69c>
						PORTC |= (1u << DIO_Array[LoopIndex].PIN);
    52fe:	a5 e3       	ldi	r26, 0x35	; 53
    5300:	b0 e0       	ldi	r27, 0x00	; 0
    5302:	e5 e3       	ldi	r30, 0x35	; 53
    5304:	f0 e0       	ldi	r31, 0x00	; 0
    5306:	40 81       	ld	r20, Z
    5308:	89 81       	ldd	r24, Y+1	; 0x01
    530a:	28 2f       	mov	r18, r24
    530c:	30 e0       	ldi	r19, 0x00	; 0
    530e:	c9 01       	movw	r24, r18
    5310:	88 0f       	add	r24, r24
    5312:	99 1f       	adc	r25, r25
    5314:	82 0f       	add	r24, r18
    5316:	93 1f       	adc	r25, r19
    5318:	88 0f       	add	r24, r24
    531a:	99 1f       	adc	r25, r25
    531c:	fc 01       	movw	r30, r24
    531e:	e9 53       	subi	r30, 0x39	; 57
    5320:	ff 4f       	sbci	r31, 0xFF	; 255
    5322:	80 81       	ld	r24, Z
    5324:	28 2f       	mov	r18, r24
    5326:	30 e0       	ldi	r19, 0x00	; 0
    5328:	81 e0       	ldi	r24, 0x01	; 1
    532a:	90 e0       	ldi	r25, 0x00	; 0
    532c:	02 2e       	mov	r0, r18
    532e:	02 c0       	rjmp	.+4      	; 0x5334 <DIO_Init+0x692>
    5330:	88 0f       	add	r24, r24
    5332:	99 1f       	adc	r25, r25
    5334:	0a 94       	dec	r0
    5336:	e2 f7       	brpl	.-8      	; 0x5330 <DIO_Init+0x68e>
    5338:	84 2b       	or	r24, r20
    533a:	8c 93       	st	X, r24
    533c:	55 c2       	rjmp	.+1194   	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Val == LOW) {
    533e:	89 81       	ldd	r24, Y+1	; 0x01
    5340:	28 2f       	mov	r18, r24
    5342:	30 e0       	ldi	r19, 0x00	; 0
    5344:	c9 01       	movw	r24, r18
    5346:	88 0f       	add	r24, r24
    5348:	99 1f       	adc	r25, r25
    534a:	82 0f       	add	r24, r18
    534c:	93 1f       	adc	r25, r19
    534e:	88 0f       	add	r24, r24
    5350:	99 1f       	adc	r25, r25
    5352:	fc 01       	movw	r30, r24
    5354:	e7 53       	subi	r30, 0x37	; 55
    5356:	ff 4f       	sbci	r31, 0xFF	; 255
    5358:	80 81       	ld	r24, Z
    535a:	88 23       	and	r24, r24
    535c:	09 f5       	brne	.+66     	; 0x53a0 <DIO_Init+0x6fe>
						PORTC &= ~(1u << DIO_Array[LoopIndex].PIN);
    535e:	a5 e3       	ldi	r26, 0x35	; 53
    5360:	b0 e0       	ldi	r27, 0x00	; 0
    5362:	e5 e3       	ldi	r30, 0x35	; 53
    5364:	f0 e0       	ldi	r31, 0x00	; 0
    5366:	40 81       	ld	r20, Z
    5368:	89 81       	ldd	r24, Y+1	; 0x01
    536a:	28 2f       	mov	r18, r24
    536c:	30 e0       	ldi	r19, 0x00	; 0
    536e:	c9 01       	movw	r24, r18
    5370:	88 0f       	add	r24, r24
    5372:	99 1f       	adc	r25, r25
    5374:	82 0f       	add	r24, r18
    5376:	93 1f       	adc	r25, r19
    5378:	88 0f       	add	r24, r24
    537a:	99 1f       	adc	r25, r25
    537c:	fc 01       	movw	r30, r24
    537e:	e9 53       	subi	r30, 0x39	; 57
    5380:	ff 4f       	sbci	r31, 0xFF	; 255
    5382:	80 81       	ld	r24, Z
    5384:	28 2f       	mov	r18, r24
    5386:	30 e0       	ldi	r19, 0x00	; 0
    5388:	81 e0       	ldi	r24, 0x01	; 1
    538a:	90 e0       	ldi	r25, 0x00	; 0
    538c:	02 2e       	mov	r0, r18
    538e:	02 c0       	rjmp	.+4      	; 0x5394 <DIO_Init+0x6f2>
    5390:	88 0f       	add	r24, r24
    5392:	99 1f       	adc	r25, r25
    5394:	0a 94       	dec	r0
    5396:	e2 f7       	brpl	.-8      	; 0x5390 <DIO_Init+0x6ee>
    5398:	80 95       	com	r24
    539a:	84 23       	and	r24, r20
    539c:	8c 93       	st	X, r24
    539e:	24 c2       	rjmp	.+1096   	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    53a0:	89 81       	ldd	r24, Y+1	; 0x01
    53a2:	28 2f       	mov	r18, r24
    53a4:	30 e0       	ldi	r19, 0x00	; 0
    53a6:	c9 01       	movw	r24, r18
    53a8:	88 0f       	add	r24, r24
    53aa:	99 1f       	adc	r25, r25
    53ac:	82 0f       	add	r24, r18
    53ae:	93 1f       	adc	r25, r19
    53b0:	88 0f       	add	r24, r24
    53b2:	99 1f       	adc	r25, r25
    53b4:	fc 01       	movw	r30, r24
    53b6:	e5 53       	subi	r30, 0x35	; 53
    53b8:	ff 4f       	sbci	r31, 0xFF	; 255
    53ba:	10 82       	st	Z, r1
						RetVal = NOK;
    53bc:	1a 82       	std	Y+2, r1	; 0x02
    53be:	14 c2       	rjmp	.+1064   	; 0x57e8 <DIO_Init+0xb46>
					}
					} else if (DIO_Array[LoopIndex].Dir == INPUT) {
    53c0:	89 81       	ldd	r24, Y+1	; 0x01
    53c2:	28 2f       	mov	r18, r24
    53c4:	30 e0       	ldi	r19, 0x00	; 0
    53c6:	c9 01       	movw	r24, r18
    53c8:	88 0f       	add	r24, r24
    53ca:	99 1f       	adc	r25, r25
    53cc:	82 0f       	add	r24, r18
    53ce:	93 1f       	adc	r25, r19
    53d0:	01 96       	adiw	r24, 0x01	; 1
    53d2:	88 0f       	add	r24, r24
    53d4:	99 1f       	adc	r25, r25
    53d6:	fc 01       	movw	r30, r24
    53d8:	ea 53       	subi	r30, 0x3A	; 58
    53da:	ff 4f       	sbci	r31, 0xFF	; 255
    53dc:	80 81       	ld	r24, Z
    53de:	88 23       	and	r24, r24
    53e0:	09 f0       	breq	.+2      	; 0x53e4 <DIO_Init+0x742>
    53e2:	90 c0       	rjmp	.+288    	; 0x5504 <DIO_Init+0x862>
					DDRC &= ~(1u << DIO_Array[LoopIndex].PIN);
    53e4:	a4 e3       	ldi	r26, 0x34	; 52
    53e6:	b0 e0       	ldi	r27, 0x00	; 0
    53e8:	e4 e3       	ldi	r30, 0x34	; 52
    53ea:	f0 e0       	ldi	r31, 0x00	; 0
    53ec:	40 81       	ld	r20, Z
    53ee:	89 81       	ldd	r24, Y+1	; 0x01
    53f0:	28 2f       	mov	r18, r24
    53f2:	30 e0       	ldi	r19, 0x00	; 0
    53f4:	c9 01       	movw	r24, r18
    53f6:	88 0f       	add	r24, r24
    53f8:	99 1f       	adc	r25, r25
    53fa:	82 0f       	add	r24, r18
    53fc:	93 1f       	adc	r25, r19
    53fe:	88 0f       	add	r24, r24
    5400:	99 1f       	adc	r25, r25
    5402:	fc 01       	movw	r30, r24
    5404:	e9 53       	subi	r30, 0x39	; 57
    5406:	ff 4f       	sbci	r31, 0xFF	; 255
    5408:	80 81       	ld	r24, Z
    540a:	28 2f       	mov	r18, r24
    540c:	30 e0       	ldi	r19, 0x00	; 0
    540e:	81 e0       	ldi	r24, 0x01	; 1
    5410:	90 e0       	ldi	r25, 0x00	; 0
    5412:	02 c0       	rjmp	.+4      	; 0x5418 <DIO_Init+0x776>
    5414:	88 0f       	add	r24, r24
    5416:	99 1f       	adc	r25, r25
    5418:	2a 95       	dec	r18
    541a:	e2 f7       	brpl	.-8      	; 0x5414 <DIO_Init+0x772>
    541c:	80 95       	com	r24
    541e:	84 23       	and	r24, r20
    5420:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Res == PULLUP) {
    5422:	89 81       	ldd	r24, Y+1	; 0x01
    5424:	28 2f       	mov	r18, r24
    5426:	30 e0       	ldi	r19, 0x00	; 0
    5428:	c9 01       	movw	r24, r18
    542a:	88 0f       	add	r24, r24
    542c:	99 1f       	adc	r25, r25
    542e:	82 0f       	add	r24, r18
    5430:	93 1f       	adc	r25, r19
    5432:	88 0f       	add	r24, r24
    5434:	99 1f       	adc	r25, r25
    5436:	fc 01       	movw	r30, r24
    5438:	e6 53       	subi	r30, 0x36	; 54
    543a:	ff 4f       	sbci	r31, 0xFF	; 255
    543c:	80 81       	ld	r24, Z
    543e:	81 30       	cpi	r24, 0x01	; 1
    5440:	01 f5       	brne	.+64     	; 0x5482 <DIO_Init+0x7e0>
						PORTC |= (1u << DIO_Array[LoopIndex].PIN);
    5442:	a5 e3       	ldi	r26, 0x35	; 53
    5444:	b0 e0       	ldi	r27, 0x00	; 0
    5446:	e5 e3       	ldi	r30, 0x35	; 53
    5448:	f0 e0       	ldi	r31, 0x00	; 0
    544a:	40 81       	ld	r20, Z
    544c:	89 81       	ldd	r24, Y+1	; 0x01
    544e:	28 2f       	mov	r18, r24
    5450:	30 e0       	ldi	r19, 0x00	; 0
    5452:	c9 01       	movw	r24, r18
    5454:	88 0f       	add	r24, r24
    5456:	99 1f       	adc	r25, r25
    5458:	82 0f       	add	r24, r18
    545a:	93 1f       	adc	r25, r19
    545c:	88 0f       	add	r24, r24
    545e:	99 1f       	adc	r25, r25
    5460:	fc 01       	movw	r30, r24
    5462:	e9 53       	subi	r30, 0x39	; 57
    5464:	ff 4f       	sbci	r31, 0xFF	; 255
    5466:	80 81       	ld	r24, Z
    5468:	28 2f       	mov	r18, r24
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	81 e0       	ldi	r24, 0x01	; 1
    546e:	90 e0       	ldi	r25, 0x00	; 0
    5470:	02 2e       	mov	r0, r18
    5472:	02 c0       	rjmp	.+4      	; 0x5478 <DIO_Init+0x7d6>
    5474:	88 0f       	add	r24, r24
    5476:	99 1f       	adc	r25, r25
    5478:	0a 94       	dec	r0
    547a:	e2 f7       	brpl	.-8      	; 0x5474 <DIO_Init+0x7d2>
    547c:	84 2b       	or	r24, r20
    547e:	8c 93       	st	X, r24
    5480:	b3 c1       	rjmp	.+870    	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Res == EXTRES) {
    5482:	89 81       	ldd	r24, Y+1	; 0x01
    5484:	28 2f       	mov	r18, r24
    5486:	30 e0       	ldi	r19, 0x00	; 0
    5488:	c9 01       	movw	r24, r18
    548a:	88 0f       	add	r24, r24
    548c:	99 1f       	adc	r25, r25
    548e:	82 0f       	add	r24, r18
    5490:	93 1f       	adc	r25, r19
    5492:	88 0f       	add	r24, r24
    5494:	99 1f       	adc	r25, r25
    5496:	fc 01       	movw	r30, r24
    5498:	e6 53       	subi	r30, 0x36	; 54
    549a:	ff 4f       	sbci	r31, 0xFF	; 255
    549c:	80 81       	ld	r24, Z
    549e:	88 23       	and	r24, r24
    54a0:	09 f5       	brne	.+66     	; 0x54e4 <DIO_Init+0x842>
						PORTC &= ~(1u << DIO_Array[LoopIndex].PIN);
    54a2:	a5 e3       	ldi	r26, 0x35	; 53
    54a4:	b0 e0       	ldi	r27, 0x00	; 0
    54a6:	e5 e3       	ldi	r30, 0x35	; 53
    54a8:	f0 e0       	ldi	r31, 0x00	; 0
    54aa:	40 81       	ld	r20, Z
    54ac:	89 81       	ldd	r24, Y+1	; 0x01
    54ae:	28 2f       	mov	r18, r24
    54b0:	30 e0       	ldi	r19, 0x00	; 0
    54b2:	c9 01       	movw	r24, r18
    54b4:	88 0f       	add	r24, r24
    54b6:	99 1f       	adc	r25, r25
    54b8:	82 0f       	add	r24, r18
    54ba:	93 1f       	adc	r25, r19
    54bc:	88 0f       	add	r24, r24
    54be:	99 1f       	adc	r25, r25
    54c0:	fc 01       	movw	r30, r24
    54c2:	e9 53       	subi	r30, 0x39	; 57
    54c4:	ff 4f       	sbci	r31, 0xFF	; 255
    54c6:	80 81       	ld	r24, Z
    54c8:	28 2f       	mov	r18, r24
    54ca:	30 e0       	ldi	r19, 0x00	; 0
    54cc:	81 e0       	ldi	r24, 0x01	; 1
    54ce:	90 e0       	ldi	r25, 0x00	; 0
    54d0:	02 2e       	mov	r0, r18
    54d2:	02 c0       	rjmp	.+4      	; 0x54d8 <DIO_Init+0x836>
    54d4:	88 0f       	add	r24, r24
    54d6:	99 1f       	adc	r25, r25
    54d8:	0a 94       	dec	r0
    54da:	e2 f7       	brpl	.-8      	; 0x54d4 <DIO_Init+0x832>
    54dc:	80 95       	com	r24
    54de:	84 23       	and	r24, r20
    54e0:	8c 93       	st	X, r24
    54e2:	82 c1       	rjmp	.+772    	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    54e4:	89 81       	ldd	r24, Y+1	; 0x01
    54e6:	28 2f       	mov	r18, r24
    54e8:	30 e0       	ldi	r19, 0x00	; 0
    54ea:	c9 01       	movw	r24, r18
    54ec:	88 0f       	add	r24, r24
    54ee:	99 1f       	adc	r25, r25
    54f0:	82 0f       	add	r24, r18
    54f2:	93 1f       	adc	r25, r19
    54f4:	88 0f       	add	r24, r24
    54f6:	99 1f       	adc	r25, r25
    54f8:	fc 01       	movw	r30, r24
    54fa:	e5 53       	subi	r30, 0x35	; 53
    54fc:	ff 4f       	sbci	r31, 0xFF	; 255
    54fe:	10 82       	st	Z, r1
						RetVal = NOK;
    5500:	1a 82       	std	Y+2, r1	; 0x02
    5502:	72 c1       	rjmp	.+740    	; 0x57e8 <DIO_Init+0xb46>
					}
					} else {
					DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    5504:	89 81       	ldd	r24, Y+1	; 0x01
    5506:	28 2f       	mov	r18, r24
    5508:	30 e0       	ldi	r19, 0x00	; 0
    550a:	c9 01       	movw	r24, r18
    550c:	88 0f       	add	r24, r24
    550e:	99 1f       	adc	r25, r25
    5510:	82 0f       	add	r24, r18
    5512:	93 1f       	adc	r25, r19
    5514:	88 0f       	add	r24, r24
    5516:	99 1f       	adc	r25, r25
    5518:	fc 01       	movw	r30, r24
    551a:	e5 53       	subi	r30, 0x35	; 53
    551c:	ff 4f       	sbci	r31, 0xFF	; 255
    551e:	10 82       	st	Z, r1
					RetVal = NOK;
    5520:	1a 82       	std	Y+2, r1	; 0x02
    5522:	62 c1       	rjmp	.+708    	; 0x57e8 <DIO_Init+0xb46>
				}
				break;
				case PORT_D:

				if (DIO_Array[LoopIndex].Dir == OUTPUT) {
    5524:	89 81       	ldd	r24, Y+1	; 0x01
    5526:	28 2f       	mov	r18, r24
    5528:	30 e0       	ldi	r19, 0x00	; 0
    552a:	c9 01       	movw	r24, r18
    552c:	88 0f       	add	r24, r24
    552e:	99 1f       	adc	r25, r25
    5530:	82 0f       	add	r24, r18
    5532:	93 1f       	adc	r25, r19
    5534:	01 96       	adiw	r24, 0x01	; 1
    5536:	88 0f       	add	r24, r24
    5538:	99 1f       	adc	r25, r25
    553a:	fc 01       	movw	r30, r24
    553c:	ea 53       	subi	r30, 0x3A	; 58
    553e:	ff 4f       	sbci	r31, 0xFF	; 255
    5540:	80 81       	ld	r24, Z
    5542:	81 30       	cpi	r24, 0x01	; 1
    5544:	09 f0       	breq	.+2      	; 0x5548 <DIO_Init+0x8a6>
    5546:	8f c0       	rjmp	.+286    	; 0x5666 <DIO_Init+0x9c4>
					DDRD |= (1u << DIO_Array[LoopIndex].PIN);
    5548:	a1 e3       	ldi	r26, 0x31	; 49
    554a:	b0 e0       	ldi	r27, 0x00	; 0
    554c:	e1 e3       	ldi	r30, 0x31	; 49
    554e:	f0 e0       	ldi	r31, 0x00	; 0
    5550:	40 81       	ld	r20, Z
    5552:	89 81       	ldd	r24, Y+1	; 0x01
    5554:	28 2f       	mov	r18, r24
    5556:	30 e0       	ldi	r19, 0x00	; 0
    5558:	c9 01       	movw	r24, r18
    555a:	88 0f       	add	r24, r24
    555c:	99 1f       	adc	r25, r25
    555e:	82 0f       	add	r24, r18
    5560:	93 1f       	adc	r25, r19
    5562:	88 0f       	add	r24, r24
    5564:	99 1f       	adc	r25, r25
    5566:	fc 01       	movw	r30, r24
    5568:	e9 53       	subi	r30, 0x39	; 57
    556a:	ff 4f       	sbci	r31, 0xFF	; 255
    556c:	80 81       	ld	r24, Z
    556e:	28 2f       	mov	r18, r24
    5570:	30 e0       	ldi	r19, 0x00	; 0
    5572:	81 e0       	ldi	r24, 0x01	; 1
    5574:	90 e0       	ldi	r25, 0x00	; 0
    5576:	02 c0       	rjmp	.+4      	; 0x557c <DIO_Init+0x8da>
    5578:	88 0f       	add	r24, r24
    557a:	99 1f       	adc	r25, r25
    557c:	2a 95       	dec	r18
    557e:	e2 f7       	brpl	.-8      	; 0x5578 <DIO_Init+0x8d6>
    5580:	84 2b       	or	r24, r20
    5582:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Val == HIGH) {
    5584:	89 81       	ldd	r24, Y+1	; 0x01
    5586:	28 2f       	mov	r18, r24
    5588:	30 e0       	ldi	r19, 0x00	; 0
    558a:	c9 01       	movw	r24, r18
    558c:	88 0f       	add	r24, r24
    558e:	99 1f       	adc	r25, r25
    5590:	82 0f       	add	r24, r18
    5592:	93 1f       	adc	r25, r19
    5594:	88 0f       	add	r24, r24
    5596:	99 1f       	adc	r25, r25
    5598:	fc 01       	movw	r30, r24
    559a:	e7 53       	subi	r30, 0x37	; 55
    559c:	ff 4f       	sbci	r31, 0xFF	; 255
    559e:	80 81       	ld	r24, Z
    55a0:	81 30       	cpi	r24, 0x01	; 1
    55a2:	01 f5       	brne	.+64     	; 0x55e4 <DIO_Init+0x942>
						PORTD |= (1u << DIO_Array[LoopIndex].PIN);
    55a4:	a2 e3       	ldi	r26, 0x32	; 50
    55a6:	b0 e0       	ldi	r27, 0x00	; 0
    55a8:	e2 e3       	ldi	r30, 0x32	; 50
    55aa:	f0 e0       	ldi	r31, 0x00	; 0
    55ac:	40 81       	ld	r20, Z
    55ae:	89 81       	ldd	r24, Y+1	; 0x01
    55b0:	28 2f       	mov	r18, r24
    55b2:	30 e0       	ldi	r19, 0x00	; 0
    55b4:	c9 01       	movw	r24, r18
    55b6:	88 0f       	add	r24, r24
    55b8:	99 1f       	adc	r25, r25
    55ba:	82 0f       	add	r24, r18
    55bc:	93 1f       	adc	r25, r19
    55be:	88 0f       	add	r24, r24
    55c0:	99 1f       	adc	r25, r25
    55c2:	fc 01       	movw	r30, r24
    55c4:	e9 53       	subi	r30, 0x39	; 57
    55c6:	ff 4f       	sbci	r31, 0xFF	; 255
    55c8:	80 81       	ld	r24, Z
    55ca:	28 2f       	mov	r18, r24
    55cc:	30 e0       	ldi	r19, 0x00	; 0
    55ce:	81 e0       	ldi	r24, 0x01	; 1
    55d0:	90 e0       	ldi	r25, 0x00	; 0
    55d2:	02 2e       	mov	r0, r18
    55d4:	02 c0       	rjmp	.+4      	; 0x55da <DIO_Init+0x938>
    55d6:	88 0f       	add	r24, r24
    55d8:	99 1f       	adc	r25, r25
    55da:	0a 94       	dec	r0
    55dc:	e2 f7       	brpl	.-8      	; 0x55d6 <DIO_Init+0x934>
    55de:	84 2b       	or	r24, r20
    55e0:	8c 93       	st	X, r24
    55e2:	02 c1       	rjmp	.+516    	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Val == LOW) {
    55e4:	89 81       	ldd	r24, Y+1	; 0x01
    55e6:	28 2f       	mov	r18, r24
    55e8:	30 e0       	ldi	r19, 0x00	; 0
    55ea:	c9 01       	movw	r24, r18
    55ec:	88 0f       	add	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	82 0f       	add	r24, r18
    55f2:	93 1f       	adc	r25, r19
    55f4:	88 0f       	add	r24, r24
    55f6:	99 1f       	adc	r25, r25
    55f8:	fc 01       	movw	r30, r24
    55fa:	e7 53       	subi	r30, 0x37	; 55
    55fc:	ff 4f       	sbci	r31, 0xFF	; 255
    55fe:	80 81       	ld	r24, Z
    5600:	88 23       	and	r24, r24
    5602:	09 f5       	brne	.+66     	; 0x5646 <DIO_Init+0x9a4>
						PORTD &= ~(1u << DIO_Array[LoopIndex].PIN);
    5604:	a2 e3       	ldi	r26, 0x32	; 50
    5606:	b0 e0       	ldi	r27, 0x00	; 0
    5608:	e2 e3       	ldi	r30, 0x32	; 50
    560a:	f0 e0       	ldi	r31, 0x00	; 0
    560c:	40 81       	ld	r20, Z
    560e:	89 81       	ldd	r24, Y+1	; 0x01
    5610:	28 2f       	mov	r18, r24
    5612:	30 e0       	ldi	r19, 0x00	; 0
    5614:	c9 01       	movw	r24, r18
    5616:	88 0f       	add	r24, r24
    5618:	99 1f       	adc	r25, r25
    561a:	82 0f       	add	r24, r18
    561c:	93 1f       	adc	r25, r19
    561e:	88 0f       	add	r24, r24
    5620:	99 1f       	adc	r25, r25
    5622:	fc 01       	movw	r30, r24
    5624:	e9 53       	subi	r30, 0x39	; 57
    5626:	ff 4f       	sbci	r31, 0xFF	; 255
    5628:	80 81       	ld	r24, Z
    562a:	28 2f       	mov	r18, r24
    562c:	30 e0       	ldi	r19, 0x00	; 0
    562e:	81 e0       	ldi	r24, 0x01	; 1
    5630:	90 e0       	ldi	r25, 0x00	; 0
    5632:	02 2e       	mov	r0, r18
    5634:	02 c0       	rjmp	.+4      	; 0x563a <DIO_Init+0x998>
    5636:	88 0f       	add	r24, r24
    5638:	99 1f       	adc	r25, r25
    563a:	0a 94       	dec	r0
    563c:	e2 f7       	brpl	.-8      	; 0x5636 <DIO_Init+0x994>
    563e:	80 95       	com	r24
    5640:	84 23       	and	r24, r20
    5642:	8c 93       	st	X, r24
    5644:	d1 c0       	rjmp	.+418    	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    5646:	89 81       	ldd	r24, Y+1	; 0x01
    5648:	28 2f       	mov	r18, r24
    564a:	30 e0       	ldi	r19, 0x00	; 0
    564c:	c9 01       	movw	r24, r18
    564e:	88 0f       	add	r24, r24
    5650:	99 1f       	adc	r25, r25
    5652:	82 0f       	add	r24, r18
    5654:	93 1f       	adc	r25, r19
    5656:	88 0f       	add	r24, r24
    5658:	99 1f       	adc	r25, r25
    565a:	fc 01       	movw	r30, r24
    565c:	e5 53       	subi	r30, 0x35	; 53
    565e:	ff 4f       	sbci	r31, 0xFF	; 255
    5660:	10 82       	st	Z, r1
						RetVal = NOK;
    5662:	1a 82       	std	Y+2, r1	; 0x02
    5664:	c1 c0       	rjmp	.+386    	; 0x57e8 <DIO_Init+0xb46>
					}
					} else if (DIO_Array[LoopIndex].Dir == INPUT) {
    5666:	89 81       	ldd	r24, Y+1	; 0x01
    5668:	28 2f       	mov	r18, r24
    566a:	30 e0       	ldi	r19, 0x00	; 0
    566c:	c9 01       	movw	r24, r18
    566e:	88 0f       	add	r24, r24
    5670:	99 1f       	adc	r25, r25
    5672:	82 0f       	add	r24, r18
    5674:	93 1f       	adc	r25, r19
    5676:	01 96       	adiw	r24, 0x01	; 1
    5678:	88 0f       	add	r24, r24
    567a:	99 1f       	adc	r25, r25
    567c:	fc 01       	movw	r30, r24
    567e:	ea 53       	subi	r30, 0x3A	; 58
    5680:	ff 4f       	sbci	r31, 0xFF	; 255
    5682:	80 81       	ld	r24, Z
    5684:	88 23       	and	r24, r24
    5686:	09 f0       	breq	.+2      	; 0x568a <DIO_Init+0x9e8>
    5688:	90 c0       	rjmp	.+288    	; 0x57aa <DIO_Init+0xb08>
					DDRD &= ~(1u << DIO_Array[LoopIndex].PIN);
    568a:	a1 e3       	ldi	r26, 0x31	; 49
    568c:	b0 e0       	ldi	r27, 0x00	; 0
    568e:	e1 e3       	ldi	r30, 0x31	; 49
    5690:	f0 e0       	ldi	r31, 0x00	; 0
    5692:	40 81       	ld	r20, Z
    5694:	89 81       	ldd	r24, Y+1	; 0x01
    5696:	28 2f       	mov	r18, r24
    5698:	30 e0       	ldi	r19, 0x00	; 0
    569a:	c9 01       	movw	r24, r18
    569c:	88 0f       	add	r24, r24
    569e:	99 1f       	adc	r25, r25
    56a0:	82 0f       	add	r24, r18
    56a2:	93 1f       	adc	r25, r19
    56a4:	88 0f       	add	r24, r24
    56a6:	99 1f       	adc	r25, r25
    56a8:	fc 01       	movw	r30, r24
    56aa:	e9 53       	subi	r30, 0x39	; 57
    56ac:	ff 4f       	sbci	r31, 0xFF	; 255
    56ae:	80 81       	ld	r24, Z
    56b0:	28 2f       	mov	r18, r24
    56b2:	30 e0       	ldi	r19, 0x00	; 0
    56b4:	81 e0       	ldi	r24, 0x01	; 1
    56b6:	90 e0       	ldi	r25, 0x00	; 0
    56b8:	02 c0       	rjmp	.+4      	; 0x56be <DIO_Init+0xa1c>
    56ba:	88 0f       	add	r24, r24
    56bc:	99 1f       	adc	r25, r25
    56be:	2a 95       	dec	r18
    56c0:	e2 f7       	brpl	.-8      	; 0x56ba <DIO_Init+0xa18>
    56c2:	80 95       	com	r24
    56c4:	84 23       	and	r24, r20
    56c6:	8c 93       	st	X, r24
					if (DIO_Array[LoopIndex].Res == PULLUP) {
    56c8:	89 81       	ldd	r24, Y+1	; 0x01
    56ca:	28 2f       	mov	r18, r24
    56cc:	30 e0       	ldi	r19, 0x00	; 0
    56ce:	c9 01       	movw	r24, r18
    56d0:	88 0f       	add	r24, r24
    56d2:	99 1f       	adc	r25, r25
    56d4:	82 0f       	add	r24, r18
    56d6:	93 1f       	adc	r25, r19
    56d8:	88 0f       	add	r24, r24
    56da:	99 1f       	adc	r25, r25
    56dc:	fc 01       	movw	r30, r24
    56de:	e6 53       	subi	r30, 0x36	; 54
    56e0:	ff 4f       	sbci	r31, 0xFF	; 255
    56e2:	80 81       	ld	r24, Z
    56e4:	81 30       	cpi	r24, 0x01	; 1
    56e6:	01 f5       	brne	.+64     	; 0x5728 <DIO_Init+0xa86>
						PORTD |= (1u << DIO_Array[LoopIndex].PIN);
    56e8:	a2 e3       	ldi	r26, 0x32	; 50
    56ea:	b0 e0       	ldi	r27, 0x00	; 0
    56ec:	e2 e3       	ldi	r30, 0x32	; 50
    56ee:	f0 e0       	ldi	r31, 0x00	; 0
    56f0:	40 81       	ld	r20, Z
    56f2:	89 81       	ldd	r24, Y+1	; 0x01
    56f4:	28 2f       	mov	r18, r24
    56f6:	30 e0       	ldi	r19, 0x00	; 0
    56f8:	c9 01       	movw	r24, r18
    56fa:	88 0f       	add	r24, r24
    56fc:	99 1f       	adc	r25, r25
    56fe:	82 0f       	add	r24, r18
    5700:	93 1f       	adc	r25, r19
    5702:	88 0f       	add	r24, r24
    5704:	99 1f       	adc	r25, r25
    5706:	fc 01       	movw	r30, r24
    5708:	e9 53       	subi	r30, 0x39	; 57
    570a:	ff 4f       	sbci	r31, 0xFF	; 255
    570c:	80 81       	ld	r24, Z
    570e:	28 2f       	mov	r18, r24
    5710:	30 e0       	ldi	r19, 0x00	; 0
    5712:	81 e0       	ldi	r24, 0x01	; 1
    5714:	90 e0       	ldi	r25, 0x00	; 0
    5716:	02 2e       	mov	r0, r18
    5718:	02 c0       	rjmp	.+4      	; 0x571e <DIO_Init+0xa7c>
    571a:	88 0f       	add	r24, r24
    571c:	99 1f       	adc	r25, r25
    571e:	0a 94       	dec	r0
    5720:	e2 f7       	brpl	.-8      	; 0x571a <DIO_Init+0xa78>
    5722:	84 2b       	or	r24, r20
    5724:	8c 93       	st	X, r24
    5726:	60 c0       	rjmp	.+192    	; 0x57e8 <DIO_Init+0xb46>
						} else if (DIO_Array[LoopIndex].Res == EXTRES) {
    5728:	89 81       	ldd	r24, Y+1	; 0x01
    572a:	28 2f       	mov	r18, r24
    572c:	30 e0       	ldi	r19, 0x00	; 0
    572e:	c9 01       	movw	r24, r18
    5730:	88 0f       	add	r24, r24
    5732:	99 1f       	adc	r25, r25
    5734:	82 0f       	add	r24, r18
    5736:	93 1f       	adc	r25, r19
    5738:	88 0f       	add	r24, r24
    573a:	99 1f       	adc	r25, r25
    573c:	fc 01       	movw	r30, r24
    573e:	e6 53       	subi	r30, 0x36	; 54
    5740:	ff 4f       	sbci	r31, 0xFF	; 255
    5742:	80 81       	ld	r24, Z
    5744:	88 23       	and	r24, r24
    5746:	09 f5       	brne	.+66     	; 0x578a <DIO_Init+0xae8>
						PORTD &= ~(1u << DIO_Array[LoopIndex].PIN);
    5748:	a2 e3       	ldi	r26, 0x32	; 50
    574a:	b0 e0       	ldi	r27, 0x00	; 0
    574c:	e2 e3       	ldi	r30, 0x32	; 50
    574e:	f0 e0       	ldi	r31, 0x00	; 0
    5750:	40 81       	ld	r20, Z
    5752:	89 81       	ldd	r24, Y+1	; 0x01
    5754:	28 2f       	mov	r18, r24
    5756:	30 e0       	ldi	r19, 0x00	; 0
    5758:	c9 01       	movw	r24, r18
    575a:	88 0f       	add	r24, r24
    575c:	99 1f       	adc	r25, r25
    575e:	82 0f       	add	r24, r18
    5760:	93 1f       	adc	r25, r19
    5762:	88 0f       	add	r24, r24
    5764:	99 1f       	adc	r25, r25
    5766:	fc 01       	movw	r30, r24
    5768:	e9 53       	subi	r30, 0x39	; 57
    576a:	ff 4f       	sbci	r31, 0xFF	; 255
    576c:	80 81       	ld	r24, Z
    576e:	28 2f       	mov	r18, r24
    5770:	30 e0       	ldi	r19, 0x00	; 0
    5772:	81 e0       	ldi	r24, 0x01	; 1
    5774:	90 e0       	ldi	r25, 0x00	; 0
    5776:	02 2e       	mov	r0, r18
    5778:	02 c0       	rjmp	.+4      	; 0x577e <DIO_Init+0xadc>
    577a:	88 0f       	add	r24, r24
    577c:	99 1f       	adc	r25, r25
    577e:	0a 94       	dec	r0
    5780:	e2 f7       	brpl	.-8      	; 0x577a <DIO_Init+0xad8>
    5782:	80 95       	com	r24
    5784:	84 23       	and	r24, r20
    5786:	8c 93       	st	X, r24
    5788:	2f c0       	rjmp	.+94     	; 0x57e8 <DIO_Init+0xb46>
						} else {
						DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    578a:	89 81       	ldd	r24, Y+1	; 0x01
    578c:	28 2f       	mov	r18, r24
    578e:	30 e0       	ldi	r19, 0x00	; 0
    5790:	c9 01       	movw	r24, r18
    5792:	88 0f       	add	r24, r24
    5794:	99 1f       	adc	r25, r25
    5796:	82 0f       	add	r24, r18
    5798:	93 1f       	adc	r25, r19
    579a:	88 0f       	add	r24, r24
    579c:	99 1f       	adc	r25, r25
    579e:	fc 01       	movw	r30, r24
    57a0:	e5 53       	subi	r30, 0x35	; 53
    57a2:	ff 4f       	sbci	r31, 0xFF	; 255
    57a4:	10 82       	st	Z, r1
						RetVal = NOK;
    57a6:	1a 82       	std	Y+2, r1	; 0x02
    57a8:	1f c0       	rjmp	.+62     	; 0x57e8 <DIO_Init+0xb46>
					}
					} else {
					DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    57aa:	89 81       	ldd	r24, Y+1	; 0x01
    57ac:	28 2f       	mov	r18, r24
    57ae:	30 e0       	ldi	r19, 0x00	; 0
    57b0:	c9 01       	movw	r24, r18
    57b2:	88 0f       	add	r24, r24
    57b4:	99 1f       	adc	r25, r25
    57b6:	82 0f       	add	r24, r18
    57b8:	93 1f       	adc	r25, r19
    57ba:	88 0f       	add	r24, r24
    57bc:	99 1f       	adc	r25, r25
    57be:	fc 01       	movw	r30, r24
    57c0:	e5 53       	subi	r30, 0x35	; 53
    57c2:	ff 4f       	sbci	r31, 0xFF	; 255
    57c4:	10 82       	st	Z, r1
					RetVal = NOK;
    57c6:	1a 82       	std	Y+2, r1	; 0x02
    57c8:	0f c0       	rjmp	.+30     	; 0x57e8 <DIO_Init+0xb46>
				}
				break;
				default:
				DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
    57ca:	89 81       	ldd	r24, Y+1	; 0x01
    57cc:	28 2f       	mov	r18, r24
    57ce:	30 e0       	ldi	r19, 0x00	; 0
    57d0:	c9 01       	movw	r24, r18
    57d2:	88 0f       	add	r24, r24
    57d4:	99 1f       	adc	r25, r25
    57d6:	82 0f       	add	r24, r18
    57d8:	93 1f       	adc	r25, r19
    57da:	88 0f       	add	r24, r24
    57dc:	99 1f       	adc	r25, r25
    57de:	fc 01       	movw	r30, r24
    57e0:	e5 53       	subi	r30, 0x35	; 53
    57e2:	ff 4f       	sbci	r31, 0xFF	; 255
    57e4:	10 82       	st	Z, r1
				RetVal = NOK;
    57e6:	1a 82       	std	Y+2, r1	; 0x02
	STD_Fun_t RetVal = OK;
	uint8_t LoopIndex;

	if (NUM_PINS <= MAX_NUM_PINS) {

		for (LoopIndex = 0; LoopIndex < NUM_PINS; LoopIndex++) {
    57e8:	89 81       	ldd	r24, Y+1	; 0x01
    57ea:	8f 5f       	subi	r24, 0xFF	; 255
    57ec:	89 83       	std	Y+1, r24	; 0x01
    57ee:	89 81       	ldd	r24, Y+1	; 0x01
    57f0:	8b 30       	cpi	r24, 0x0B	; 11
    57f2:	08 f4       	brcc	.+2      	; 0x57f6 <DIO_Init+0xb54>
    57f4:	60 ca       	rjmp	.-2880   	; 0x4cb6 <DIO_Init+0x14>
			DIO_Array[LoopIndex].IS_Init = NOT_INITIALIZED;
		}

		RetVal = NOK;
	}
	return RetVal;
    57f6:	8a 81       	ldd	r24, Y+2	; 0x02
}
    57f8:	0f 90       	pop	r0
    57fa:	0f 90       	pop	r0
    57fc:	0f 90       	pop	r0
    57fe:	0f 90       	pop	r0
    5800:	cf 91       	pop	r28
    5802:	df 91       	pop	r29
    5804:	08 95       	ret

00005806 <DIO_Write>:


STD_Fun_t DIO_Write(PINS_t pin , uint8_t value)
{
    5806:	df 93       	push	r29
    5808:	cf 93       	push	r28
    580a:	00 d0       	rcall	.+0      	; 0x580c <DIO_Write+0x6>
    580c:	00 d0       	rcall	.+0      	; 0x580e <DIO_Write+0x8>
    580e:	0f 92       	push	r0
    5810:	cd b7       	in	r28, 0x3d	; 61
    5812:	de b7       	in	r29, 0x3e	; 62
    5814:	8a 83       	std	Y+2, r24	; 0x02
    5816:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t state_val = OK;
    5818:	81 e0       	ldi	r24, 0x01	; 1
    581a:	89 83       	std	Y+1, r24	; 0x01
	if (pin <= NUM_PINS - 1)
    581c:	8a 81       	ldd	r24, Y+2	; 0x02
    581e:	8b 30       	cpi	r24, 0x0B	; 11
    5820:	08 f0       	brcs	.+2      	; 0x5824 <DIO_Write+0x1e>
    5822:	64 c1       	rjmp	.+712    	; 0x5aec <DIO_Write+0x2e6>
	{
		if (DIO_Array[pin].IS_Init == INITIALIZED && DIO_Array[pin].Dir == OUTPUT)
    5824:	8a 81       	ldd	r24, Y+2	; 0x02
    5826:	28 2f       	mov	r18, r24
    5828:	30 e0       	ldi	r19, 0x00	; 0
    582a:	c9 01       	movw	r24, r18
    582c:	88 0f       	add	r24, r24
    582e:	99 1f       	adc	r25, r25
    5830:	82 0f       	add	r24, r18
    5832:	93 1f       	adc	r25, r19
    5834:	88 0f       	add	r24, r24
    5836:	99 1f       	adc	r25, r25
    5838:	fc 01       	movw	r30, r24
    583a:	e5 53       	subi	r30, 0x35	; 53
    583c:	ff 4f       	sbci	r31, 0xFF	; 255
    583e:	80 81       	ld	r24, Z
    5840:	81 30       	cpi	r24, 0x01	; 1
    5842:	09 f0       	breq	.+2      	; 0x5846 <DIO_Write+0x40>
    5844:	51 c1       	rjmp	.+674    	; 0x5ae8 <DIO_Write+0x2e2>
    5846:	8a 81       	ldd	r24, Y+2	; 0x02
    5848:	28 2f       	mov	r18, r24
    584a:	30 e0       	ldi	r19, 0x00	; 0
    584c:	c9 01       	movw	r24, r18
    584e:	88 0f       	add	r24, r24
    5850:	99 1f       	adc	r25, r25
    5852:	82 0f       	add	r24, r18
    5854:	93 1f       	adc	r25, r19
    5856:	01 96       	adiw	r24, 0x01	; 1
    5858:	88 0f       	add	r24, r24
    585a:	99 1f       	adc	r25, r25
    585c:	fc 01       	movw	r30, r24
    585e:	ea 53       	subi	r30, 0x3A	; 58
    5860:	ff 4f       	sbci	r31, 0xFF	; 255
    5862:	80 81       	ld	r24, Z
    5864:	81 30       	cpi	r24, 0x01	; 1
    5866:	09 f0       	breq	.+2      	; 0x586a <DIO_Write+0x64>
    5868:	3f c1       	rjmp	.+638    	; 0x5ae8 <DIO_Write+0x2e2>
		{
			switch(DIO_Array[pin].PORT)
    586a:	8a 81       	ldd	r24, Y+2	; 0x02
    586c:	28 2f       	mov	r18, r24
    586e:	30 e0       	ldi	r19, 0x00	; 0
    5870:	c9 01       	movw	r24, r18
    5872:	88 0f       	add	r24, r24
    5874:	99 1f       	adc	r25, r25
    5876:	82 0f       	add	r24, r18
    5878:	93 1f       	adc	r25, r19
    587a:	88 0f       	add	r24, r24
    587c:	99 1f       	adc	r25, r25
    587e:	fc 01       	movw	r30, r24
    5880:	ea 53       	subi	r30, 0x3A	; 58
    5882:	ff 4f       	sbci	r31, 0xFF	; 255
    5884:	80 81       	ld	r24, Z
    5886:	28 2f       	mov	r18, r24
    5888:	30 e0       	ldi	r19, 0x00	; 0
    588a:	3d 83       	std	Y+5, r19	; 0x05
    588c:	2c 83       	std	Y+4, r18	; 0x04
    588e:	8c 81       	ldd	r24, Y+4	; 0x04
    5890:	9d 81       	ldd	r25, Y+5	; 0x05
    5892:	81 30       	cpi	r24, 0x01	; 1
    5894:	91 05       	cpc	r25, r1
    5896:	09 f4       	brne	.+2      	; 0x589a <DIO_Write+0x94>
    5898:	5b c0       	rjmp	.+182    	; 0x5950 <DIO_Write+0x14a>
    589a:	2c 81       	ldd	r18, Y+4	; 0x04
    589c:	3d 81       	ldd	r19, Y+5	; 0x05
    589e:	22 30       	cpi	r18, 0x02	; 2
    58a0:	31 05       	cpc	r19, r1
    58a2:	2c f4       	brge	.+10     	; 0x58ae <DIO_Write+0xa8>
    58a4:	8c 81       	ldd	r24, Y+4	; 0x04
    58a6:	9d 81       	ldd	r25, Y+5	; 0x05
    58a8:	00 97       	sbiw	r24, 0x00	; 0
    58aa:	71 f0       	breq	.+28     	; 0x58c8 <DIO_Write+0xc2>
    58ac:	20 c1       	rjmp	.+576    	; 0x5aee <DIO_Write+0x2e8>
    58ae:	2c 81       	ldd	r18, Y+4	; 0x04
    58b0:	3d 81       	ldd	r19, Y+5	; 0x05
    58b2:	22 30       	cpi	r18, 0x02	; 2
    58b4:	31 05       	cpc	r19, r1
    58b6:	09 f4       	brne	.+2      	; 0x58ba <DIO_Write+0xb4>
    58b8:	8f c0       	rjmp	.+286    	; 0x59d8 <DIO_Write+0x1d2>
    58ba:	8c 81       	ldd	r24, Y+4	; 0x04
    58bc:	9d 81       	ldd	r25, Y+5	; 0x05
    58be:	83 30       	cpi	r24, 0x03	; 3
    58c0:	91 05       	cpc	r25, r1
    58c2:	09 f4       	brne	.+2      	; 0x58c6 <DIO_Write+0xc0>
    58c4:	cd c0       	rjmp	.+410    	; 0x5a60 <DIO_Write+0x25a>
    58c6:	13 c1       	rjmp	.+550    	; 0x5aee <DIO_Write+0x2e8>
			{
				case PORT_A:
				if (value == HIGH)
    58c8:	8b 81       	ldd	r24, Y+3	; 0x03
    58ca:	81 30       	cpi	r24, 0x01	; 1
    58cc:	01 f5       	brne	.+64     	; 0x590e <DIO_Write+0x108>
				{
					PORTA |=(1u<<DIO_Array[pin].PIN);
    58ce:	ab e3       	ldi	r26, 0x3B	; 59
    58d0:	b0 e0       	ldi	r27, 0x00	; 0
    58d2:	eb e3       	ldi	r30, 0x3B	; 59
    58d4:	f0 e0       	ldi	r31, 0x00	; 0
    58d6:	40 81       	ld	r20, Z
    58d8:	8a 81       	ldd	r24, Y+2	; 0x02
    58da:	28 2f       	mov	r18, r24
    58dc:	30 e0       	ldi	r19, 0x00	; 0
    58de:	c9 01       	movw	r24, r18
    58e0:	88 0f       	add	r24, r24
    58e2:	99 1f       	adc	r25, r25
    58e4:	82 0f       	add	r24, r18
    58e6:	93 1f       	adc	r25, r19
    58e8:	88 0f       	add	r24, r24
    58ea:	99 1f       	adc	r25, r25
    58ec:	fc 01       	movw	r30, r24
    58ee:	e9 53       	subi	r30, 0x39	; 57
    58f0:	ff 4f       	sbci	r31, 0xFF	; 255
    58f2:	80 81       	ld	r24, Z
    58f4:	28 2f       	mov	r18, r24
    58f6:	30 e0       	ldi	r19, 0x00	; 0
    58f8:	81 e0       	ldi	r24, 0x01	; 1
    58fa:	90 e0       	ldi	r25, 0x00	; 0
    58fc:	02 2e       	mov	r0, r18
    58fe:	02 c0       	rjmp	.+4      	; 0x5904 <DIO_Write+0xfe>
    5900:	88 0f       	add	r24, r24
    5902:	99 1f       	adc	r25, r25
    5904:	0a 94       	dec	r0
    5906:	e2 f7       	brpl	.-8      	; 0x5900 <DIO_Write+0xfa>
    5908:	84 2b       	or	r24, r20
    590a:	8c 93       	st	X, r24
    590c:	f0 c0       	rjmp	.+480    	; 0x5aee <DIO_Write+0x2e8>
				}
				else
				{
					PORTA &=~(1u<<DIO_Array[pin].PIN);
    590e:	ab e3       	ldi	r26, 0x3B	; 59
    5910:	b0 e0       	ldi	r27, 0x00	; 0
    5912:	eb e3       	ldi	r30, 0x3B	; 59
    5914:	f0 e0       	ldi	r31, 0x00	; 0
    5916:	40 81       	ld	r20, Z
    5918:	8a 81       	ldd	r24, Y+2	; 0x02
    591a:	28 2f       	mov	r18, r24
    591c:	30 e0       	ldi	r19, 0x00	; 0
    591e:	c9 01       	movw	r24, r18
    5920:	88 0f       	add	r24, r24
    5922:	99 1f       	adc	r25, r25
    5924:	82 0f       	add	r24, r18
    5926:	93 1f       	adc	r25, r19
    5928:	88 0f       	add	r24, r24
    592a:	99 1f       	adc	r25, r25
    592c:	fc 01       	movw	r30, r24
    592e:	e9 53       	subi	r30, 0x39	; 57
    5930:	ff 4f       	sbci	r31, 0xFF	; 255
    5932:	80 81       	ld	r24, Z
    5934:	28 2f       	mov	r18, r24
    5936:	30 e0       	ldi	r19, 0x00	; 0
    5938:	81 e0       	ldi	r24, 0x01	; 1
    593a:	90 e0       	ldi	r25, 0x00	; 0
    593c:	02 2e       	mov	r0, r18
    593e:	02 c0       	rjmp	.+4      	; 0x5944 <DIO_Write+0x13e>
    5940:	88 0f       	add	r24, r24
    5942:	99 1f       	adc	r25, r25
    5944:	0a 94       	dec	r0
    5946:	e2 f7       	brpl	.-8      	; 0x5940 <DIO_Write+0x13a>
    5948:	80 95       	com	r24
    594a:	84 23       	and	r24, r20
    594c:	8c 93       	st	X, r24
    594e:	cf c0       	rjmp	.+414    	; 0x5aee <DIO_Write+0x2e8>
				}
				break;
				case PORT_B:
				if (value == HIGH)
    5950:	8b 81       	ldd	r24, Y+3	; 0x03
    5952:	81 30       	cpi	r24, 0x01	; 1
    5954:	01 f5       	brne	.+64     	; 0x5996 <DIO_Write+0x190>
				{
					PORTB |=(1u<<DIO_Array[pin].PIN);
    5956:	a8 e3       	ldi	r26, 0x38	; 56
    5958:	b0 e0       	ldi	r27, 0x00	; 0
    595a:	e8 e3       	ldi	r30, 0x38	; 56
    595c:	f0 e0       	ldi	r31, 0x00	; 0
    595e:	40 81       	ld	r20, Z
    5960:	8a 81       	ldd	r24, Y+2	; 0x02
    5962:	28 2f       	mov	r18, r24
    5964:	30 e0       	ldi	r19, 0x00	; 0
    5966:	c9 01       	movw	r24, r18
    5968:	88 0f       	add	r24, r24
    596a:	99 1f       	adc	r25, r25
    596c:	82 0f       	add	r24, r18
    596e:	93 1f       	adc	r25, r19
    5970:	88 0f       	add	r24, r24
    5972:	99 1f       	adc	r25, r25
    5974:	fc 01       	movw	r30, r24
    5976:	e9 53       	subi	r30, 0x39	; 57
    5978:	ff 4f       	sbci	r31, 0xFF	; 255
    597a:	80 81       	ld	r24, Z
    597c:	28 2f       	mov	r18, r24
    597e:	30 e0       	ldi	r19, 0x00	; 0
    5980:	81 e0       	ldi	r24, 0x01	; 1
    5982:	90 e0       	ldi	r25, 0x00	; 0
    5984:	02 2e       	mov	r0, r18
    5986:	02 c0       	rjmp	.+4      	; 0x598c <DIO_Write+0x186>
    5988:	88 0f       	add	r24, r24
    598a:	99 1f       	adc	r25, r25
    598c:	0a 94       	dec	r0
    598e:	e2 f7       	brpl	.-8      	; 0x5988 <DIO_Write+0x182>
    5990:	84 2b       	or	r24, r20
    5992:	8c 93       	st	X, r24
    5994:	ac c0       	rjmp	.+344    	; 0x5aee <DIO_Write+0x2e8>
				}
				else
				{
					PORTB &=~(1u<<DIO_Array[pin].PIN);
    5996:	a8 e3       	ldi	r26, 0x38	; 56
    5998:	b0 e0       	ldi	r27, 0x00	; 0
    599a:	e8 e3       	ldi	r30, 0x38	; 56
    599c:	f0 e0       	ldi	r31, 0x00	; 0
    599e:	40 81       	ld	r20, Z
    59a0:	8a 81       	ldd	r24, Y+2	; 0x02
    59a2:	28 2f       	mov	r18, r24
    59a4:	30 e0       	ldi	r19, 0x00	; 0
    59a6:	c9 01       	movw	r24, r18
    59a8:	88 0f       	add	r24, r24
    59aa:	99 1f       	adc	r25, r25
    59ac:	82 0f       	add	r24, r18
    59ae:	93 1f       	adc	r25, r19
    59b0:	88 0f       	add	r24, r24
    59b2:	99 1f       	adc	r25, r25
    59b4:	fc 01       	movw	r30, r24
    59b6:	e9 53       	subi	r30, 0x39	; 57
    59b8:	ff 4f       	sbci	r31, 0xFF	; 255
    59ba:	80 81       	ld	r24, Z
    59bc:	28 2f       	mov	r18, r24
    59be:	30 e0       	ldi	r19, 0x00	; 0
    59c0:	81 e0       	ldi	r24, 0x01	; 1
    59c2:	90 e0       	ldi	r25, 0x00	; 0
    59c4:	02 2e       	mov	r0, r18
    59c6:	02 c0       	rjmp	.+4      	; 0x59cc <DIO_Write+0x1c6>
    59c8:	88 0f       	add	r24, r24
    59ca:	99 1f       	adc	r25, r25
    59cc:	0a 94       	dec	r0
    59ce:	e2 f7       	brpl	.-8      	; 0x59c8 <DIO_Write+0x1c2>
    59d0:	80 95       	com	r24
    59d2:	84 23       	and	r24, r20
    59d4:	8c 93       	st	X, r24
    59d6:	8b c0       	rjmp	.+278    	; 0x5aee <DIO_Write+0x2e8>
				}
				break;
				case PORT_C:
				if (value == HIGH)
    59d8:	8b 81       	ldd	r24, Y+3	; 0x03
    59da:	81 30       	cpi	r24, 0x01	; 1
    59dc:	01 f5       	brne	.+64     	; 0x5a1e <DIO_Write+0x218>
				{
					PORTC |=(1u<<DIO_Array[pin].PIN);
    59de:	a5 e3       	ldi	r26, 0x35	; 53
    59e0:	b0 e0       	ldi	r27, 0x00	; 0
    59e2:	e5 e3       	ldi	r30, 0x35	; 53
    59e4:	f0 e0       	ldi	r31, 0x00	; 0
    59e6:	40 81       	ld	r20, Z
    59e8:	8a 81       	ldd	r24, Y+2	; 0x02
    59ea:	28 2f       	mov	r18, r24
    59ec:	30 e0       	ldi	r19, 0x00	; 0
    59ee:	c9 01       	movw	r24, r18
    59f0:	88 0f       	add	r24, r24
    59f2:	99 1f       	adc	r25, r25
    59f4:	82 0f       	add	r24, r18
    59f6:	93 1f       	adc	r25, r19
    59f8:	88 0f       	add	r24, r24
    59fa:	99 1f       	adc	r25, r25
    59fc:	fc 01       	movw	r30, r24
    59fe:	e9 53       	subi	r30, 0x39	; 57
    5a00:	ff 4f       	sbci	r31, 0xFF	; 255
    5a02:	80 81       	ld	r24, Z
    5a04:	28 2f       	mov	r18, r24
    5a06:	30 e0       	ldi	r19, 0x00	; 0
    5a08:	81 e0       	ldi	r24, 0x01	; 1
    5a0a:	90 e0       	ldi	r25, 0x00	; 0
    5a0c:	02 2e       	mov	r0, r18
    5a0e:	02 c0       	rjmp	.+4      	; 0x5a14 <DIO_Write+0x20e>
    5a10:	88 0f       	add	r24, r24
    5a12:	99 1f       	adc	r25, r25
    5a14:	0a 94       	dec	r0
    5a16:	e2 f7       	brpl	.-8      	; 0x5a10 <DIO_Write+0x20a>
    5a18:	84 2b       	or	r24, r20
    5a1a:	8c 93       	st	X, r24
    5a1c:	68 c0       	rjmp	.+208    	; 0x5aee <DIO_Write+0x2e8>
				}
				else
				{
					PORTC &=~(1u<<DIO_Array[pin].PIN);
    5a1e:	a5 e3       	ldi	r26, 0x35	; 53
    5a20:	b0 e0       	ldi	r27, 0x00	; 0
    5a22:	e5 e3       	ldi	r30, 0x35	; 53
    5a24:	f0 e0       	ldi	r31, 0x00	; 0
    5a26:	40 81       	ld	r20, Z
    5a28:	8a 81       	ldd	r24, Y+2	; 0x02
    5a2a:	28 2f       	mov	r18, r24
    5a2c:	30 e0       	ldi	r19, 0x00	; 0
    5a2e:	c9 01       	movw	r24, r18
    5a30:	88 0f       	add	r24, r24
    5a32:	99 1f       	adc	r25, r25
    5a34:	82 0f       	add	r24, r18
    5a36:	93 1f       	adc	r25, r19
    5a38:	88 0f       	add	r24, r24
    5a3a:	99 1f       	adc	r25, r25
    5a3c:	fc 01       	movw	r30, r24
    5a3e:	e9 53       	subi	r30, 0x39	; 57
    5a40:	ff 4f       	sbci	r31, 0xFF	; 255
    5a42:	80 81       	ld	r24, Z
    5a44:	28 2f       	mov	r18, r24
    5a46:	30 e0       	ldi	r19, 0x00	; 0
    5a48:	81 e0       	ldi	r24, 0x01	; 1
    5a4a:	90 e0       	ldi	r25, 0x00	; 0
    5a4c:	02 2e       	mov	r0, r18
    5a4e:	02 c0       	rjmp	.+4      	; 0x5a54 <DIO_Write+0x24e>
    5a50:	88 0f       	add	r24, r24
    5a52:	99 1f       	adc	r25, r25
    5a54:	0a 94       	dec	r0
    5a56:	e2 f7       	brpl	.-8      	; 0x5a50 <DIO_Write+0x24a>
    5a58:	80 95       	com	r24
    5a5a:	84 23       	and	r24, r20
    5a5c:	8c 93       	st	X, r24
    5a5e:	47 c0       	rjmp	.+142    	; 0x5aee <DIO_Write+0x2e8>
				}
				break;
				case PORT_D:
				if (value == HIGH)
    5a60:	8b 81       	ldd	r24, Y+3	; 0x03
    5a62:	81 30       	cpi	r24, 0x01	; 1
    5a64:	01 f5       	brne	.+64     	; 0x5aa6 <DIO_Write+0x2a0>
				{
					PORTD |=(1u<<DIO_Array[pin].PIN);
    5a66:	a2 e3       	ldi	r26, 0x32	; 50
    5a68:	b0 e0       	ldi	r27, 0x00	; 0
    5a6a:	e2 e3       	ldi	r30, 0x32	; 50
    5a6c:	f0 e0       	ldi	r31, 0x00	; 0
    5a6e:	40 81       	ld	r20, Z
    5a70:	8a 81       	ldd	r24, Y+2	; 0x02
    5a72:	28 2f       	mov	r18, r24
    5a74:	30 e0       	ldi	r19, 0x00	; 0
    5a76:	c9 01       	movw	r24, r18
    5a78:	88 0f       	add	r24, r24
    5a7a:	99 1f       	adc	r25, r25
    5a7c:	82 0f       	add	r24, r18
    5a7e:	93 1f       	adc	r25, r19
    5a80:	88 0f       	add	r24, r24
    5a82:	99 1f       	adc	r25, r25
    5a84:	fc 01       	movw	r30, r24
    5a86:	e9 53       	subi	r30, 0x39	; 57
    5a88:	ff 4f       	sbci	r31, 0xFF	; 255
    5a8a:	80 81       	ld	r24, Z
    5a8c:	28 2f       	mov	r18, r24
    5a8e:	30 e0       	ldi	r19, 0x00	; 0
    5a90:	81 e0       	ldi	r24, 0x01	; 1
    5a92:	90 e0       	ldi	r25, 0x00	; 0
    5a94:	02 2e       	mov	r0, r18
    5a96:	02 c0       	rjmp	.+4      	; 0x5a9c <DIO_Write+0x296>
    5a98:	88 0f       	add	r24, r24
    5a9a:	99 1f       	adc	r25, r25
    5a9c:	0a 94       	dec	r0
    5a9e:	e2 f7       	brpl	.-8      	; 0x5a98 <DIO_Write+0x292>
    5aa0:	84 2b       	or	r24, r20
    5aa2:	8c 93       	st	X, r24
    5aa4:	24 c0       	rjmp	.+72     	; 0x5aee <DIO_Write+0x2e8>
				}
				else
				{
					PORTD &=~(1u<<DIO_Array[pin].PIN);
    5aa6:	a2 e3       	ldi	r26, 0x32	; 50
    5aa8:	b0 e0       	ldi	r27, 0x00	; 0
    5aaa:	e2 e3       	ldi	r30, 0x32	; 50
    5aac:	f0 e0       	ldi	r31, 0x00	; 0
    5aae:	40 81       	ld	r20, Z
    5ab0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ab2:	28 2f       	mov	r18, r24
    5ab4:	30 e0       	ldi	r19, 0x00	; 0
    5ab6:	c9 01       	movw	r24, r18
    5ab8:	88 0f       	add	r24, r24
    5aba:	99 1f       	adc	r25, r25
    5abc:	82 0f       	add	r24, r18
    5abe:	93 1f       	adc	r25, r19
    5ac0:	88 0f       	add	r24, r24
    5ac2:	99 1f       	adc	r25, r25
    5ac4:	fc 01       	movw	r30, r24
    5ac6:	e9 53       	subi	r30, 0x39	; 57
    5ac8:	ff 4f       	sbci	r31, 0xFF	; 255
    5aca:	80 81       	ld	r24, Z
    5acc:	28 2f       	mov	r18, r24
    5ace:	30 e0       	ldi	r19, 0x00	; 0
    5ad0:	81 e0       	ldi	r24, 0x01	; 1
    5ad2:	90 e0       	ldi	r25, 0x00	; 0
    5ad4:	02 2e       	mov	r0, r18
    5ad6:	02 c0       	rjmp	.+4      	; 0x5adc <DIO_Write+0x2d6>
    5ad8:	88 0f       	add	r24, r24
    5ada:	99 1f       	adc	r25, r25
    5adc:	0a 94       	dec	r0
    5ade:	e2 f7       	brpl	.-8      	; 0x5ad8 <DIO_Write+0x2d2>
    5ae0:	80 95       	com	r24
    5ae2:	84 23       	and	r24, r20
    5ae4:	8c 93       	st	X, r24
    5ae6:	03 c0       	rjmp	.+6      	; 0x5aee <DIO_Write+0x2e8>
				break;
			}
		}
		else
		{
			state_val = NOK;
    5ae8:	19 82       	std	Y+1, r1	; 0x01
    5aea:	01 c0       	rjmp	.+2      	; 0x5aee <DIO_Write+0x2e8>
		}
	}
	else
	{
		state_val = NOK;
    5aec:	19 82       	std	Y+1, r1	; 0x01
	}
	return state_val;
    5aee:	89 81       	ldd	r24, Y+1	; 0x01
}
    5af0:	0f 90       	pop	r0
    5af2:	0f 90       	pop	r0
    5af4:	0f 90       	pop	r0
    5af6:	0f 90       	pop	r0
    5af8:	0f 90       	pop	r0
    5afa:	cf 91       	pop	r28
    5afc:	df 91       	pop	r29
    5afe:	08 95       	ret

00005b00 <DIO_Read>:



STD_Fun_t DIO_Read( PINS_t pin ,uint8_t *PVal)
{
    5b00:	df 93       	push	r29
    5b02:	cf 93       	push	r28
    5b04:	00 d0       	rcall	.+0      	; 0x5b06 <DIO_Read+0x6>
    5b06:	00 d0       	rcall	.+0      	; 0x5b08 <DIO_Read+0x8>
    5b08:	00 d0       	rcall	.+0      	; 0x5b0a <DIO_Read+0xa>
    5b0a:	cd b7       	in	r28, 0x3d	; 61
    5b0c:	de b7       	in	r29, 0x3e	; 62
    5b0e:	8a 83       	std	Y+2, r24	; 0x02
    5b10:	7c 83       	std	Y+4, r23	; 0x04
    5b12:	6b 83       	std	Y+3, r22	; 0x03
	uint8_t stat_val = OK;
    5b14:	81 e0       	ldi	r24, 0x01	; 1
    5b16:	89 83       	std	Y+1, r24	; 0x01
	if (pin <= NUM_PINS - 1)
    5b18:	8a 81       	ldd	r24, Y+2	; 0x02
    5b1a:	8b 30       	cpi	r24, 0x0B	; 11
    5b1c:	08 f0       	brcs	.+2      	; 0x5b20 <DIO_Read+0x20>
    5b1e:	d7 c0       	rjmp	.+430    	; 0x5cce <DIO_Read+0x1ce>
	{
		if (DIO_Array[pin].IS_Init == INITIALIZED && DIO_Array[pin].Dir == INPUT)
    5b20:	8a 81       	ldd	r24, Y+2	; 0x02
    5b22:	28 2f       	mov	r18, r24
    5b24:	30 e0       	ldi	r19, 0x00	; 0
    5b26:	c9 01       	movw	r24, r18
    5b28:	88 0f       	add	r24, r24
    5b2a:	99 1f       	adc	r25, r25
    5b2c:	82 0f       	add	r24, r18
    5b2e:	93 1f       	adc	r25, r19
    5b30:	88 0f       	add	r24, r24
    5b32:	99 1f       	adc	r25, r25
    5b34:	fc 01       	movw	r30, r24
    5b36:	e5 53       	subi	r30, 0x35	; 53
    5b38:	ff 4f       	sbci	r31, 0xFF	; 255
    5b3a:	80 81       	ld	r24, Z
    5b3c:	81 30       	cpi	r24, 0x01	; 1
    5b3e:	09 f0       	breq	.+2      	; 0x5b42 <DIO_Read+0x42>
    5b40:	c4 c0       	rjmp	.+392    	; 0x5cca <DIO_Read+0x1ca>
    5b42:	8a 81       	ldd	r24, Y+2	; 0x02
    5b44:	28 2f       	mov	r18, r24
    5b46:	30 e0       	ldi	r19, 0x00	; 0
    5b48:	c9 01       	movw	r24, r18
    5b4a:	88 0f       	add	r24, r24
    5b4c:	99 1f       	adc	r25, r25
    5b4e:	82 0f       	add	r24, r18
    5b50:	93 1f       	adc	r25, r19
    5b52:	01 96       	adiw	r24, 0x01	; 1
    5b54:	88 0f       	add	r24, r24
    5b56:	99 1f       	adc	r25, r25
    5b58:	fc 01       	movw	r30, r24
    5b5a:	ea 53       	subi	r30, 0x3A	; 58
    5b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    5b5e:	80 81       	ld	r24, Z
    5b60:	88 23       	and	r24, r24
    5b62:	09 f0       	breq	.+2      	; 0x5b66 <DIO_Read+0x66>
    5b64:	b2 c0       	rjmp	.+356    	; 0x5cca <DIO_Read+0x1ca>
		{
			switch(DIO_Array[pin].PORT)
    5b66:	8a 81       	ldd	r24, Y+2	; 0x02
    5b68:	28 2f       	mov	r18, r24
    5b6a:	30 e0       	ldi	r19, 0x00	; 0
    5b6c:	c9 01       	movw	r24, r18
    5b6e:	88 0f       	add	r24, r24
    5b70:	99 1f       	adc	r25, r25
    5b72:	82 0f       	add	r24, r18
    5b74:	93 1f       	adc	r25, r19
    5b76:	88 0f       	add	r24, r24
    5b78:	99 1f       	adc	r25, r25
    5b7a:	fc 01       	movw	r30, r24
    5b7c:	ea 53       	subi	r30, 0x3A	; 58
    5b7e:	ff 4f       	sbci	r31, 0xFF	; 255
    5b80:	80 81       	ld	r24, Z
    5b82:	28 2f       	mov	r18, r24
    5b84:	30 e0       	ldi	r19, 0x00	; 0
    5b86:	3e 83       	std	Y+6, r19	; 0x06
    5b88:	2d 83       	std	Y+5, r18	; 0x05
    5b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5b8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5b8e:	81 30       	cpi	r24, 0x01	; 1
    5b90:	91 05       	cpc	r25, r1
    5b92:	c1 f1       	breq	.+112    	; 0x5c04 <DIO_Read+0x104>
    5b94:	2d 81       	ldd	r18, Y+5	; 0x05
    5b96:	3e 81       	ldd	r19, Y+6	; 0x06
    5b98:	22 30       	cpi	r18, 0x02	; 2
    5b9a:	31 05       	cpc	r19, r1
    5b9c:	2c f4       	brge	.+10     	; 0x5ba8 <DIO_Read+0xa8>
    5b9e:	8d 81       	ldd	r24, Y+5	; 0x05
    5ba0:	9e 81       	ldd	r25, Y+6	; 0x06
    5ba2:	00 97       	sbiw	r24, 0x00	; 0
    5ba4:	71 f0       	breq	.+28     	; 0x5bc2 <DIO_Read+0xc2>
    5ba6:	94 c0       	rjmp	.+296    	; 0x5cd0 <DIO_Read+0x1d0>
    5ba8:	2d 81       	ldd	r18, Y+5	; 0x05
    5baa:	3e 81       	ldd	r19, Y+6	; 0x06
    5bac:	22 30       	cpi	r18, 0x02	; 2
    5bae:	31 05       	cpc	r19, r1
    5bb0:	09 f4       	brne	.+2      	; 0x5bb4 <DIO_Read+0xb4>
    5bb2:	49 c0       	rjmp	.+146    	; 0x5c46 <DIO_Read+0x146>
    5bb4:	8d 81       	ldd	r24, Y+5	; 0x05
    5bb6:	9e 81       	ldd	r25, Y+6	; 0x06
    5bb8:	83 30       	cpi	r24, 0x03	; 3
    5bba:	91 05       	cpc	r25, r1
    5bbc:	09 f4       	brne	.+2      	; 0x5bc0 <DIO_Read+0xc0>
    5bbe:	64 c0       	rjmp	.+200    	; 0x5c88 <DIO_Read+0x188>
    5bc0:	87 c0       	rjmp	.+270    	; 0x5cd0 <DIO_Read+0x1d0>
			{
				case PORT_A:
				*PVal = ((PINA >> DIO_Array[pin].PIN) & 1u);
    5bc2:	e9 e3       	ldi	r30, 0x39	; 57
    5bc4:	f0 e0       	ldi	r31, 0x00	; 0
    5bc6:	80 81       	ld	r24, Z
    5bc8:	48 2f       	mov	r20, r24
    5bca:	50 e0       	ldi	r21, 0x00	; 0
    5bcc:	8a 81       	ldd	r24, Y+2	; 0x02
    5bce:	28 2f       	mov	r18, r24
    5bd0:	30 e0       	ldi	r19, 0x00	; 0
    5bd2:	c9 01       	movw	r24, r18
    5bd4:	88 0f       	add	r24, r24
    5bd6:	99 1f       	adc	r25, r25
    5bd8:	82 0f       	add	r24, r18
    5bda:	93 1f       	adc	r25, r19
    5bdc:	88 0f       	add	r24, r24
    5bde:	99 1f       	adc	r25, r25
    5be0:	fc 01       	movw	r30, r24
    5be2:	e9 53       	subi	r30, 0x39	; 57
    5be4:	ff 4f       	sbci	r31, 0xFF	; 255
    5be6:	80 81       	ld	r24, Z
    5be8:	88 2f       	mov	r24, r24
    5bea:	90 e0       	ldi	r25, 0x00	; 0
    5bec:	9a 01       	movw	r18, r20
    5bee:	02 c0       	rjmp	.+4      	; 0x5bf4 <DIO_Read+0xf4>
    5bf0:	35 95       	asr	r19
    5bf2:	27 95       	ror	r18
    5bf4:	8a 95       	dec	r24
    5bf6:	e2 f7       	brpl	.-8      	; 0x5bf0 <DIO_Read+0xf0>
    5bf8:	c9 01       	movw	r24, r18
    5bfa:	81 70       	andi	r24, 0x01	; 1
    5bfc:	eb 81       	ldd	r30, Y+3	; 0x03
    5bfe:	fc 81       	ldd	r31, Y+4	; 0x04
    5c00:	80 83       	st	Z, r24
    5c02:	66 c0       	rjmp	.+204    	; 0x5cd0 <DIO_Read+0x1d0>
				break;
				case PORT_B:
				*PVal = ((PINB >> DIO_Array[pin].PIN) & 1u);
    5c04:	e6 e3       	ldi	r30, 0x36	; 54
    5c06:	f0 e0       	ldi	r31, 0x00	; 0
    5c08:	80 81       	ld	r24, Z
    5c0a:	48 2f       	mov	r20, r24
    5c0c:	50 e0       	ldi	r21, 0x00	; 0
    5c0e:	8a 81       	ldd	r24, Y+2	; 0x02
    5c10:	28 2f       	mov	r18, r24
    5c12:	30 e0       	ldi	r19, 0x00	; 0
    5c14:	c9 01       	movw	r24, r18
    5c16:	88 0f       	add	r24, r24
    5c18:	99 1f       	adc	r25, r25
    5c1a:	82 0f       	add	r24, r18
    5c1c:	93 1f       	adc	r25, r19
    5c1e:	88 0f       	add	r24, r24
    5c20:	99 1f       	adc	r25, r25
    5c22:	fc 01       	movw	r30, r24
    5c24:	e9 53       	subi	r30, 0x39	; 57
    5c26:	ff 4f       	sbci	r31, 0xFF	; 255
    5c28:	80 81       	ld	r24, Z
    5c2a:	88 2f       	mov	r24, r24
    5c2c:	90 e0       	ldi	r25, 0x00	; 0
    5c2e:	9a 01       	movw	r18, r20
    5c30:	02 c0       	rjmp	.+4      	; 0x5c36 <DIO_Read+0x136>
    5c32:	35 95       	asr	r19
    5c34:	27 95       	ror	r18
    5c36:	8a 95       	dec	r24
    5c38:	e2 f7       	brpl	.-8      	; 0x5c32 <DIO_Read+0x132>
    5c3a:	c9 01       	movw	r24, r18
    5c3c:	81 70       	andi	r24, 0x01	; 1
    5c3e:	eb 81       	ldd	r30, Y+3	; 0x03
    5c40:	fc 81       	ldd	r31, Y+4	; 0x04
    5c42:	80 83       	st	Z, r24
    5c44:	45 c0       	rjmp	.+138    	; 0x5cd0 <DIO_Read+0x1d0>
				break;
				case PORT_C:
				*PVal = ((PINC >> DIO_Array[pin].PIN) & 1u);
    5c46:	e3 e3       	ldi	r30, 0x33	; 51
    5c48:	f0 e0       	ldi	r31, 0x00	; 0
    5c4a:	80 81       	ld	r24, Z
    5c4c:	48 2f       	mov	r20, r24
    5c4e:	50 e0       	ldi	r21, 0x00	; 0
    5c50:	8a 81       	ldd	r24, Y+2	; 0x02
    5c52:	28 2f       	mov	r18, r24
    5c54:	30 e0       	ldi	r19, 0x00	; 0
    5c56:	c9 01       	movw	r24, r18
    5c58:	88 0f       	add	r24, r24
    5c5a:	99 1f       	adc	r25, r25
    5c5c:	82 0f       	add	r24, r18
    5c5e:	93 1f       	adc	r25, r19
    5c60:	88 0f       	add	r24, r24
    5c62:	99 1f       	adc	r25, r25
    5c64:	fc 01       	movw	r30, r24
    5c66:	e9 53       	subi	r30, 0x39	; 57
    5c68:	ff 4f       	sbci	r31, 0xFF	; 255
    5c6a:	80 81       	ld	r24, Z
    5c6c:	88 2f       	mov	r24, r24
    5c6e:	90 e0       	ldi	r25, 0x00	; 0
    5c70:	9a 01       	movw	r18, r20
    5c72:	02 c0       	rjmp	.+4      	; 0x5c78 <DIO_Read+0x178>
    5c74:	35 95       	asr	r19
    5c76:	27 95       	ror	r18
    5c78:	8a 95       	dec	r24
    5c7a:	e2 f7       	brpl	.-8      	; 0x5c74 <DIO_Read+0x174>
    5c7c:	c9 01       	movw	r24, r18
    5c7e:	81 70       	andi	r24, 0x01	; 1
    5c80:	eb 81       	ldd	r30, Y+3	; 0x03
    5c82:	fc 81       	ldd	r31, Y+4	; 0x04
    5c84:	80 83       	st	Z, r24
    5c86:	24 c0       	rjmp	.+72     	; 0x5cd0 <DIO_Read+0x1d0>
				break;
				case PORT_D:
				*PVal = ((PIND >> DIO_Array[pin].PIN) & 1u);
    5c88:	e0 e3       	ldi	r30, 0x30	; 48
    5c8a:	f0 e0       	ldi	r31, 0x00	; 0
    5c8c:	80 81       	ld	r24, Z
    5c8e:	48 2f       	mov	r20, r24
    5c90:	50 e0       	ldi	r21, 0x00	; 0
    5c92:	8a 81       	ldd	r24, Y+2	; 0x02
    5c94:	28 2f       	mov	r18, r24
    5c96:	30 e0       	ldi	r19, 0x00	; 0
    5c98:	c9 01       	movw	r24, r18
    5c9a:	88 0f       	add	r24, r24
    5c9c:	99 1f       	adc	r25, r25
    5c9e:	82 0f       	add	r24, r18
    5ca0:	93 1f       	adc	r25, r19
    5ca2:	88 0f       	add	r24, r24
    5ca4:	99 1f       	adc	r25, r25
    5ca6:	fc 01       	movw	r30, r24
    5ca8:	e9 53       	subi	r30, 0x39	; 57
    5caa:	ff 4f       	sbci	r31, 0xFF	; 255
    5cac:	80 81       	ld	r24, Z
    5cae:	88 2f       	mov	r24, r24
    5cb0:	90 e0       	ldi	r25, 0x00	; 0
    5cb2:	9a 01       	movw	r18, r20
    5cb4:	02 c0       	rjmp	.+4      	; 0x5cba <DIO_Read+0x1ba>
    5cb6:	35 95       	asr	r19
    5cb8:	27 95       	ror	r18
    5cba:	8a 95       	dec	r24
    5cbc:	e2 f7       	brpl	.-8      	; 0x5cb6 <DIO_Read+0x1b6>
    5cbe:	c9 01       	movw	r24, r18
    5cc0:	81 70       	andi	r24, 0x01	; 1
    5cc2:	eb 81       	ldd	r30, Y+3	; 0x03
    5cc4:	fc 81       	ldd	r31, Y+4	; 0x04
    5cc6:	80 83       	st	Z, r24
    5cc8:	03 c0       	rjmp	.+6      	; 0x5cd0 <DIO_Read+0x1d0>
				break;	
			}
		}
		else
		{
			stat_val = NOK;
    5cca:	19 82       	std	Y+1, r1	; 0x01
    5ccc:	01 c0       	rjmp	.+2      	; 0x5cd0 <DIO_Read+0x1d0>
		}
	}
	else
	{
		stat_val = NOK;
    5cce:	19 82       	std	Y+1, r1	; 0x01
	}
	
	return stat_val;
    5cd0:	89 81       	ldd	r24, Y+1	; 0x01
}
    5cd2:	26 96       	adiw	r28, 0x06	; 6
    5cd4:	0f b6       	in	r0, 0x3f	; 63
    5cd6:	f8 94       	cli
    5cd8:	de bf       	out	0x3e, r29	; 62
    5cda:	0f be       	out	0x3f, r0	; 63
    5cdc:	cd bf       	out	0x3d, r28	; 61
    5cde:	cf 91       	pop	r28
    5ce0:	df 91       	pop	r29
    5ce2:	08 95       	ret

00005ce4 <LCD_sendCommand>:
volatile static uint8_t g_Data_Flag = DATA_FREE;

static volatile Enum_LCDInitState g_InitFlag = LCD_UNINTAILIZED ;

Enum_LCDState LCD_sendCommand(uint8_t COPY_CMND)
{
    5ce4:	df 93       	push	r29
    5ce6:	cf 93       	push	r28
    5ce8:	00 d0       	rcall	.+0      	; 0x5cea <LCD_sendCommand+0x6>
    5cea:	00 d0       	rcall	.+0      	; 0x5cec <LCD_sendCommand+0x8>
    5cec:	cd b7       	in	r28, 0x3d	; 61
    5cee:	de b7       	in	r29, 0x3e	; 62
    5cf0:	8a 83       	std	Y+2, r24	; 0x02
	static uint8_t LOC_CMNDSTATE = 0;
	Enum_LCDState LOC_CMNDStatus = LCD_Pending;
    5cf2:	19 82       	std	Y+1, r1	; 0x01

	switch(LOC_CMNDSTATE)
    5cf4:	80 91 51 07 	lds	r24, 0x0751
    5cf8:	28 2f       	mov	r18, r24
    5cfa:	30 e0       	ldi	r19, 0x00	; 0
    5cfc:	3c 83       	std	Y+4, r19	; 0x04
    5cfe:	2b 83       	std	Y+3, r18	; 0x03
    5d00:	8b 81       	ldd	r24, Y+3	; 0x03
    5d02:	9c 81       	ldd	r25, Y+4	; 0x04
    5d04:	81 30       	cpi	r24, 0x01	; 1
    5d06:	91 05       	cpc	r25, r1
    5d08:	09 f4       	brne	.+2      	; 0x5d0c <LCD_sendCommand+0x28>
    5d0a:	44 c0       	rjmp	.+136    	; 0x5d94 <LCD_sendCommand+0xb0>
    5d0c:	2b 81       	ldd	r18, Y+3	; 0x03
    5d0e:	3c 81       	ldd	r19, Y+4	; 0x04
    5d10:	22 30       	cpi	r18, 0x02	; 2
    5d12:	31 05       	cpc	r19, r1
    5d14:	09 f4       	brne	.+2      	; 0x5d18 <LCD_sendCommand+0x34>
    5d16:	6e c0       	rjmp	.+220    	; 0x5df4 <LCD_sendCommand+0x110>
    5d18:	8b 81       	ldd	r24, Y+3	; 0x03
    5d1a:	9c 81       	ldd	r25, Y+4	; 0x04
    5d1c:	00 97       	sbiw	r24, 0x00	; 0
    5d1e:	09 f0       	breq	.+2      	; 0x5d22 <LCD_sendCommand+0x3e>
    5d20:	71 c0       	rjmp	.+226    	; 0x5e04 <LCD_sendCommand+0x120>
	{
	case 0:
		DIO_Write(RS , LOW);
    5d22:	85 e0       	ldi	r24, 0x05	; 5
    5d24:	60 e0       	ldi	r22, 0x00	; 0
    5d26:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(RW , LOW);
    5d2a:	86 e0       	ldi	r24, 0x06	; 6
    5d2c:	60 e0       	ldi	r22, 0x00	; 0
    5d2e:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

		DIO_Write(LCD_D4 , (COPY_CMND >> 4) &1);
    5d32:	8a 81       	ldd	r24, Y+2	; 0x02
    5d34:	82 95       	swap	r24
    5d36:	8f 70       	andi	r24, 0x0F	; 15
    5d38:	98 2f       	mov	r25, r24
    5d3a:	91 70       	andi	r25, 0x01	; 1
    5d3c:	80 e0       	ldi	r24, 0x00	; 0
    5d3e:	69 2f       	mov	r22, r25
    5d40:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D5 , (COPY_CMND >> 5) &1);
    5d44:	8a 81       	ldd	r24, Y+2	; 0x02
    5d46:	82 95       	swap	r24
    5d48:	86 95       	lsr	r24
    5d4a:	87 70       	andi	r24, 0x07	; 7
    5d4c:	98 2f       	mov	r25, r24
    5d4e:	91 70       	andi	r25, 0x01	; 1
    5d50:	81 e0       	ldi	r24, 0x01	; 1
    5d52:	69 2f       	mov	r22, r25
    5d54:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D6 , (COPY_CMND >> 6) &1);
    5d58:	8a 81       	ldd	r24, Y+2	; 0x02
    5d5a:	82 95       	swap	r24
    5d5c:	86 95       	lsr	r24
    5d5e:	86 95       	lsr	r24
    5d60:	83 70       	andi	r24, 0x03	; 3
    5d62:	98 2f       	mov	r25, r24
    5d64:	91 70       	andi	r25, 0x01	; 1
    5d66:	82 e0       	ldi	r24, 0x02	; 2
    5d68:	69 2f       	mov	r22, r25
    5d6a:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D7 , (COPY_CMND >> 7) &1);
    5d6e:	8a 81       	ldd	r24, Y+2	; 0x02
    5d70:	98 2f       	mov	r25, r24
    5d72:	99 1f       	adc	r25, r25
    5d74:	99 27       	eor	r25, r25
    5d76:	99 1f       	adc	r25, r25
    5d78:	83 e0       	ldi	r24, 0x03	; 3
    5d7a:	69 2f       	mov	r22, r25
    5d7c:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

		DIO_Write( LCD_EN , HIGH);
    5d80:	84 e0       	ldi	r24, 0x04	; 4
    5d82:	61 e0       	ldi	r22, 0x01	; 1
    5d84:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		LOC_CMNDSTATE++;
    5d88:	80 91 51 07 	lds	r24, 0x0751
    5d8c:	8f 5f       	subi	r24, 0xFF	; 255
    5d8e:	80 93 51 07 	sts	0x0751, r24
    5d92:	38 c0       	rjmp	.+112    	; 0x5e04 <LCD_sendCommand+0x120>

		break;
	case 1:
		DIO_Write(LCD_EN , LOW);
    5d94:	84 e0       	ldi	r24, 0x04	; 4
    5d96:	60 e0       	ldi	r22, 0x00	; 0
    5d98:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

		DIO_Write(LCD_D4 , (COPY_CMND >> 0) &1);
    5d9c:	8a 81       	ldd	r24, Y+2	; 0x02
    5d9e:	98 2f       	mov	r25, r24
    5da0:	91 70       	andi	r25, 0x01	; 1
    5da2:	80 e0       	ldi	r24, 0x00	; 0
    5da4:	69 2f       	mov	r22, r25
    5da6:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D5 , (COPY_CMND >> 1) &1);
    5daa:	8a 81       	ldd	r24, Y+2	; 0x02
    5dac:	86 95       	lsr	r24
    5dae:	98 2f       	mov	r25, r24
    5db0:	91 70       	andi	r25, 0x01	; 1
    5db2:	81 e0       	ldi	r24, 0x01	; 1
    5db4:	69 2f       	mov	r22, r25
    5db6:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D6 , (COPY_CMND >> 2) &1);
    5dba:	8a 81       	ldd	r24, Y+2	; 0x02
    5dbc:	86 95       	lsr	r24
    5dbe:	86 95       	lsr	r24
    5dc0:	98 2f       	mov	r25, r24
    5dc2:	91 70       	andi	r25, 0x01	; 1
    5dc4:	82 e0       	ldi	r24, 0x02	; 2
    5dc6:	69 2f       	mov	r22, r25
    5dc8:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		DIO_Write(LCD_D7 , (COPY_CMND >> 3) &1);
    5dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    5dce:	86 95       	lsr	r24
    5dd0:	86 95       	lsr	r24
    5dd2:	86 95       	lsr	r24
    5dd4:	98 2f       	mov	r25, r24
    5dd6:	91 70       	andi	r25, 0x01	; 1
    5dd8:	83 e0       	ldi	r24, 0x03	; 3
    5dda:	69 2f       	mov	r22, r25
    5ddc:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

		DIO_Write( LCD_EN , HIGH);
    5de0:	84 e0       	ldi	r24, 0x04	; 4
    5de2:	61 e0       	ldi	r22, 0x01	; 1
    5de4:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		LOC_CMNDSTATE++;
    5de8:	80 91 51 07 	lds	r24, 0x0751
    5dec:	8f 5f       	subi	r24, 0xFF	; 255
    5dee:	80 93 51 07 	sts	0x0751, r24
    5df2:	08 c0       	rjmp	.+16     	; 0x5e04 <LCD_sendCommand+0x120>

		break;
	case 2:
		DIO_Write(LCD_EN , LOW);
    5df4:	84 e0       	ldi	r24, 0x04	; 4
    5df6:	60 e0       	ldi	r22, 0x00	; 0
    5df8:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		LOC_CMNDSTATE=0;
    5dfc:	10 92 51 07 	sts	0x0751, r1
		LOC_CMNDStatus = LCD_Finished;
    5e00:	81 e0       	ldi	r24, 0x01	; 1
    5e02:	89 83       	std	Y+1, r24	; 0x01
		break;
	}

	return LOC_CMNDStatus;
    5e04:	89 81       	ldd	r24, Y+1	; 0x01
}
    5e06:	0f 90       	pop	r0
    5e08:	0f 90       	pop	r0
    5e0a:	0f 90       	pop	r0
    5e0c:	0f 90       	pop	r0
    5e0e:	cf 91       	pop	r28
    5e10:	df 91       	pop	r29
    5e12:	08 95       	ret

00005e14 <LCD_DataWr>:


Enum_LCDState LCD_DataWr(uint8_t COPY_Data)
{
    5e14:	df 93       	push	r29
    5e16:	cf 93       	push	r28
    5e18:	00 d0       	rcall	.+0      	; 0x5e1a <LCD_DataWr+0x6>
    5e1a:	00 d0       	rcall	.+0      	; 0x5e1c <LCD_DataWr+0x8>
    5e1c:	cd b7       	in	r28, 0x3d	; 61
    5e1e:	de b7       	in	r29, 0x3e	; 62
    5e20:	8a 83       	std	Y+2, r24	; 0x02
	static uint8_t LOC_DataWrState = 0;
	Enum_LCDState LOC_DataWrStatus = LCD_Pending;
    5e22:	19 82       	std	Y+1, r1	; 0x01

	if( LCD_INITALIZED == g_InitFlag )
    5e24:	80 91 50 07 	lds	r24, 0x0750
    5e28:	81 30       	cpi	r24, 0x01	; 1
    5e2a:	09 f0       	breq	.+2      	; 0x5e2e <LCD_DataWr+0x1a>
    5e2c:	88 c0       	rjmp	.+272    	; 0x5f3e <LCD_DataWr+0x12a>
	{
		switch (LOC_DataWrState)
    5e2e:	80 91 52 07 	lds	r24, 0x0752
    5e32:	28 2f       	mov	r18, r24
    5e34:	30 e0       	ldi	r19, 0x00	; 0
    5e36:	3c 83       	std	Y+4, r19	; 0x04
    5e38:	2b 83       	std	Y+3, r18	; 0x03
    5e3a:	8b 81       	ldd	r24, Y+3	; 0x03
    5e3c:	9c 81       	ldd	r25, Y+4	; 0x04
    5e3e:	81 30       	cpi	r24, 0x01	; 1
    5e40:	91 05       	cpc	r25, r1
    5e42:	09 f4       	brne	.+2      	; 0x5e46 <LCD_DataWr+0x32>
    5e44:	44 c0       	rjmp	.+136    	; 0x5ece <LCD_DataWr+0xba>
    5e46:	2b 81       	ldd	r18, Y+3	; 0x03
    5e48:	3c 81       	ldd	r19, Y+4	; 0x04
    5e4a:	22 30       	cpi	r18, 0x02	; 2
    5e4c:	31 05       	cpc	r19, r1
    5e4e:	09 f4       	brne	.+2      	; 0x5e52 <LCD_DataWr+0x3e>
    5e50:	6e c0       	rjmp	.+220    	; 0x5f2e <LCD_DataWr+0x11a>
    5e52:	8b 81       	ldd	r24, Y+3	; 0x03
    5e54:	9c 81       	ldd	r25, Y+4	; 0x04
    5e56:	00 97       	sbiw	r24, 0x00	; 0
    5e58:	09 f0       	breq	.+2      	; 0x5e5c <LCD_DataWr+0x48>
    5e5a:	71 c0       	rjmp	.+226    	; 0x5f3e <LCD_DataWr+0x12a>
		{
		case 0:
			DIO_Write(RS , HIGH);
    5e5c:	85 e0       	ldi	r24, 0x05	; 5
    5e5e:	61 e0       	ldi	r22, 0x01	; 1
    5e60:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(RW , LOW);
    5e64:	86 e0       	ldi	r24, 0x06	; 6
    5e66:	60 e0       	ldi	r22, 0x00	; 0
    5e68:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

			DIO_Write(LCD_D4 , (COPY_Data >> 4) &1 );
    5e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    5e6e:	82 95       	swap	r24
    5e70:	8f 70       	andi	r24, 0x0F	; 15
    5e72:	98 2f       	mov	r25, r24
    5e74:	91 70       	andi	r25, 0x01	; 1
    5e76:	80 e0       	ldi	r24, 0x00	; 0
    5e78:	69 2f       	mov	r22, r25
    5e7a:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D5 , (COPY_Data >> 5) &1 );
    5e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e80:	82 95       	swap	r24
    5e82:	86 95       	lsr	r24
    5e84:	87 70       	andi	r24, 0x07	; 7
    5e86:	98 2f       	mov	r25, r24
    5e88:	91 70       	andi	r25, 0x01	; 1
    5e8a:	81 e0       	ldi	r24, 0x01	; 1
    5e8c:	69 2f       	mov	r22, r25
    5e8e:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D6 , (COPY_Data >> 6) &1 );
    5e92:	8a 81       	ldd	r24, Y+2	; 0x02
    5e94:	82 95       	swap	r24
    5e96:	86 95       	lsr	r24
    5e98:	86 95       	lsr	r24
    5e9a:	83 70       	andi	r24, 0x03	; 3
    5e9c:	98 2f       	mov	r25, r24
    5e9e:	91 70       	andi	r25, 0x01	; 1
    5ea0:	82 e0       	ldi	r24, 0x02	; 2
    5ea2:	69 2f       	mov	r22, r25
    5ea4:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D7 , (COPY_Data >> 7) &1 );
    5ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    5eaa:	98 2f       	mov	r25, r24
    5eac:	99 1f       	adc	r25, r25
    5eae:	99 27       	eor	r25, r25
    5eb0:	99 1f       	adc	r25, r25
    5eb2:	83 e0       	ldi	r24, 0x03	; 3
    5eb4:	69 2f       	mov	r22, r25
    5eb6:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

			DIO_Write( LCD_EN , HIGH);
    5eba:	84 e0       	ldi	r24, 0x04	; 4
    5ebc:	61 e0       	ldi	r22, 0x01	; 1
    5ebe:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			LOC_DataWrState++;
    5ec2:	80 91 52 07 	lds	r24, 0x0752
    5ec6:	8f 5f       	subi	r24, 0xFF	; 255
    5ec8:	80 93 52 07 	sts	0x0752, r24
    5ecc:	38 c0       	rjmp	.+112    	; 0x5f3e <LCD_DataWr+0x12a>
			break;
		case 1:
			DIO_Write(LCD_EN , LOW);
    5ece:	84 e0       	ldi	r24, 0x04	; 4
    5ed0:	60 e0       	ldi	r22, 0x00	; 0
    5ed2:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

			DIO_Write(LCD_D4 , (COPY_Data >> 0) &1);
    5ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed8:	98 2f       	mov	r25, r24
    5eda:	91 70       	andi	r25, 0x01	; 1
    5edc:	80 e0       	ldi	r24, 0x00	; 0
    5ede:	69 2f       	mov	r22, r25
    5ee0:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D5 , (COPY_Data >> 1) &1);
    5ee4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee6:	86 95       	lsr	r24
    5ee8:	98 2f       	mov	r25, r24
    5eea:	91 70       	andi	r25, 0x01	; 1
    5eec:	81 e0       	ldi	r24, 0x01	; 1
    5eee:	69 2f       	mov	r22, r25
    5ef0:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D6 , (COPY_Data >> 2) &1);
    5ef4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ef6:	86 95       	lsr	r24
    5ef8:	86 95       	lsr	r24
    5efa:	98 2f       	mov	r25, r24
    5efc:	91 70       	andi	r25, 0x01	; 1
    5efe:	82 e0       	ldi	r24, 0x02	; 2
    5f00:	69 2f       	mov	r22, r25
    5f02:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			DIO_Write(LCD_D7 , (COPY_Data >> 3) &1);
    5f06:	8a 81       	ldd	r24, Y+2	; 0x02
    5f08:	86 95       	lsr	r24
    5f0a:	86 95       	lsr	r24
    5f0c:	86 95       	lsr	r24
    5f0e:	98 2f       	mov	r25, r24
    5f10:	91 70       	andi	r25, 0x01	; 1
    5f12:	83 e0       	ldi	r24, 0x03	; 3
    5f14:	69 2f       	mov	r22, r25
    5f16:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

			DIO_Write( LCD_EN , HIGH);
    5f1a:	84 e0       	ldi	r24, 0x04	; 4
    5f1c:	61 e0       	ldi	r22, 0x01	; 1
    5f1e:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			LOC_DataWrState++;
    5f22:	80 91 52 07 	lds	r24, 0x0752
    5f26:	8f 5f       	subi	r24, 0xFF	; 255
    5f28:	80 93 52 07 	sts	0x0752, r24
    5f2c:	08 c0       	rjmp	.+16     	; 0x5f3e <LCD_DataWr+0x12a>
			break;
		case 2:
			DIO_Write(LCD_EN , LOW);
    5f2e:	84 e0       	ldi	r24, 0x04	; 4
    5f30:	60 e0       	ldi	r22, 0x00	; 0
    5f32:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
			LOC_DataWrState=0;
    5f36:	10 92 52 07 	sts	0x0752, r1
			LOC_DataWrStatus = LCD_Finished;
    5f3a:	81 e0       	ldi	r24, 0x01	; 1
    5f3c:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}
	return LOC_DataWrStatus;
    5f3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    5f40:	0f 90       	pop	r0
    5f42:	0f 90       	pop	r0
    5f44:	0f 90       	pop	r0
    5f46:	0f 90       	pop	r0
    5f48:	cf 91       	pop	r28
    5f4a:	df 91       	pop	r29
    5f4c:	08 95       	ret

00005f4e <LCD_DispChar>:


Enum_LCDState LCD_DispChar(uint8_t COPY_Data)
{
    5f4e:	df 93       	push	r29
    5f50:	cf 93       	push	r28
    5f52:	00 d0       	rcall	.+0      	; 0x5f54 <LCD_DispChar+0x6>
    5f54:	cd b7       	in	r28, 0x3d	; 61
    5f56:	de b7       	in	r29, 0x3e	; 62
    5f58:	8a 83       	std	Y+2, r24	; 0x02
	static uint8_t LOC_CurrentTaskAquiringData = 0;
	Enum_LCDState LOC_LCDStatus = LCD_Pending;
    5f5a:	19 82       	std	Y+1, r1	; 0x01
	if( (LCD_INITALIZED == g_InitFlag) && (g_CMND_Flag == CMD_FREE) )
    5f5c:	80 91 50 07 	lds	r24, 0x0750
    5f60:	81 30       	cpi	r24, 0x01	; 1
    5f62:	f9 f4       	brne	.+62     	; 0x5fa2 <LCD_DispChar+0x54>
    5f64:	80 91 4e 07 	lds	r24, 0x074E
    5f68:	88 23       	and	r24, r24
    5f6a:	d9 f4       	brne	.+54     	; 0x5fa2 <LCD_DispChar+0x54>
	{
		if ( (g_Data_Flag == DATA_FREE) || (LOC_CurrentTaskAquiringData == 1) )
    5f6c:	80 91 4f 07 	lds	r24, 0x074F
    5f70:	88 23       	and	r24, r24
    5f72:	21 f0       	breq	.+8      	; 0x5f7c <LCD_DispChar+0x2e>
    5f74:	80 91 53 07 	lds	r24, 0x0753
    5f78:	81 30       	cpi	r24, 0x01	; 1
    5f7a:	99 f4       	brne	.+38     	; 0x5fa2 <LCD_DispChar+0x54>
		{
			LOC_LCDStatus = LCD_DataWr(COPY_Data);
    5f7c:	8a 81       	ldd	r24, Y+2	; 0x02
    5f7e:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <LCD_DataWr>
    5f82:	89 83       	std	Y+1, r24	; 0x01
			g_Data_Flag = DATA_ACUIRED;
    5f84:	81 e0       	ldi	r24, 0x01	; 1
    5f86:	80 93 4f 07 	sts	0x074F, r24
			LOC_CurrentTaskAquiringData = 1;
    5f8a:	81 e0       	ldi	r24, 0x01	; 1
    5f8c:	80 93 53 07 	sts	0x0753, r24
			if (LOC_LCDStatus == LCD_Finished)
    5f90:	89 81       	ldd	r24, Y+1	; 0x01
    5f92:	81 30       	cpi	r24, 0x01	; 1
    5f94:	31 f4       	brne	.+12     	; 0x5fa2 <LCD_DispChar+0x54>
			{
				g_Data_Flag = DATA_FREE;
    5f96:	10 92 4f 07 	sts	0x074F, r1
				LOC_CurrentTaskAquiringData = 0;
    5f9a:	10 92 53 07 	sts	0x0753, r1
				LOC_LCDStatus = LCD_Finished;
    5f9e:	81 e0       	ldi	r24, 0x01	; 1
    5fa0:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	return LOC_LCDStatus;
    5fa2:	89 81       	ldd	r24, Y+1	; 0x01
}
    5fa4:	0f 90       	pop	r0
    5fa6:	0f 90       	pop	r0
    5fa8:	cf 91       	pop	r28
    5faa:	df 91       	pop	r29
    5fac:	08 95       	ret

00005fae <LCD_init>:

Enum_LCDInitState LCD_init(void)
{
    5fae:	df 93       	push	r29
    5fb0:	cf 93       	push	r28
    5fb2:	00 d0       	rcall	.+0      	; 0x5fb4 <LCD_init+0x6>
    5fb4:	0f 92       	push	r0
    5fb6:	cd b7       	in	r28, 0x3d	; 61
    5fb8:	de b7       	in	r29, 0x3e	; 62
	static uint8_t LOC_InitState=0;
	Enum_LCDState LOC_LCDState = LCD_Pending;
    5fba:	19 82       	std	Y+1, r1	; 0x01
	static uint8_t LOC_CurrentTaskAquiringCMD = 0;

	if (LCD_UNINTAILIZED == g_InitFlag)
    5fbc:	80 91 50 07 	lds	r24, 0x0750
    5fc0:	88 23       	and	r24, r24
    5fc2:	09 f0       	breq	.+2      	; 0x5fc6 <LCD_init+0x18>
    5fc4:	d4 c0       	rjmp	.+424    	; 0x616e <LCD_init+0x1c0>
	{

		switch(LOC_InitState)
    5fc6:	80 91 55 07 	lds	r24, 0x0755
    5fca:	28 2f       	mov	r18, r24
    5fcc:	30 e0       	ldi	r19, 0x00	; 0
    5fce:	3b 83       	std	Y+3, r19	; 0x03
    5fd0:	2a 83       	std	Y+2, r18	; 0x02
    5fd2:	8a 81       	ldd	r24, Y+2	; 0x02
    5fd4:	9b 81       	ldd	r25, Y+3	; 0x03
    5fd6:	82 30       	cpi	r24, 0x02	; 2
    5fd8:	91 05       	cpc	r25, r1
    5fda:	09 f4       	brne	.+2      	; 0x5fde <LCD_init+0x30>
    5fdc:	64 c0       	rjmp	.+200    	; 0x60a6 <LCD_init+0xf8>
    5fde:	2a 81       	ldd	r18, Y+2	; 0x02
    5fe0:	3b 81       	ldd	r19, Y+3	; 0x03
    5fe2:	23 30       	cpi	r18, 0x03	; 3
    5fe4:	31 05       	cpc	r19, r1
    5fe6:	54 f4       	brge	.+20     	; 0x5ffc <LCD_init+0x4e>
    5fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    5fea:	9b 81       	ldd	r25, Y+3	; 0x03
    5fec:	00 97       	sbiw	r24, 0x00	; 0
    5fee:	c9 f0       	breq	.+50     	; 0x6022 <LCD_init+0x74>
    5ff0:	2a 81       	ldd	r18, Y+2	; 0x02
    5ff2:	3b 81       	ldd	r19, Y+3	; 0x03
    5ff4:	21 30       	cpi	r18, 0x01	; 1
    5ff6:	31 05       	cpc	r19, r1
    5ff8:	a9 f1       	breq	.+106    	; 0x6064 <LCD_init+0xb6>
    5ffa:	b9 c0       	rjmp	.+370    	; 0x616e <LCD_init+0x1c0>
    5ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    5ffe:	9b 81       	ldd	r25, Y+3	; 0x03
    6000:	84 30       	cpi	r24, 0x04	; 4
    6002:	91 05       	cpc	r25, r1
    6004:	09 f4       	brne	.+2      	; 0x6008 <LCD_init+0x5a>
    6006:	8f c0       	rjmp	.+286    	; 0x6126 <LCD_init+0x178>
    6008:	2a 81       	ldd	r18, Y+2	; 0x02
    600a:	3b 81       	ldd	r19, Y+3	; 0x03
    600c:	24 30       	cpi	r18, 0x04	; 4
    600e:	31 05       	cpc	r19, r1
    6010:	0c f4       	brge	.+2      	; 0x6014 <LCD_init+0x66>
    6012:	6a c0       	rjmp	.+212    	; 0x60e8 <LCD_init+0x13a>
    6014:	8a 81       	ldd	r24, Y+2	; 0x02
    6016:	9b 81       	ldd	r25, Y+3	; 0x03
    6018:	85 30       	cpi	r24, 0x05	; 5
    601a:	91 05       	cpc	r25, r1
    601c:	09 f4       	brne	.+2      	; 0x6020 <LCD_init+0x72>
    601e:	a2 c0       	rjmp	.+324    	; 0x6164 <LCD_init+0x1b6>
    6020:	a6 c0       	rjmp	.+332    	; 0x616e <LCD_init+0x1c0>
		{
		case 0:
			if ( (g_CMND_Flag == CMD_FREE) || (LOC_CurrentTaskAquiringCMD == 1) )
    6022:	80 91 4e 07 	lds	r24, 0x074E
    6026:	88 23       	and	r24, r24
    6028:	29 f0       	breq	.+10     	; 0x6034 <LCD_init+0x86>
    602a:	80 91 54 07 	lds	r24, 0x0754
    602e:	81 30       	cpi	r24, 0x01	; 1
    6030:	09 f0       	breq	.+2      	; 0x6034 <LCD_init+0x86>
    6032:	9d c0       	rjmp	.+314    	; 0x616e <LCD_init+0x1c0>
			{
				LOC_LCDState = LCD_sendCommand(LCD_CursorHome);
    6034:	82 e0       	ldi	r24, 0x02	; 2
    6036:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    603a:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    603c:	81 e0       	ldi	r24, 0x01	; 1
    603e:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD = 1;
    6042:	81 e0       	ldi	r24, 0x01	; 1
    6044:	80 93 54 07 	sts	0x0754, r24
				if (LOC_LCDState == LCD_Finished)
    6048:	89 81       	ldd	r24, Y+1	; 0x01
    604a:	81 30       	cpi	r24, 0x01	; 1
    604c:	09 f0       	breq	.+2      	; 0x6050 <LCD_init+0xa2>
    604e:	8f c0       	rjmp	.+286    	; 0x616e <LCD_init+0x1c0>
				{
					LOC_InitState++;
    6050:	80 91 55 07 	lds	r24, 0x0755
    6054:	8f 5f       	subi	r24, 0xFF	; 255
    6056:	80 93 55 07 	sts	0x0755, r24
					g_CMND_Flag = CMD_FREE;
    605a:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD = 0;
    605e:	10 92 54 07 	sts	0x0754, r1
    6062:	85 c0       	rjmp	.+266    	; 0x616e <LCD_init+0x1c0>
				}
			}

			break;
		case 1:
			if ( (g_CMND_Flag == CMD_FREE) || (LOC_CurrentTaskAquiringCMD == 1) )
    6064:	80 91 4e 07 	lds	r24, 0x074E
    6068:	88 23       	and	r24, r24
    606a:	29 f0       	breq	.+10     	; 0x6076 <LCD_init+0xc8>
    606c:	80 91 54 07 	lds	r24, 0x0754
    6070:	81 30       	cpi	r24, 0x01	; 1
    6072:	09 f0       	breq	.+2      	; 0x6076 <LCD_init+0xc8>
    6074:	7c c0       	rjmp	.+248    	; 0x616e <LCD_init+0x1c0>
			{
				LOC_LCDState = LCD_sendCommand(LCD_Set4Bit2Lin);
    6076:	88 e2       	ldi	r24, 0x28	; 40
    6078:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    607c:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    607e:	81 e0       	ldi	r24, 0x01	; 1
    6080:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD = 1;
    6084:	81 e0       	ldi	r24, 0x01	; 1
    6086:	80 93 54 07 	sts	0x0754, r24
				if (LOC_LCDState == LCD_Finished)
    608a:	89 81       	ldd	r24, Y+1	; 0x01
    608c:	81 30       	cpi	r24, 0x01	; 1
    608e:	09 f0       	breq	.+2      	; 0x6092 <LCD_init+0xe4>
    6090:	6e c0       	rjmp	.+220    	; 0x616e <LCD_init+0x1c0>
				{
					LOC_InitState++;
    6092:	80 91 55 07 	lds	r24, 0x0755
    6096:	8f 5f       	subi	r24, 0xFF	; 255
    6098:	80 93 55 07 	sts	0x0755, r24
					g_CMND_Flag = CMD_FREE;
    609c:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD = 0;
    60a0:	10 92 54 07 	sts	0x0754, r1
    60a4:	64 c0       	rjmp	.+200    	; 0x616e <LCD_init+0x1c0>
			}


			break;
		case 2:
			if ( (g_CMND_Flag == CMD_FREE) || (LOC_CurrentTaskAquiringCMD == 1) )
    60a6:	80 91 4e 07 	lds	r24, 0x074E
    60aa:	88 23       	and	r24, r24
    60ac:	29 f0       	breq	.+10     	; 0x60b8 <LCD_init+0x10a>
    60ae:	80 91 54 07 	lds	r24, 0x0754
    60b2:	81 30       	cpi	r24, 0x01	; 1
    60b4:	09 f0       	breq	.+2      	; 0x60b8 <LCD_init+0x10a>
    60b6:	5b c0       	rjmp	.+182    	; 0x616e <LCD_init+0x1c0>
			{
				LOC_LCDState = LCD_sendCommand(LCD_DisOnCurOnBliOff);
    60b8:	8e e0       	ldi	r24, 0x0E	; 14
    60ba:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    60be:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    60c0:	81 e0       	ldi	r24, 0x01	; 1
    60c2:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD = 1;
    60c6:	81 e0       	ldi	r24, 0x01	; 1
    60c8:	80 93 54 07 	sts	0x0754, r24
				if (LOC_LCDState == LCD_Finished)
    60cc:	89 81       	ldd	r24, Y+1	; 0x01
    60ce:	81 30       	cpi	r24, 0x01	; 1
    60d0:	09 f0       	breq	.+2      	; 0x60d4 <LCD_init+0x126>
    60d2:	4d c0       	rjmp	.+154    	; 0x616e <LCD_init+0x1c0>
				{
					LOC_InitState++;
    60d4:	80 91 55 07 	lds	r24, 0x0755
    60d8:	8f 5f       	subi	r24, 0xFF	; 255
    60da:	80 93 55 07 	sts	0x0755, r24
					g_CMND_Flag = CMD_FREE;
    60de:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD = 0;
    60e2:	10 92 54 07 	sts	0x0754, r1
    60e6:	43 c0       	rjmp	.+134    	; 0x616e <LCD_init+0x1c0>
				}
			}

			break;
		case 3:
			if ( (g_CMND_Flag == CMD_FREE) || (LOC_CurrentTaskAquiringCMD == 1) )
    60e8:	80 91 4e 07 	lds	r24, 0x074E
    60ec:	88 23       	and	r24, r24
    60ee:	21 f0       	breq	.+8      	; 0x60f8 <LCD_init+0x14a>
    60f0:	80 91 54 07 	lds	r24, 0x0754
    60f4:	81 30       	cpi	r24, 0x01	; 1
    60f6:	d9 f5       	brne	.+118    	; 0x616e <LCD_init+0x1c0>
			{
				LOC_LCDState = LCD_sendCommand(LCD_IncOnShiOff);
    60f8:	86 e0       	ldi	r24, 0x06	; 6
    60fa:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    60fe:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    6100:	81 e0       	ldi	r24, 0x01	; 1
    6102:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD = 1;
    6106:	81 e0       	ldi	r24, 0x01	; 1
    6108:	80 93 54 07 	sts	0x0754, r24
				if (LOC_LCDState == LCD_Finished)
    610c:	89 81       	ldd	r24, Y+1	; 0x01
    610e:	81 30       	cpi	r24, 0x01	; 1
    6110:	71 f5       	brne	.+92     	; 0x616e <LCD_init+0x1c0>
				{
					LOC_InitState++;
    6112:	80 91 55 07 	lds	r24, 0x0755
    6116:	8f 5f       	subi	r24, 0xFF	; 255
    6118:	80 93 55 07 	sts	0x0755, r24
					g_CMND_Flag = CMD_FREE;
    611c:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD = 0;
    6120:	10 92 54 07 	sts	0x0754, r1
    6124:	24 c0       	rjmp	.+72     	; 0x616e <LCD_init+0x1c0>
				}
			}
			break;
		case 4:
			if ( (g_CMND_Flag == CMD_FREE) || (LOC_CurrentTaskAquiringCMD == 1) )
    6126:	80 91 4e 07 	lds	r24, 0x074E
    612a:	88 23       	and	r24, r24
    612c:	21 f0       	breq	.+8      	; 0x6136 <LCD_init+0x188>
    612e:	80 91 54 07 	lds	r24, 0x0754
    6132:	81 30       	cpi	r24, 0x01	; 1
    6134:	e1 f4       	brne	.+56     	; 0x616e <LCD_init+0x1c0>
			{
				LOC_LCDState = LCD_sendCommand(LCD_ClearScreen);
    6136:	81 e0       	ldi	r24, 0x01	; 1
    6138:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    613c:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    613e:	81 e0       	ldi	r24, 0x01	; 1
    6140:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD = 1;
    6144:	81 e0       	ldi	r24, 0x01	; 1
    6146:	80 93 54 07 	sts	0x0754, r24
				if (LOC_LCDState == LCD_Finished)
    614a:	89 81       	ldd	r24, Y+1	; 0x01
    614c:	81 30       	cpi	r24, 0x01	; 1
    614e:	79 f4       	brne	.+30     	; 0x616e <LCD_init+0x1c0>
				{
					LOC_InitState++;
    6150:	80 91 55 07 	lds	r24, 0x0755
    6154:	8f 5f       	subi	r24, 0xFF	; 255
    6156:	80 93 55 07 	sts	0x0755, r24
					g_CMND_Flag = CMD_FREE;
    615a:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD = 0;
    615e:	10 92 54 07 	sts	0x0754, r1
    6162:	05 c0       	rjmp	.+10     	; 0x616e <LCD_init+0x1c0>
				}
			}

			break;
		case 5:
			LOC_InitState=0;
    6164:	10 92 55 07 	sts	0x0755, r1
			g_InitFlag = LCD_INITALIZED;
    6168:	81 e0       	ldi	r24, 0x01	; 1
    616a:	80 93 50 07 	sts	0x0750, r24
			//vTaskSuspend(NULL);
			break;

		}
	}
	return g_InitFlag;
    616e:	80 91 50 07 	lds	r24, 0x0750
}
    6172:	0f 90       	pop	r0
    6174:	0f 90       	pop	r0
    6176:	0f 90       	pop	r0
    6178:	cf 91       	pop	r28
    617a:	df 91       	pop	r29
    617c:	08 95       	ret

0000617e <LCD_displayString>:


Enum_LCDState LCD_displayString(uint8_t *COPY_ptrString)
{
    617e:	df 93       	push	r29
    6180:	cf 93       	push	r28
    6182:	00 d0       	rcall	.+0      	; 0x6184 <LCD_displayString+0x6>
    6184:	0f 92       	push	r0
    6186:	cd b7       	in	r28, 0x3d	; 61
    6188:	de b7       	in	r29, 0x3e	; 62
    618a:	9b 83       	std	Y+3, r25	; 0x03
    618c:	8a 83       	std	Y+2, r24	; 0x02
	static uint8_t LCD_State = 0;
	static uint8_t LOC_CurrentTaskAquiringCMND = 0;
	static uint8_t LOC_LocalIterator = 0;
	Enum_LCDState LCD_Status = LCD_Pending;
    618e:	19 82       	std	Y+1, r1	; 0x01

	if ( CMD_FREE == g_CMND_Flag )
    6190:	80 91 4e 07 	lds	r24, 0x074E
    6194:	88 23       	and	r24, r24
    6196:	c1 f5       	brne	.+112    	; 0x6208 <LCD_displayString+0x8a>
	{
		if ( (DATA_FREE == g_Data_Flag) || (1 == LOC_CurrentTaskAquiringCMND) )
    6198:	80 91 4f 07 	lds	r24, 0x074F
    619c:	88 23       	and	r24, r24
    619e:	21 f0       	breq	.+8      	; 0x61a8 <LCD_displayString+0x2a>
    61a0:	80 91 57 07 	lds	r24, 0x0757
    61a4:	81 30       	cpi	r24, 0x01	; 1
    61a6:	81 f5       	brne	.+96     	; 0x6208 <LCD_displayString+0x8a>
		{
			LCD_Status = LCD_DataWr(COPY_ptrString[LOC_LocalIterator]);
    61a8:	80 91 56 07 	lds	r24, 0x0756
    61ac:	28 2f       	mov	r18, r24
    61ae:	30 e0       	ldi	r19, 0x00	; 0
    61b0:	8a 81       	ldd	r24, Y+2	; 0x02
    61b2:	9b 81       	ldd	r25, Y+3	; 0x03
    61b4:	fc 01       	movw	r30, r24
    61b6:	e2 0f       	add	r30, r18
    61b8:	f3 1f       	adc	r31, r19
    61ba:	80 81       	ld	r24, Z
    61bc:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <LCD_DataWr>
    61c0:	89 83       	std	Y+1, r24	; 0x01
			g_Data_Flag = DATA_ACUIRED;
    61c2:	81 e0       	ldi	r24, 0x01	; 1
    61c4:	80 93 4f 07 	sts	0x074F, r24
			LOC_CurrentTaskAquiringCMND = 1;
    61c8:	81 e0       	ldi	r24, 0x01	; 1
    61ca:	80 93 57 07 	sts	0x0757, r24
			if ( LCD_Finished == LCD_Status )
    61ce:	89 81       	ldd	r24, Y+1	; 0x01
    61d0:	81 30       	cpi	r24, 0x01	; 1
    61d2:	d1 f4       	brne	.+52     	; 0x6208 <LCD_displayString+0x8a>
			{
				LOC_LocalIterator++;
    61d4:	80 91 56 07 	lds	r24, 0x0756
    61d8:	8f 5f       	subi	r24, 0xFF	; 255
    61da:	80 93 56 07 	sts	0x0756, r24
				LCD_Status = LCD_Pending;
    61de:	19 82       	std	Y+1, r1	; 0x01
				if (COPY_ptrString[LOC_LocalIterator] == 0)
    61e0:	80 91 56 07 	lds	r24, 0x0756
    61e4:	28 2f       	mov	r18, r24
    61e6:	30 e0       	ldi	r19, 0x00	; 0
    61e8:	8a 81       	ldd	r24, Y+2	; 0x02
    61ea:	9b 81       	ldd	r25, Y+3	; 0x03
    61ec:	fc 01       	movw	r30, r24
    61ee:	e2 0f       	add	r30, r18
    61f0:	f3 1f       	adc	r31, r19
    61f2:	80 81       	ld	r24, Z
    61f4:	88 23       	and	r24, r24
    61f6:	41 f4       	brne	.+16     	; 0x6208 <LCD_displayString+0x8a>
				{
					g_Data_Flag = DATA_FREE;
    61f8:	10 92 4f 07 	sts	0x074F, r1
					LOC_CurrentTaskAquiringCMND = 0;
    61fc:	10 92 57 07 	sts	0x0757, r1
					LCD_State = 0;
    6200:	10 92 58 07 	sts	0x0758, r1
					LCD_Status = LCD_Finished;
    6204:	81 e0       	ldi	r24, 0x01	; 1
    6206:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
	}

	return LCD_Status;
    6208:	89 81       	ldd	r24, Y+1	; 0x01
}
    620a:	0f 90       	pop	r0
    620c:	0f 90       	pop	r0
    620e:	0f 90       	pop	r0
    6210:	cf 91       	pop	r28
    6212:	df 91       	pop	r29
    6214:	08 95       	ret

00006216 <LCD_displayStringRowColumn>:


Enum_LCDState LCD_displayStringRowColumn(uint8_t *COPY_ptrString,uint8_t COPY_Row,uint8_t COPY_Column)
{
    6216:	df 93       	push	r29
    6218:	cf 93       	push	r28
    621a:	cd b7       	in	r28, 0x3d	; 61
    621c:	de b7       	in	r29, 0x3e	; 62
    621e:	27 97       	sbiw	r28, 0x07	; 7
    6220:	0f b6       	in	r0, 0x3f	; 63
    6222:	f8 94       	cli
    6224:	de bf       	out	0x3e, r29	; 62
    6226:	0f be       	out	0x3f, r0	; 63
    6228:	cd bf       	out	0x3d, r28	; 61
    622a:	9b 83       	std	Y+3, r25	; 0x03
    622c:	8a 83       	std	Y+2, r24	; 0x02
    622e:	6c 83       	std	Y+4, r22	; 0x04
    6230:	4d 83       	std	Y+5, r20	; 0x05
	static uint8_t LCD_State = 0;
	static uint8_t LOC_CurrentTaskAquiringCMND = 0;
	static uint8_t LOC_LocalIterator = 0;
	Enum_LCDState LCD_Status = LCD_Pending;
    6232:	19 82       	std	Y+1, r1	; 0x01

	switch(LCD_State)
    6234:	80 91 5b 07 	lds	r24, 0x075B
    6238:	28 2f       	mov	r18, r24
    623a:	30 e0       	ldi	r19, 0x00	; 0
    623c:	3f 83       	std	Y+7, r19	; 0x07
    623e:	2e 83       	std	Y+6, r18	; 0x06
    6240:	8e 81       	ldd	r24, Y+6	; 0x06
    6242:	9f 81       	ldd	r25, Y+7	; 0x07
    6244:	00 97       	sbiw	r24, 0x00	; 0
    6246:	31 f0       	breq	.+12     	; 0x6254 <LCD_displayStringRowColumn+0x3e>
    6248:	2e 81       	ldd	r18, Y+6	; 0x06
    624a:	3f 81       	ldd	r19, Y+7	; 0x07
    624c:	21 30       	cpi	r18, 0x01	; 1
    624e:	31 05       	cpc	r19, r1
    6250:	61 f1       	breq	.+88     	; 0x62aa <LCD_displayStringRowColumn+0x94>
    6252:	69 c0       	rjmp	.+210    	; 0x6326 <LCD_displayStringRowColumn+0x110>
	{
	case 0:
		if ( (LCD_INITALIZED == g_InitFlag) && (DATA_FREE == g_Data_Flag) )
    6254:	80 91 50 07 	lds	r24, 0x0750
    6258:	81 30       	cpi	r24, 0x01	; 1
    625a:	09 f0       	breq	.+2      	; 0x625e <LCD_displayStringRowColumn+0x48>
    625c:	64 c0       	rjmp	.+200    	; 0x6326 <LCD_displayStringRowColumn+0x110>
    625e:	80 91 4f 07 	lds	r24, 0x074F
    6262:	88 23       	and	r24, r24
    6264:	09 f0       	breq	.+2      	; 0x6268 <LCD_displayStringRowColumn+0x52>
    6266:	5f c0       	rjmp	.+190    	; 0x6326 <LCD_displayStringRowColumn+0x110>
		{
			if ( (CMD_FREE == g_CMND_Flag) || (1 == LOC_CurrentTaskAquiringCMND) )
    6268:	80 91 4e 07 	lds	r24, 0x074E
    626c:	88 23       	and	r24, r24
    626e:	29 f0       	breq	.+10     	; 0x627a <LCD_displayStringRowColumn+0x64>
    6270:	80 91 5a 07 	lds	r24, 0x075A
    6274:	81 30       	cpi	r24, 0x01	; 1
    6276:	09 f0       	breq	.+2      	; 0x627a <LCD_displayStringRowColumn+0x64>
    6278:	56 c0       	rjmp	.+172    	; 0x6326 <LCD_displayStringRowColumn+0x110>
			{
				LCD_Status = LCD_gotoRowColumn(COPY_Row,COPY_Column);
    627a:	8c 81       	ldd	r24, Y+4	; 0x04
    627c:	6d 81       	ldd	r22, Y+5	; 0x05
    627e:	0e 94 9d 31 	call	0x633a	; 0x633a <LCD_gotoRowColumn>
    6282:	89 83       	std	Y+1, r24	; 0x01
				g_CMND_Flag = CMD_ACUIRED;
    6284:	81 e0       	ldi	r24, 0x01	; 1
    6286:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMND = 1;
    628a:	81 e0       	ldi	r24, 0x01	; 1
    628c:	80 93 5a 07 	sts	0x075A, r24
				if ( LCD_Finished == LCD_Status)
    6290:	89 81       	ldd	r24, Y+1	; 0x01
    6292:	81 30       	cpi	r24, 0x01	; 1
    6294:	09 f0       	breq	.+2      	; 0x6298 <LCD_displayStringRowColumn+0x82>
    6296:	47 c0       	rjmp	.+142    	; 0x6326 <LCD_displayStringRowColumn+0x110>
				{
					g_CMND_Flag = CMD_FREE;
    6298:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMND = 0;
    629c:	10 92 5a 07 	sts	0x075A, r1
					LCD_State = 1;
    62a0:	81 e0       	ldi	r24, 0x01	; 1
    62a2:	80 93 5b 07 	sts	0x075B, r24
					LCD_Status = LCD_Pending;
    62a6:	19 82       	std	Y+1, r1	; 0x01
    62a8:	3e c0       	rjmp	.+124    	; 0x6326 <LCD_displayStringRowColumn+0x110>
		}

		break;

	case 1:
		if ( CMD_FREE == g_CMND_Flag )
    62aa:	80 91 4e 07 	lds	r24, 0x074E
    62ae:	88 23       	and	r24, r24
    62b0:	d1 f5       	brne	.+116    	; 0x6326 <LCD_displayStringRowColumn+0x110>
		{
			if ( (DATA_FREE == g_Data_Flag) || (1 == LOC_CurrentTaskAquiringCMND) )
    62b2:	80 91 4f 07 	lds	r24, 0x074F
    62b6:	88 23       	and	r24, r24
    62b8:	21 f0       	breq	.+8      	; 0x62c2 <LCD_displayStringRowColumn+0xac>
    62ba:	80 91 5a 07 	lds	r24, 0x075A
    62be:	81 30       	cpi	r24, 0x01	; 1
    62c0:	91 f5       	brne	.+100    	; 0x6326 <LCD_displayStringRowColumn+0x110>
			{
				LCD_Status = LCD_DataWr(COPY_ptrString[LOC_LocalIterator]);
    62c2:	80 91 59 07 	lds	r24, 0x0759
    62c6:	28 2f       	mov	r18, r24
    62c8:	30 e0       	ldi	r19, 0x00	; 0
    62ca:	8a 81       	ldd	r24, Y+2	; 0x02
    62cc:	9b 81       	ldd	r25, Y+3	; 0x03
    62ce:	fc 01       	movw	r30, r24
    62d0:	e2 0f       	add	r30, r18
    62d2:	f3 1f       	adc	r31, r19
    62d4:	80 81       	ld	r24, Z
    62d6:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <LCD_DataWr>
    62da:	89 83       	std	Y+1, r24	; 0x01
				g_Data_Flag = DATA_ACUIRED;
    62dc:	81 e0       	ldi	r24, 0x01	; 1
    62de:	80 93 4f 07 	sts	0x074F, r24
				LOC_CurrentTaskAquiringCMND = 1;
    62e2:	81 e0       	ldi	r24, 0x01	; 1
    62e4:	80 93 5a 07 	sts	0x075A, r24
				if ( LCD_Finished == LCD_Status )
    62e8:	89 81       	ldd	r24, Y+1	; 0x01
    62ea:	81 30       	cpi	r24, 0x01	; 1
    62ec:	e1 f4       	brne	.+56     	; 0x6326 <LCD_displayStringRowColumn+0x110>
				{
					LOC_LocalIterator++;
    62ee:	80 91 59 07 	lds	r24, 0x0759
    62f2:	8f 5f       	subi	r24, 0xFF	; 255
    62f4:	80 93 59 07 	sts	0x0759, r24
					LCD_Status = LCD_Pending;
    62f8:	19 82       	std	Y+1, r1	; 0x01
					if (COPY_ptrString[LOC_LocalIterator] == 0)
    62fa:	80 91 59 07 	lds	r24, 0x0759
    62fe:	28 2f       	mov	r18, r24
    6300:	30 e0       	ldi	r19, 0x00	; 0
    6302:	8a 81       	ldd	r24, Y+2	; 0x02
    6304:	9b 81       	ldd	r25, Y+3	; 0x03
    6306:	fc 01       	movw	r30, r24
    6308:	e2 0f       	add	r30, r18
    630a:	f3 1f       	adc	r31, r19
    630c:	80 81       	ld	r24, Z
    630e:	88 23       	and	r24, r24
    6310:	51 f4       	brne	.+20     	; 0x6326 <LCD_displayStringRowColumn+0x110>
					{
						g_Data_Flag = DATA_FREE;
    6312:	10 92 4f 07 	sts	0x074F, r1
						LOC_CurrentTaskAquiringCMND = 0;
    6316:	10 92 5a 07 	sts	0x075A, r1
						LCD_State = 0;
    631a:	10 92 5b 07 	sts	0x075B, r1
						LCD_Status = LCD_Finished;
    631e:	81 e0       	ldi	r24, 0x01	; 1
    6320:	89 83       	std	Y+1, r24	; 0x01
						LOC_LocalIterator =0;
    6322:	10 92 59 07 	sts	0x0759, r1
			}
		}
		break;
	}

	return LCD_Status;
    6326:	89 81       	ldd	r24, Y+1	; 0x01
}
    6328:	27 96       	adiw	r28, 0x07	; 7
    632a:	0f b6       	in	r0, 0x3f	; 63
    632c:	f8 94       	cli
    632e:	de bf       	out	0x3e, r29	; 62
    6330:	0f be       	out	0x3f, r0	; 63
    6332:	cd bf       	out	0x3d, r28	; 61
    6334:	cf 91       	pop	r28
    6336:	df 91       	pop	r29
    6338:	08 95       	ret

0000633a <LCD_gotoRowColumn>:

Enum_LCDState LCD_gotoRowColumn( uint8_t COPY_u8Row , uint8_t COPY_u8Column)
{
    633a:	df 93       	push	r29
    633c:	cf 93       	push	r28
    633e:	00 d0       	rcall	.+0      	; 0x6340 <LCD_gotoRowColumn+0x6>
    6340:	0f 92       	push	r0
    6342:	cd b7       	in	r28, 0x3d	; 61
    6344:	de b7       	in	r29, 0x3e	; 62
    6346:	8a 83       	std	Y+2, r24	; 0x02
    6348:	6b 83       	std	Y+3, r22	; 0x03
	static uint8_t LOC_CurrentTaskAquiringCMND = 0;
	Enum_LCDState LOC_LCDStatus = LCD_Pending ;
    634a:	19 82       	std	Y+1, r1	; 0x01

	if ( ( LCD_INITALIZED == g_InitFlag ) && (DATA_FREE == g_Data_Flag))
    634c:	80 91 50 07 	lds	r24, 0x0750
    6350:	81 30       	cpi	r24, 0x01	; 1
    6352:	71 f5       	brne	.+92     	; 0x63b0 <LCD_gotoRowColumn+0x76>
    6354:	80 91 4f 07 	lds	r24, 0x074F
    6358:	88 23       	and	r24, r24
    635a:	51 f5       	brne	.+84     	; 0x63b0 <LCD_gotoRowColumn+0x76>
	{
		if ( (CMD_FREE == g_CMND_Flag) || ( 1 == LOC_CurrentTaskAquiringCMND ))
    635c:	80 91 4e 07 	lds	r24, 0x074E
    6360:	88 23       	and	r24, r24
    6362:	21 f0       	breq	.+8      	; 0x636c <LCD_gotoRowColumn+0x32>
    6364:	80 91 5c 07 	lds	r24, 0x075C
    6368:	81 30       	cpi	r24, 0x01	; 1
    636a:	11 f5       	brne	.+68     	; 0x63b0 <LCD_gotoRowColumn+0x76>
		{
			LOC_LCDStatus =  LCD_sendCommand((0x80)|(COPY_u8Column+(0x40*COPY_u8Row)));
    636c:	8a 81       	ldd	r24, Y+2	; 0x02
    636e:	88 2f       	mov	r24, r24
    6370:	90 e0       	ldi	r25, 0x00	; 0
    6372:	00 24       	eor	r0, r0
    6374:	96 95       	lsr	r25
    6376:	87 95       	ror	r24
    6378:	07 94       	ror	r0
    637a:	96 95       	lsr	r25
    637c:	87 95       	ror	r24
    637e:	07 94       	ror	r0
    6380:	98 2f       	mov	r25, r24
    6382:	80 2d       	mov	r24, r0
    6384:	98 2f       	mov	r25, r24
    6386:	8b 81       	ldd	r24, Y+3	; 0x03
    6388:	89 0f       	add	r24, r25
    638a:	80 68       	ori	r24, 0x80	; 128
    638c:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    6390:	89 83       	std	Y+1, r24	; 0x01
			g_CMND_Flag = CMD_ACUIRED;
    6392:	81 e0       	ldi	r24, 0x01	; 1
    6394:	80 93 4e 07 	sts	0x074E, r24
			LOC_CurrentTaskAquiringCMND = 1;
    6398:	81 e0       	ldi	r24, 0x01	; 1
    639a:	80 93 5c 07 	sts	0x075C, r24

			if ( LCD_Finished == LOC_LCDStatus)
    639e:	89 81       	ldd	r24, Y+1	; 0x01
    63a0:	81 30       	cpi	r24, 0x01	; 1
    63a2:	31 f4       	brne	.+12     	; 0x63b0 <LCD_gotoRowColumn+0x76>
			{
				g_CMND_Flag = CMD_FREE;
    63a4:	10 92 4e 07 	sts	0x074E, r1
				LOC_CurrentTaskAquiringCMND = 0;
    63a8:	10 92 5c 07 	sts	0x075C, r1
				LOC_LCDStatus = LCD_Finished;
    63ac:	81 e0       	ldi	r24, 0x01	; 1
    63ae:	89 83       	std	Y+1, r24	; 0x01

			}
		}
	}
	return LOC_LCDStatus;
    63b0:	89 81       	ldd	r24, Y+1	; 0x01
}
    63b2:	0f 90       	pop	r0
    63b4:	0f 90       	pop	r0
    63b6:	0f 90       	pop	r0
    63b8:	cf 91       	pop	r28
    63ba:	df 91       	pop	r29
    63bc:	08 95       	ret

000063be <LCD_Clear>:


Enum_LCDState LCD_Clear(void)
{
    63be:	df 93       	push	r29
    63c0:	cf 93       	push	r28
    63c2:	00 d0       	rcall	.+0      	; 0x63c4 <LCD_Clear+0x6>
    63c4:	cd b7       	in	r28, 0x3d	; 61
    63c6:	de b7       	in	r29, 0x3e	; 62
	uint8_t LOC_CurrentTaskAquiringCMD=1;
    63c8:	81 e0       	ldi	r24, 0x01	; 1
    63ca:	8a 83       	std	Y+2, r24	; 0x02
	Enum_LCDState LOC_LCDState=LCD_Pending;
    63cc:	19 82       	std	Y+1, r1	; 0x01
	if ( ((g_Data_Flag==DATA_FREE && g_CMND_Flag == CMD_FREE) )|| (LOC_CurrentTaskAquiringCMD == 1) )
    63ce:	80 91 4f 07 	lds	r24, 0x074F
    63d2:	88 23       	and	r24, r24
    63d4:	21 f4       	brne	.+8      	; 0x63de <LCD_Clear+0x20>
    63d6:	80 91 4e 07 	lds	r24, 0x074E
    63da:	88 23       	and	r24, r24
    63dc:	19 f0       	breq	.+6      	; 0x63e4 <LCD_Clear+0x26>
    63de:	8a 81       	ldd	r24, Y+2	; 0x02
    63e0:	81 30       	cpi	r24, 0x01	; 1
    63e2:	79 f4       	brne	.+30     	; 0x6402 <LCD_Clear+0x44>
	{
		LOC_LCDState = LCD_sendCommand(LCD_ClearScreen);
    63e4:	81 e0       	ldi	r24, 0x01	; 1
    63e6:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    63ea:	89 83       	std	Y+1, r24	; 0x01
		g_CMND_Flag = CMD_ACUIRED;
    63ec:	81 e0       	ldi	r24, 0x01	; 1
    63ee:	80 93 4e 07 	sts	0x074E, r24
		LOC_CurrentTaskAquiringCMD = 1;
    63f2:	81 e0       	ldi	r24, 0x01	; 1
    63f4:	8a 83       	std	Y+2, r24	; 0x02
		if (LOC_LCDState == LCD_Finished)
    63f6:	89 81       	ldd	r24, Y+1	; 0x01
    63f8:	81 30       	cpi	r24, 0x01	; 1
    63fa:	19 f4       	brne	.+6      	; 0x6402 <LCD_Clear+0x44>
		{
			g_CMND_Flag = CMD_FREE;
    63fc:	10 92 4e 07 	sts	0x074E, r1
			LOC_CurrentTaskAquiringCMD = 0;
    6400:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	return LOC_LCDState;
    6402:	89 81       	ldd	r24, Y+1	; 0x01
}
    6404:	0f 90       	pop	r0
    6406:	0f 90       	pop	r0
    6408:	cf 91       	pop	r28
    640a:	df 91       	pop	r29
    640c:	08 95       	ret

0000640e <LCD_VidDrawPattern>:

Enum_LCDState LCD_VidDrawPattern(uint8_t COPY_u8Row,uint8_t COPY_u8Col,uint8_t* COPY_pu8DrawPattern,uint8_t COPY_u8Size)
{
    640e:	df 93       	push	r29
    6410:	cf 93       	push	r28
    6412:	cd b7       	in	r28, 0x3d	; 61
    6414:	de b7       	in	r29, 0x3e	; 62
    6416:	2a 97       	sbiw	r28, 0x0a	; 10
    6418:	0f b6       	in	r0, 0x3f	; 63
    641a:	f8 94       	cli
    641c:	de bf       	out	0x3e, r29	; 62
    641e:	0f be       	out	0x3f, r0	; 63
    6420:	cd bf       	out	0x3d, r28	; 61
    6422:	8c 83       	std	Y+4, r24	; 0x04
    6424:	6d 83       	std	Y+5, r22	; 0x05
    6426:	5f 83       	std	Y+7, r21	; 0x07
    6428:	4e 83       	std	Y+6, r20	; 0x06
    642a:	28 87       	std	Y+8, r18	; 0x08
	static uint8_t LOC_CurrentTaskAquiringCMD=0;
	static uint8_t LOC_LcdState=0;
	Enum_LCDState LOC_DrawPatternState=LCD_Pending;
    642c:	1b 82       	std	Y+3, r1	; 0x03
	uint8_t LOC_u8Iteration1=0;
    642e:	1a 82       	std	Y+2, r1	; 0x02
	uint8_t LOC_u8Iteration2=0;
    6430:	19 82       	std	Y+1, r1	; 0x01

	switch (LOC_LcdState)
    6432:	80 91 5d 07 	lds	r24, 0x075D
    6436:	28 2f       	mov	r18, r24
    6438:	30 e0       	ldi	r19, 0x00	; 0
    643a:	3a 87       	std	Y+10, r19	; 0x0a
    643c:	29 87       	std	Y+9, r18	; 0x09
    643e:	89 85       	ldd	r24, Y+9	; 0x09
    6440:	9a 85       	ldd	r25, Y+10	; 0x0a
    6442:	82 30       	cpi	r24, 0x02	; 2
    6444:	91 05       	cpc	r25, r1
    6446:	09 f4       	brne	.+2      	; 0x644a <LCD_VidDrawPattern+0x3c>
    6448:	8b c0       	rjmp	.+278    	; 0x6560 <LCD_VidDrawPattern+0x152>
    644a:	29 85       	ldd	r18, Y+9	; 0x09
    644c:	3a 85       	ldd	r19, Y+10	; 0x0a
    644e:	23 30       	cpi	r18, 0x03	; 3
    6450:	31 05       	cpc	r19, r1
    6452:	54 f4       	brge	.+20     	; 0x6468 <LCD_VidDrawPattern+0x5a>
    6454:	89 85       	ldd	r24, Y+9	; 0x09
    6456:	9a 85       	ldd	r25, Y+10	; 0x0a
    6458:	00 97       	sbiw	r24, 0x00	; 0
    645a:	99 f0       	breq	.+38     	; 0x6482 <LCD_VidDrawPattern+0x74>
    645c:	29 85       	ldd	r18, Y+9	; 0x09
    645e:	3a 85       	ldd	r19, Y+10	; 0x0a
    6460:	21 30       	cpi	r18, 0x01	; 1
    6462:	31 05       	cpc	r19, r1
    6464:	c1 f1       	breq	.+112    	; 0x64d6 <LCD_VidDrawPattern+0xc8>
    6466:	eb c0       	rjmp	.+470    	; 0x663e <LCD_VidDrawPattern+0x230>
    6468:	89 85       	ldd	r24, Y+9	; 0x09
    646a:	9a 85       	ldd	r25, Y+10	; 0x0a
    646c:	83 30       	cpi	r24, 0x03	; 3
    646e:	91 05       	cpc	r25, r1
    6470:	09 f4       	brne	.+2      	; 0x6474 <LCD_VidDrawPattern+0x66>
    6472:	9b c0       	rjmp	.+310    	; 0x65aa <LCD_VidDrawPattern+0x19c>
    6474:	29 85       	ldd	r18, Y+9	; 0x09
    6476:	3a 85       	ldd	r19, Y+10	; 0x0a
    6478:	24 30       	cpi	r18, 0x04	; 4
    647a:	31 05       	cpc	r19, r1
    647c:	09 f4       	brne	.+2      	; 0x6480 <LCD_VidDrawPattern+0x72>
    647e:	b5 c0       	rjmp	.+362    	; 0x65ea <LCD_VidDrawPattern+0x1dc>
    6480:	de c0       	rjmp	.+444    	; 0x663e <LCD_VidDrawPattern+0x230>
	{
	case 0:
		if(LCD_INITALIZED== g_InitFlag && DATA_FREE == g_Data_Flag)
    6482:	80 91 50 07 	lds	r24, 0x0750
    6486:	81 30       	cpi	r24, 0x01	; 1
    6488:	09 f0       	breq	.+2      	; 0x648c <LCD_VidDrawPattern+0x7e>
    648a:	d9 c0       	rjmp	.+434    	; 0x663e <LCD_VidDrawPattern+0x230>
    648c:	80 91 4f 07 	lds	r24, 0x074F
    6490:	88 23       	and	r24, r24
    6492:	09 f0       	breq	.+2      	; 0x6496 <LCD_VidDrawPattern+0x88>
    6494:	d4 c0       	rjmp	.+424    	; 0x663e <LCD_VidDrawPattern+0x230>
		{
			if(CMD_FREE==g_CMND_Flag || 1== LOC_CurrentTaskAquiringCMD)
    6496:	80 91 4e 07 	lds	r24, 0x074E
    649a:	88 23       	and	r24, r24
    649c:	29 f0       	breq	.+10     	; 0x64a8 <LCD_VidDrawPattern+0x9a>
    649e:	80 91 5e 07 	lds	r24, 0x075E
    64a2:	81 30       	cpi	r24, 0x01	; 1
    64a4:	09 f0       	breq	.+2      	; 0x64a8 <LCD_VidDrawPattern+0x9a>
    64a6:	cb c0       	rjmp	.+406    	; 0x663e <LCD_VidDrawPattern+0x230>
			{
				LOC_DrawPatternState=LCD_sendCommand(64);
    64a8:	80 e4       	ldi	r24, 0x40	; 64
    64aa:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    64ae:	8b 83       	std	Y+3, r24	; 0x03
				g_CMND_Flag=CMD_ACUIRED;
    64b0:	81 e0       	ldi	r24, 0x01	; 1
    64b2:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD=1;
    64b6:	81 e0       	ldi	r24, 0x01	; 1
    64b8:	80 93 5e 07 	sts	0x075E, r24
				if(LCD_Finished==LOC_DrawPatternState)
    64bc:	8b 81       	ldd	r24, Y+3	; 0x03
    64be:	81 30       	cpi	r24, 0x01	; 1
    64c0:	09 f0       	breq	.+2      	; 0x64c4 <LCD_VidDrawPattern+0xb6>
    64c2:	bd c0       	rjmp	.+378    	; 0x663e <LCD_VidDrawPattern+0x230>
				{
					g_CMND_Flag=CMD_FREE;
    64c4:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD=0;
    64c8:	10 92 5e 07 	sts	0x075E, r1
					LOC_LcdState=1;
    64cc:	81 e0       	ldi	r24, 0x01	; 1
    64ce:	80 93 5d 07 	sts	0x075D, r24
					LOC_DrawPatternState=LCD_Pending;
    64d2:	1b 82       	std	Y+3, r1	; 0x03
    64d4:	b4 c0       	rjmp	.+360    	; 0x663e <LCD_VidDrawPattern+0x230>

		}

		break;
	case 1:
		if(CMD_FREE==g_CMND_Flag)
    64d6:	80 91 4e 07 	lds	r24, 0x074E
    64da:	88 23       	and	r24, r24
    64dc:	09 f0       	breq	.+2      	; 0x64e0 <LCD_VidDrawPattern+0xd2>
    64de:	af c0       	rjmp	.+350    	; 0x663e <LCD_VidDrawPattern+0x230>
		{
			if(DATA_FREE==g_Data_Flag || (1==LOC_CurrentTaskAquiringCMD))
    64e0:	80 91 4f 07 	lds	r24, 0x074F
    64e4:	88 23       	and	r24, r24
    64e6:	29 f0       	breq	.+10     	; 0x64f2 <LCD_VidDrawPattern+0xe4>
    64e8:	80 91 5e 07 	lds	r24, 0x075E
    64ec:	81 30       	cpi	r24, 0x01	; 1
    64ee:	09 f0       	breq	.+2      	; 0x64f2 <LCD_VidDrawPattern+0xe4>
    64f0:	a6 c0       	rjmp	.+332    	; 0x663e <LCD_VidDrawPattern+0x230>
			{
				LOC_DrawPatternState=LCD_DataWr(COPY_pu8DrawPattern[LOC_u8Iteration1]);
    64f2:	8a 81       	ldd	r24, Y+2	; 0x02
    64f4:	28 2f       	mov	r18, r24
    64f6:	30 e0       	ldi	r19, 0x00	; 0
    64f8:	8e 81       	ldd	r24, Y+6	; 0x06
    64fa:	9f 81       	ldd	r25, Y+7	; 0x07
    64fc:	fc 01       	movw	r30, r24
    64fe:	e2 0f       	add	r30, r18
    6500:	f3 1f       	adc	r31, r19
    6502:	80 81       	ld	r24, Z
    6504:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <LCD_DataWr>
    6508:	8b 83       	std	Y+3, r24	; 0x03
				g_Data_Flag=DATA_ACUIRED;
    650a:	81 e0       	ldi	r24, 0x01	; 1
    650c:	80 93 4f 07 	sts	0x074F, r24
				LOC_CurrentTaskAquiringCMD=1;
    6510:	81 e0       	ldi	r24, 0x01	; 1
    6512:	80 93 5e 07 	sts	0x075E, r24
				if(LCD_Finished==LOC_DrawPatternState)
    6516:	8b 81       	ldd	r24, Y+3	; 0x03
    6518:	81 30       	cpi	r24, 0x01	; 1
    651a:	09 f0       	breq	.+2      	; 0x651e <LCD_VidDrawPattern+0x110>
    651c:	90 c0       	rjmp	.+288    	; 0x663e <LCD_VidDrawPattern+0x230>
				{
					LOC_u8Iteration1++;
    651e:	8a 81       	ldd	r24, Y+2	; 0x02
    6520:	8f 5f       	subi	r24, 0xFF	; 255
    6522:	8a 83       	std	Y+2, r24	; 0x02
					LOC_DrawPatternState=LCD_Pending;
    6524:	1b 82       	std	Y+3, r1	; 0x03
					if(COPY_u8Size<=LOC_u8Iteration1)
    6526:	98 85       	ldd	r25, Y+8	; 0x08
    6528:	8a 81       	ldd	r24, Y+2	; 0x02
    652a:	89 17       	cp	r24, r25
    652c:	08 f4       	brcc	.+2      	; 0x6530 <LCD_VidDrawPattern+0x122>
    652e:	87 c0       	rjmp	.+270    	; 0x663e <LCD_VidDrawPattern+0x230>
					{
						DDRB|= (1<<6);
    6530:	a7 e3       	ldi	r26, 0x37	; 55
    6532:	b0 e0       	ldi	r27, 0x00	; 0
    6534:	e7 e3       	ldi	r30, 0x37	; 55
    6536:	f0 e0       	ldi	r31, 0x00	; 0
    6538:	80 81       	ld	r24, Z
    653a:	80 64       	ori	r24, 0x40	; 64
    653c:	8c 93       	st	X, r24
						PORTB|= (1<<6);
    653e:	a8 e3       	ldi	r26, 0x38	; 56
    6540:	b0 e0       	ldi	r27, 0x00	; 0
    6542:	e8 e3       	ldi	r30, 0x38	; 56
    6544:	f0 e0       	ldi	r31, 0x00	; 0
    6546:	80 81       	ld	r24, Z
    6548:	80 64       	ori	r24, 0x40	; 64
    654a:	8c 93       	st	X, r24
						g_Data_Flag=DATA_FREE;
    654c:	10 92 4f 07 	sts	0x074F, r1
						LOC_CurrentTaskAquiringCMD=0;
    6550:	10 92 5e 07 	sts	0x075E, r1
						LOC_LcdState=2;
    6554:	82 e0       	ldi	r24, 0x02	; 2
    6556:	80 93 5d 07 	sts	0x075D, r24
						LOC_DrawPatternState=LCD_Pending;
    655a:	1b 82       	std	Y+3, r1	; 0x03
						LOC_u8Iteration1=0;
    655c:	1a 82       	std	Y+2, r1	; 0x02
    655e:	6f c0       	rjmp	.+222    	; 0x663e <LCD_VidDrawPattern+0x230>
				}
			}
		}
		break;
	case 2:
		if(DATA_FREE==g_Data_Flag)
    6560:	80 91 4f 07 	lds	r24, 0x074F
    6564:	88 23       	and	r24, r24
    6566:	09 f0       	breq	.+2      	; 0x656a <LCD_VidDrawPattern+0x15c>
    6568:	6a c0       	rjmp	.+212    	; 0x663e <LCD_VidDrawPattern+0x230>
		{
			if(CMD_FREE==g_CMND_Flag || (1==LOC_CurrentTaskAquiringCMD))
    656a:	80 91 4e 07 	lds	r24, 0x074E
    656e:	88 23       	and	r24, r24
    6570:	29 f0       	breq	.+10     	; 0x657c <LCD_VidDrawPattern+0x16e>
    6572:	80 91 5e 07 	lds	r24, 0x075E
    6576:	81 30       	cpi	r24, 0x01	; 1
    6578:	09 f0       	breq	.+2      	; 0x657c <LCD_VidDrawPattern+0x16e>
    657a:	61 c0       	rjmp	.+194    	; 0x663e <LCD_VidDrawPattern+0x230>
			{
				LOC_DrawPatternState=LCD_sendCommand(LCD_BlankDis);
    657c:	88 e0       	ldi	r24, 0x08	; 8
    657e:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <LCD_sendCommand>
    6582:	8b 83       	std	Y+3, r24	; 0x03
				g_CMND_Flag=CMD_ACUIRED;
    6584:	81 e0       	ldi	r24, 0x01	; 1
    6586:	80 93 4e 07 	sts	0x074E, r24
				LOC_CurrentTaskAquiringCMD=1;
    658a:	81 e0       	ldi	r24, 0x01	; 1
    658c:	80 93 5e 07 	sts	0x075E, r24
				if(LCD_Finished==LOC_DrawPatternState)
    6590:	8b 81       	ldd	r24, Y+3	; 0x03
    6592:	81 30       	cpi	r24, 0x01	; 1
    6594:	09 f0       	breq	.+2      	; 0x6598 <LCD_VidDrawPattern+0x18a>
    6596:	53 c0       	rjmp	.+166    	; 0x663e <LCD_VidDrawPattern+0x230>
				{
					g_CMND_Flag=CMD_FREE;
    6598:	10 92 4e 07 	sts	0x074E, r1
					LOC_CurrentTaskAquiringCMD=0;
    659c:	10 92 5e 07 	sts	0x075E, r1
					LOC_LcdState=3;
    65a0:	83 e0       	ldi	r24, 0x03	; 3
    65a2:	80 93 5d 07 	sts	0x075D, r24
					LOC_DrawPatternState=LCD_Pending;
    65a6:	1b 82       	std	Y+3, r1	; 0x03
    65a8:	4a c0       	rjmp	.+148    	; 0x663e <LCD_VidDrawPattern+0x230>
			}
		}

		break;
	case 3:
		if(CMD_FREE==g_CMND_Flag||1==LOC_CurrentTaskAquiringCMD)
    65aa:	80 91 4e 07 	lds	r24, 0x074E
    65ae:	88 23       	and	r24, r24
    65b0:	29 f0       	breq	.+10     	; 0x65bc <LCD_VidDrawPattern+0x1ae>
    65b2:	80 91 5e 07 	lds	r24, 0x075E
    65b6:	81 30       	cpi	r24, 0x01	; 1
    65b8:	09 f0       	breq	.+2      	; 0x65bc <LCD_VidDrawPattern+0x1ae>
    65ba:	41 c0       	rjmp	.+130    	; 0x663e <LCD_VidDrawPattern+0x230>
		{
			LOC_DrawPatternState=LCD_gotoRowColumn(COPY_u8Row,COPY_u8Col);
    65bc:	8c 81       	ldd	r24, Y+4	; 0x04
    65be:	6d 81       	ldd	r22, Y+5	; 0x05
    65c0:	0e 94 9d 31 	call	0x633a	; 0x633a <LCD_gotoRowColumn>
    65c4:	8b 83       	std	Y+3, r24	; 0x03
			g_CMND_Flag=CMD_ACUIRED;
    65c6:	81 e0       	ldi	r24, 0x01	; 1
    65c8:	80 93 4e 07 	sts	0x074E, r24
			LOC_CurrentTaskAquiringCMD=1;
    65cc:	81 e0       	ldi	r24, 0x01	; 1
    65ce:	80 93 5e 07 	sts	0x075E, r24
			if(LCD_Finished==LOC_DrawPatternState)
    65d2:	8b 81       	ldd	r24, Y+3	; 0x03
    65d4:	81 30       	cpi	r24, 0x01	; 1
    65d6:	99 f5       	brne	.+102    	; 0x663e <LCD_VidDrawPattern+0x230>
			{
				g_CMND_Flag=CMD_FREE;
    65d8:	10 92 4e 07 	sts	0x074E, r1
				LOC_CurrentTaskAquiringCMD=0;
    65dc:	10 92 5e 07 	sts	0x075E, r1
				LOC_LcdState=4;
    65e0:	84 e0       	ldi	r24, 0x04	; 4
    65e2:	80 93 5d 07 	sts	0x075D, r24
				LOC_DrawPatternState=LCD_Pending;		
    65e6:	1b 82       	std	Y+3, r1	; 0x03
    65e8:	2a c0       	rjmp	.+84     	; 0x663e <LCD_VidDrawPattern+0x230>
													
			}
		}
		break;
	case 4:
		if(CMD_FREE==g_CMND_Flag)
    65ea:	80 91 4e 07 	lds	r24, 0x074E
    65ee:	88 23       	and	r24, r24
    65f0:	31 f5       	brne	.+76     	; 0x663e <LCD_VidDrawPattern+0x230>
		{
			if(DATA_FREE==g_Data_Flag || 1==LOC_CurrentTaskAquiringCMD)
    65f2:	80 91 4f 07 	lds	r24, 0x074F
    65f6:	88 23       	and	r24, r24
    65f8:	21 f0       	breq	.+8      	; 0x6602 <LCD_VidDrawPattern+0x1f4>
    65fa:	80 91 5e 07 	lds	r24, 0x075E
    65fe:	81 30       	cpi	r24, 0x01	; 1
    6600:	f1 f4       	brne	.+60     	; 0x663e <LCD_VidDrawPattern+0x230>
			{
				LOC_DrawPatternState=LCD_DataWr(LOC_u8Iteration2);
    6602:	89 81       	ldd	r24, Y+1	; 0x01
    6604:	0e 94 0a 2f 	call	0x5e14	; 0x5e14 <LCD_DataWr>
    6608:	8b 83       	std	Y+3, r24	; 0x03
				g_Data_Flag=DATA_ACUIRED;
    660a:	81 e0       	ldi	r24, 0x01	; 1
    660c:	80 93 4f 07 	sts	0x074F, r24
				LOC_CurrentTaskAquiringCMD=1;
    6610:	81 e0       	ldi	r24, 0x01	; 1
    6612:	80 93 5e 07 	sts	0x075E, r24
				if(LCD_Finished==LOC_DrawPatternState)
    6616:	8b 81       	ldd	r24, Y+3	; 0x03
    6618:	81 30       	cpi	r24, 0x01	; 1
    661a:	89 f4       	brne	.+34     	; 0x663e <LCD_VidDrawPattern+0x230>
				{
					LOC_u8Iteration2++;
    661c:	89 81       	ldd	r24, Y+1	; 0x01
    661e:	8f 5f       	subi	r24, 0xFF	; 255
    6620:	89 83       	std	Y+1, r24	; 0x01
					LOC_DrawPatternState=LCD_Pending;
    6622:	1b 82       	std	Y+3, r1	; 0x03
					if(LOC_u8Iteration2>=COPY_u8Size)
    6624:	99 81       	ldd	r25, Y+1	; 0x01
    6626:	88 85       	ldd	r24, Y+8	; 0x08
    6628:	98 17       	cp	r25, r24
    662a:	48 f0       	brcs	.+18     	; 0x663e <LCD_VidDrawPattern+0x230>
					{
						g_Data_Flag=DATA_FREE;
    662c:	10 92 4f 07 	sts	0x074F, r1
						LOC_CurrentTaskAquiringCMD=0;
    6630:	10 92 5e 07 	sts	0x075E, r1
						LOC_LcdState=0;
    6634:	10 92 5d 07 	sts	0x075D, r1
						LOC_DrawPatternState=LCD_Finished;
    6638:	81 e0       	ldi	r24, 0x01	; 1
    663a:	8b 83       	std	Y+3, r24	; 0x03
						LOC_u8Iteration2=0;
    663c:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		break;
	}

	return LOC_DrawPatternState;
    663e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6640:	2a 96       	adiw	r28, 0x0a	; 10
    6642:	0f b6       	in	r0, 0x3f	; 63
    6644:	f8 94       	cli
    6646:	de bf       	out	0x3e, r29	; 62
    6648:	0f be       	out	0x3f, r0	; 63
    664a:	cd bf       	out	0x3d, r28	; 61
    664c:	cf 91       	pop	r28
    664e:	df 91       	pop	r29
    6650:	08 95       	ret

00006652 <vidTOGGLE_Led>:
 */
#include "LED.h"
static uint8_t Toggle_Flag=0;

void vidTOGGLE_Led(uint8_t LED_ID)
{
    6652:	df 93       	push	r29
    6654:	cf 93       	push	r28
    6656:	0f 92       	push	r0
    6658:	cd b7       	in	r28, 0x3d	; 61
    665a:	de b7       	in	r29, 0x3e	; 62
    665c:	89 83       	std	Y+1, r24	; 0x01
	if(LOW==Toggle_Flag)
    665e:	80 91 5f 07 	lds	r24, 0x075F
    6662:	88 23       	and	r24, r24
    6664:	41 f4       	brne	.+16     	; 0x6676 <vidTOGGLE_Led+0x24>
	{
		DIO_Write(LED_ID,HIGH);
    6666:	89 81       	ldd	r24, Y+1	; 0x01
    6668:	61 e0       	ldi	r22, 0x01	; 1
    666a:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		Toggle_Flag=HIGH;
    666e:	81 e0       	ldi	r24, 0x01	; 1
    6670:	80 93 5f 07 	sts	0x075F, r24
    6674:	06 c0       	rjmp	.+12     	; 0x6682 <vidTOGGLE_Led+0x30>
	}
	else
	{
		DIO_Write(LED_ID,LOW);
    6676:	89 81       	ldd	r24, Y+1	; 0x01
    6678:	60 e0       	ldi	r22, 0x00	; 0
    667a:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>
		Toggle_Flag=LOW;
    667e:	10 92 5f 07 	sts	0x075F, r1


	}
}
    6682:	0f 90       	pop	r0
    6684:	cf 91       	pop	r28
    6686:	df 91       	pop	r29
    6688:	08 95       	ret

0000668a <vidLED_On>:
void vidLED_On(uint8_t LED_ID)
{
    668a:	df 93       	push	r29
    668c:	cf 93       	push	r28
    668e:	0f 92       	push	r0
    6690:	cd b7       	in	r28, 0x3d	; 61
    6692:	de b7       	in	r29, 0x3e	; 62
    6694:	89 83       	std	Y+1, r24	; 0x01
	DIO_Write(LED_ID,HIGH);
    6696:	89 81       	ldd	r24, Y+1	; 0x01
    6698:	61 e0       	ldi	r22, 0x01	; 1
    669a:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

}
    669e:	0f 90       	pop	r0
    66a0:	cf 91       	pop	r28
    66a2:	df 91       	pop	r29
    66a4:	08 95       	ret

000066a6 <vidLED_off>:
void vidLED_off(uint8_t LED_ID)
{
    66a6:	df 93       	push	r29
    66a8:	cf 93       	push	r28
    66aa:	0f 92       	push	r0
    66ac:	cd b7       	in	r28, 0x3d	; 61
    66ae:	de b7       	in	r29, 0x3e	; 62
    66b0:	89 83       	std	Y+1, r24	; 0x01
	DIO_Write(LED_ID,LOW);
    66b2:	89 81       	ldd	r24, Y+1	; 0x01
    66b4:	60 e0       	ldi	r22, 0x00	; 0
    66b6:	0e 94 03 2c 	call	0x5806	; 0x5806 <DIO_Write>

}
    66ba:	0f 90       	pop	r0
    66bc:	cf 91       	pop	r28
    66be:	df 91       	pop	r29
    66c0:	08 95       	ret

000066c2 <vidINIT_Task>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/

/********************Task environment initialization********************/
void vidINIT_Task(void){
    66c2:	df 93       	push	r29
    66c4:	cf 93       	push	r28
    66c6:	0f 92       	push	r0
    66c8:	cd b7       	in	r28, 0x3d	; 61
    66ca:	de b7       	in	r29, 0x3e	; 62

	static uint8_t LOC_DIO_Init_Status = NOT_INITIALIZED;
	Enum_LCDState LCD_State = LCD_Pending;
    66cc:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if (g_Init_Flag == NOT_INITIALIZED)
    66ce:	80 91 60 07 	lds	r24, 0x0760
    66d2:	88 23       	and	r24, r24
    66d4:	f1 f4       	brne	.+60     	; 0x6712 <vidINIT_Task+0x50>
		{
			if (LOC_DIO_Init_Status != INITIALIZED)
    66d6:	80 91 61 07 	lds	r24, 0x0761
    66da:	81 30       	cpi	r24, 0x01	; 1
    66dc:	29 f0       	breq	.+10     	; 0x66e8 <vidINIT_Task+0x26>
			{
				DIO_Init();
    66de:	0e 94 51 26 	call	0x4ca2	; 0x4ca2 <DIO_Init>
				LOC_DIO_Init_Status = INITIALIZED;
    66e2:	81 e0       	ldi	r24, 0x01	; 1
    66e4:	80 93 61 07 	sts	0x0761, r24
			}
			LCD_State = LCD_init();
    66e8:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <LCD_init>
    66ec:	89 83       	std	Y+1, r24	; 0x01
			if (LCD_State == LCD_Finished)
    66ee:	89 81       	ldd	r24, Y+1	; 0x01
    66f0:	81 30       	cpi	r24, 0x01	; 1
    66f2:	79 f4       	brne	.+30     	; 0x6712 <vidINIT_Task+0x50>
			{
				xEventGroupSetBits(g_xPush_Button_Flags,PushButtonOffLCD);
    66f4:	80 91 6a 07 	lds	r24, 0x076A
    66f8:	90 91 6b 07 	lds	r25, 0x076B
    66fc:	60 e2       	ldi	r22, 0x20	; 32
    66fe:	70 e0       	ldi	r23, 0x00	; 0
    6700:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
				g_Init_Flag = INITIALIZED;
    6704:	81 e0       	ldi	r24, 0x01	; 1
    6706:	80 93 60 07 	sts	0x0760, r24
				vTaskSuspend(NULL);
    670a:	80 e0       	ldi	r24, 0x00	; 0
    670c:	90 e0       	ldi	r25, 0x00	; 0
    670e:	0e 94 bb 19 	call	0x3376	; 0x3376 <vTaskSuspend>
			}
		}
		vTaskDelay(2);
    6712:	82 e0       	ldi	r24, 0x02	; 2
    6714:	90 e0       	ldi	r25, 0x00	; 0
    6716:	0e 94 99 19 	call	0x3332	; 0x3332 <vTaskDelay>
    671a:	d9 cf       	rjmp	.-78     	; 0x66ce <vidINIT_Task+0xc>

0000671c <vidPB1_Task>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/
/********************First Push button Task *****************************/
void vidPB1_Task(void * COPY_User_Periodicity)
{
    671c:	df 93       	push	r29
    671e:	cf 93       	push	r28
    6720:	00 d0       	rcall	.+0      	; 0x6722 <vidPB1_Task+0x6>
    6722:	cd b7       	in	r28, 0x3d	; 61
    6724:	de b7       	in	r29, 0x3e	; 62
    6726:	9a 83       	std	Y+2, r25	; 0x02
    6728:	89 83       	std	Y+1, r24	; 0x01
	static uint8_t LOC_Semaphore_Taken=0;

	while(1)
	{
		/***********Guard to Check the initialization Status************/
		if(g_Init_Flag == INITIALIZED)
    672a:	80 91 60 07 	lds	r24, 0x0760
    672e:	81 30       	cpi	r24, 0x01	; 1
    6730:	09 f0       	breq	.+2      	; 0x6734 <vidPB1_Task+0x18>
    6732:	69 c0       	rjmp	.+210    	; 0x6806 <vidPB1_Task+0xea>
		{
			if(LOC_Semaphore_Taken == 0)
    6734:	80 91 62 07 	lds	r24, 0x0762
    6738:	88 23       	and	r24, r24
    673a:	59 f4       	brne	.+22     	; 0x6752 <vidPB1_Task+0x36>
			{
				xSemaphoreTake(g_xPush_Botton_Mutex , portMAX_DELAY);
    673c:	80 91 6c 07 	lds	r24, 0x076C
    6740:	90 91 6d 07 	lds	r25, 0x076D
    6744:	6f ef       	ldi	r22, 0xFF	; 255
    6746:	7f ef       	ldi	r23, 0xFF	; 255
    6748:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <xQueueSemaphoreTake>
				LOC_Semaphore_Taken = 1;
    674c:	81 e0       	ldi	r24, 0x01	; 1
    674e:	80 93 62 07 	sts	0x0762, r24
			}
			/************************Get the status of the key Pressed or not Pressed*******************/
			DIO_Read(PUSH_BUTTON1,&LOC_Current_SwitchStatus);
    6752:	23 e6       	ldi	r18, 0x63	; 99
    6754:	37 e0       	ldi	r19, 0x07	; 7
    6756:	87 e0       	ldi	r24, 0x07	; 7
    6758:	b9 01       	movw	r22, r18
    675a:	0e 94 80 2d 	call	0x5b00	; 0x5b00 <DIO_Read>
			/*************************Condition of pressed key and compare
			 ************************** with last Key Status when it was unpressed**************/
			if( (LOC_Current_SwitchStatus == Switch_Pressed) && (LOC_Last_Switch_Status == Switch_NotPressed) )
    675e:	80 91 63 07 	lds	r24, 0x0763
    6762:	81 30       	cpi	r24, 0x01	; 1
    6764:	c9 f4       	brne	.+50     	; 0x6798 <vidPB1_Task+0x7c>
    6766:	80 91 64 07 	lds	r24, 0x0764
    676a:	88 23       	and	r24, r24
    676c:	a9 f4       	brne	.+42     	; 0x6798 <vidPB1_Task+0x7c>
			{
				LOC_Last_Switch_Status = LOC_Current_SwitchStatus;
    676e:	80 91 63 07 	lds	r24, 0x0763
    6772:	80 93 64 07 	sts	0x0764, r24
				xEventGroupClearBits(g_xPush_Button_Flags,PushButtonOffLED|PushButtonOffLCD);
    6776:	80 91 6a 07 	lds	r24, 0x076A
    677a:	90 91 6b 07 	lds	r25, 0x076B
    677e:	60 e3       	ldi	r22, 0x30	; 48
    6780:	70 e0       	ldi	r23, 0x00	; 0
    6782:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
				xEventGroupSetBits(g_xPush_Button_Flags,LED_PushButton1|LCD_PushButton1);
    6786:	80 91 6a 07 	lds	r24, 0x076A
    678a:	90 91 6b 07 	lds	r25, 0x076B
    678e:	65 e0       	ldi	r22, 0x05	; 5
    6790:	70 e0       	ldi	r23, 0x00	; 0
    6792:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
    6796:	37 c0       	rjmp	.+110    	; 0x6806 <vidPB1_Task+0xea>
			}
			/*************************Condition of not pressed key and compare
			 ************************** with last Key Status when it was pressed**************/
			else if( (LOC_Current_SwitchStatus == Switch_NotPressed) && (LOC_Last_Switch_Status == Switch_Pressed) )
    6798:	80 91 63 07 	lds	r24, 0x0763
    679c:	88 23       	and	r24, r24
    679e:	f1 f4       	brne	.+60     	; 0x67dc <vidPB1_Task+0xc0>
    67a0:	80 91 64 07 	lds	r24, 0x0764
    67a4:	81 30       	cpi	r24, 0x01	; 1
    67a6:	d1 f4       	brne	.+52     	; 0x67dc <vidPB1_Task+0xc0>
			{
				LOC_Last_Switch_Status = LOC_Current_SwitchStatus;
    67a8:	80 91 63 07 	lds	r24, 0x0763
    67ac:	80 93 64 07 	sts	0x0764, r24
				xEventGroupSetBits(g_xPush_Button_Flags,PushButtonOffLED|PushButtonOffLCD);
    67b0:	80 91 6a 07 	lds	r24, 0x076A
    67b4:	90 91 6b 07 	lds	r25, 0x076B
    67b8:	60 e3       	ldi	r22, 0x30	; 48
    67ba:	70 e0       	ldi	r23, 0x00	; 0
    67bc:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
				xSemaphoreGive(g_xPush_Botton_Mutex);
    67c0:	80 91 6c 07 	lds	r24, 0x076C
    67c4:	90 91 6d 07 	lds	r25, 0x076D
    67c8:	60 e0       	ldi	r22, 0x00	; 0
    67ca:	70 e0       	ldi	r23, 0x00	; 0
    67cc:	40 e0       	ldi	r20, 0x00	; 0
    67ce:	50 e0       	ldi	r21, 0x00	; 0
    67d0:	20 e0       	ldi	r18, 0x00	; 0
    67d2:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xQueueGenericSend>
				LOC_Semaphore_Taken=0;
    67d6:	10 92 62 07 	sts	0x0762, r1
    67da:	15 c0       	rjmp	.+42     	; 0x6806 <vidPB1_Task+0xea>
			}
			/*************************Condition of not pressed key and compare
			 ********************** with last Key Status when it was unpressed**************/
			else if( (LOC_Current_SwitchStatus == Switch_NotPressed) && (LOC_Last_Switch_Status == Switch_NotPressed) )
    67dc:	80 91 63 07 	lds	r24, 0x0763
    67e0:	88 23       	and	r24, r24
    67e2:	89 f4       	brne	.+34     	; 0x6806 <vidPB1_Task+0xea>
    67e4:	80 91 64 07 	lds	r24, 0x0764
    67e8:	88 23       	and	r24, r24
    67ea:	69 f4       	brne	.+26     	; 0x6806 <vidPB1_Task+0xea>
			{
				xSemaphoreGive(g_xPush_Botton_Mutex);
    67ec:	80 91 6c 07 	lds	r24, 0x076C
    67f0:	90 91 6d 07 	lds	r25, 0x076D
    67f4:	60 e0       	ldi	r22, 0x00	; 0
    67f6:	70 e0       	ldi	r23, 0x00	; 0
    67f8:	40 e0       	ldi	r20, 0x00	; 0
    67fa:	50 e0       	ldi	r21, 0x00	; 0
    67fc:	20 e0       	ldi	r18, 0x00	; 0
    67fe:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xQueueGenericSend>
				LOC_Semaphore_Taken=0;
    6802:	10 92 62 07 	sts	0x0762, r1
			}
		}
		vTaskDelay(30);
    6806:	8e e1       	ldi	r24, 0x1E	; 30
    6808:	90 e0       	ldi	r25, 0x00	; 0
    680a:	0e 94 99 19 	call	0x3332	; 0x3332 <vTaskDelay>
    680e:	8d cf       	rjmp	.-230    	; 0x672a <vidPB1_Task+0xe>

00006810 <vidPB2_Task>:
 * i-o/p:  NULL
 * return: NULL:*/
/********************Secound Push button Task *****************************/

void vidPB2_Task(void * COPY_User_Periodicity)
{
    6810:	df 93       	push	r29
    6812:	cf 93       	push	r28
    6814:	00 d0       	rcall	.+0      	; 0x6816 <vidPB2_Task+0x6>
    6816:	cd b7       	in	r28, 0x3d	; 61
    6818:	de b7       	in	r29, 0x3e	; 62
    681a:	9a 83       	std	Y+2, r25	; 0x02
    681c:	89 83       	std	Y+1, r24	; 0x01
	static uint8_t LOC_Semaphore_Taken=0;

	while(1)
	{
		/***********Guard to Check the initialization Status************/
		if(g_Init_Flag == INITIALIZED)
    681e:	80 91 60 07 	lds	r24, 0x0760
    6822:	81 30       	cpi	r24, 0x01	; 1
    6824:	09 f0       	breq	.+2      	; 0x6828 <vidPB2_Task+0x18>
    6826:	69 c0       	rjmp	.+210    	; 0x68fa <vidPB2_Task+0xea>
		{
			if(LOC_Semaphore_Taken == 0)
    6828:	80 91 65 07 	lds	r24, 0x0765
    682c:	88 23       	and	r24, r24
    682e:	59 f4       	brne	.+22     	; 0x6846 <vidPB2_Task+0x36>
			{
				xSemaphoreTake(g_xPush_Botton_Mutex , portMAX_DELAY);
    6830:	80 91 6c 07 	lds	r24, 0x076C
    6834:	90 91 6d 07 	lds	r25, 0x076D
    6838:	6f ef       	ldi	r22, 0xFF	; 255
    683a:	7f ef       	ldi	r23, 0xFF	; 255
    683c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <xQueueSemaphoreTake>
				LOC_Semaphore_Taken = 1;
    6840:	81 e0       	ldi	r24, 0x01	; 1
    6842:	80 93 65 07 	sts	0x0765, r24
			}
			/************************Get the status of the key Pressed or not Pressed*******************/
			DIO_Read(PUSH_BUTTON1,&LOC_Current_SwitchStatus);
    6846:	26 e6       	ldi	r18, 0x66	; 102
    6848:	37 e0       	ldi	r19, 0x07	; 7
    684a:	87 e0       	ldi	r24, 0x07	; 7
    684c:	b9 01       	movw	r22, r18
    684e:	0e 94 80 2d 	call	0x5b00	; 0x5b00 <DIO_Read>
			/*************************Condition of pressed key and compare
			 ************************** with last Key Status when it was unpressed**************/
			if( (LOC_Current_SwitchStatus == Switch_Pressed) && (LOC_Last_Switch_Status == Switch_NotPressed) )
    6852:	80 91 66 07 	lds	r24, 0x0766
    6856:	81 30       	cpi	r24, 0x01	; 1
    6858:	c9 f4       	brne	.+50     	; 0x688c <vidPB2_Task+0x7c>
    685a:	80 91 67 07 	lds	r24, 0x0767
    685e:	88 23       	and	r24, r24
    6860:	a9 f4       	brne	.+42     	; 0x688c <vidPB2_Task+0x7c>
			{
				LOC_Last_Switch_Status = LOC_Current_SwitchStatus;
    6862:	80 91 66 07 	lds	r24, 0x0766
    6866:	80 93 67 07 	sts	0x0767, r24
				xEventGroupClearBits(g_xPush_Button_Flags,PushButtonOffLED|PushButtonOffLCD);
    686a:	80 91 6a 07 	lds	r24, 0x076A
    686e:	90 91 6b 07 	lds	r25, 0x076B
    6872:	60 e3       	ldi	r22, 0x30	; 48
    6874:	70 e0       	ldi	r23, 0x00	; 0
    6876:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
				xEventGroupSetBits(g_xPush_Button_Flags,LED_PushButton1|LCD_PushButton1);
    687a:	80 91 6a 07 	lds	r24, 0x076A
    687e:	90 91 6b 07 	lds	r25, 0x076B
    6882:	65 e0       	ldi	r22, 0x05	; 5
    6884:	70 e0       	ldi	r23, 0x00	; 0
    6886:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
    688a:	37 c0       	rjmp	.+110    	; 0x68fa <vidPB2_Task+0xea>
			}
			/*************************Condition of not pressed key and compare
			 ************************** with last Key Status when it was pressed**************/
			else if( (LOC_Current_SwitchStatus == Switch_NotPressed) && (LOC_Last_Switch_Status == Switch_Pressed) )
    688c:	80 91 66 07 	lds	r24, 0x0766
    6890:	88 23       	and	r24, r24
    6892:	f1 f4       	brne	.+60     	; 0x68d0 <vidPB2_Task+0xc0>
    6894:	80 91 67 07 	lds	r24, 0x0767
    6898:	81 30       	cpi	r24, 0x01	; 1
    689a:	d1 f4       	brne	.+52     	; 0x68d0 <vidPB2_Task+0xc0>
			{
				LOC_Last_Switch_Status = LOC_Current_SwitchStatus;
    689c:	80 91 66 07 	lds	r24, 0x0766
    68a0:	80 93 67 07 	sts	0x0767, r24
				xEventGroupSetBits(g_xPush_Button_Flags,PushButtonOffLED|PushButtonOffLCD);
    68a4:	80 91 6a 07 	lds	r24, 0x076A
    68a8:	90 91 6b 07 	lds	r25, 0x076B
    68ac:	60 e3       	ldi	r22, 0x30	; 48
    68ae:	70 e0       	ldi	r23, 0x00	; 0
    68b0:	0e 94 3f 02 	call	0x47e	; 0x47e <xEventGroupSetBits>
				xSemaphoreGive(g_xPush_Botton_Mutex);
    68b4:	80 91 6c 07 	lds	r24, 0x076C
    68b8:	90 91 6d 07 	lds	r25, 0x076D
    68bc:	60 e0       	ldi	r22, 0x00	; 0
    68be:	70 e0       	ldi	r23, 0x00	; 0
    68c0:	40 e0       	ldi	r20, 0x00	; 0
    68c2:	50 e0       	ldi	r21, 0x00	; 0
    68c4:	20 e0       	ldi	r18, 0x00	; 0
    68c6:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xQueueGenericSend>
				LOC_Semaphore_Taken=0;
    68ca:	10 92 65 07 	sts	0x0765, r1
    68ce:	15 c0       	rjmp	.+42     	; 0x68fa <vidPB2_Task+0xea>
			}
			/*************************Condition of not pressed key and compare
			 ********************** with last Key Status when it was unpressed**************/
			else if( (LOC_Current_SwitchStatus == Switch_NotPressed) && (LOC_Last_Switch_Status == Switch_NotPressed) )
    68d0:	80 91 66 07 	lds	r24, 0x0766
    68d4:	88 23       	and	r24, r24
    68d6:	89 f4       	brne	.+34     	; 0x68fa <vidPB2_Task+0xea>
    68d8:	80 91 67 07 	lds	r24, 0x0767
    68dc:	88 23       	and	r24, r24
    68de:	69 f4       	brne	.+26     	; 0x68fa <vidPB2_Task+0xea>
			{
				xSemaphoreGive(g_xPush_Botton_Mutex);
    68e0:	80 91 6c 07 	lds	r24, 0x076C
    68e4:	90 91 6d 07 	lds	r25, 0x076D
    68e8:	60 e0       	ldi	r22, 0x00	; 0
    68ea:	70 e0       	ldi	r23, 0x00	; 0
    68ec:	40 e0       	ldi	r20, 0x00	; 0
    68ee:	50 e0       	ldi	r21, 0x00	; 0
    68f0:	20 e0       	ldi	r18, 0x00	; 0
    68f2:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xQueueGenericSend>
				LOC_Semaphore_Taken=0;
    68f6:	10 92 65 07 	sts	0x0765, r1
			}
		}
		vTaskDelay(30);
    68fa:	8e e1       	ldi	r24, 0x1E	; 30
    68fc:	90 e0       	ldi	r25, 0x00	; 0
    68fe:	0e 94 99 19 	call	0x3332	; 0x3332 <vTaskDelay>
    6902:	8d cf       	rjmp	.-230    	; 0x681e <vidPB2_Task+0xe>

00006904 <vidLED_Task>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/
/********************LED State  Task *****************************/
void vidLED_Task(void * COPY_User_Periodicity)
{
    6904:	0f 93       	push	r16
    6906:	1f 93       	push	r17
    6908:	df 93       	push	r29
    690a:	cf 93       	push	r28
    690c:	00 d0       	rcall	.+0      	; 0x690e <vidLED_Task+0xa>
    690e:	cd b7       	in	r28, 0x3d	; 61
    6910:	de b7       	in	r29, 0x3e	; 62
    6912:	9a 83       	std	Y+2, r25	; 0x02
    6914:	89 83       	std	Y+1, r24	; 0x01

	static EventBits_t  LOC_LED_EventBits_Value = 0;
	while(1)
	{
		LOC_LED_EventBits_Value =  xEventGroupWaitBits(g_xPush_Button_Flags , (LED_PushButton1 | LED_PushButton2 | PushButtonOffLED) , pdFALSE , pdFALSE , portMAX_DELAY);
    6916:	80 91 6a 07 	lds	r24, 0x076A
    691a:	90 91 6b 07 	lds	r25, 0x076B
    691e:	63 e1       	ldi	r22, 0x13	; 19
    6920:	70 e0       	ldi	r23, 0x00	; 0
    6922:	40 e0       	ldi	r20, 0x00	; 0
    6924:	20 e0       	ldi	r18, 0x00	; 0
    6926:	0f ef       	ldi	r16, 0xFF	; 255
    6928:	1f ef       	ldi	r17, 0xFF	; 255
    692a:	0e 94 21 01 	call	0x242	; 0x242 <xEventGroupWaitBits>
    692e:	90 93 69 07 	sts	0x0769, r25
    6932:	80 93 68 07 	sts	0x0768, r24

		LOC_LED_EventBits_Value &= ( (LED_PushButton1) | (LED_PushButton2) | (PushButtonOffLED) );
    6936:	80 91 68 07 	lds	r24, 0x0768
    693a:	90 91 69 07 	lds	r25, 0x0769
    693e:	83 71       	andi	r24, 0x13	; 19
    6940:	90 70       	andi	r25, 0x00	; 0
    6942:	90 93 69 07 	sts	0x0769, r25
    6946:	80 93 68 07 	sts	0x0768, r24
		/********Check if the First Push Button Pressed Flag to Turn Led on***********/
		if(LED_PushButton1 == LOC_LED_EventBits_Value)
    694a:	80 91 68 07 	lds	r24, 0x0768
    694e:	90 91 69 07 	lds	r25, 0x0769
    6952:	81 30       	cpi	r24, 0x01	; 1
    6954:	91 05       	cpc	r25, r1
    6956:	69 f4       	brne	.+26     	; 0x6972 <vidLED_Task+0x6e>
		{
			vidLED_On(LED_1);
    6958:	89 e0       	ldi	r24, 0x09	; 9
    695a:	90 e0       	ldi	r25, 0x00	; 0
    695c:	0e 94 45 33 	call	0x668a	; 0x668a <vidLED_On>
			xEventGroupClearBits(g_xPush_Button_Flags , ( LED_PushButton1) );
    6960:	80 91 6a 07 	lds	r24, 0x076A
    6964:	90 91 6b 07 	lds	r25, 0x076B
    6968:	61 e0       	ldi	r22, 0x01	; 1
    696a:	70 e0       	ldi	r23, 0x00	; 0
    696c:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
    6970:	27 c0       	rjmp	.+78     	; 0x69c0 <vidLED_Task+0xbc>
		}
		/********Check if the second Push Button Pressed Flag to Turn Led on***********/
		else if(LED_PushButton2==LOC_LED_EventBits_Value)
    6972:	80 91 68 07 	lds	r24, 0x0768
    6976:	90 91 69 07 	lds	r25, 0x0769
    697a:	82 30       	cpi	r24, 0x02	; 2
    697c:	91 05       	cpc	r25, r1
    697e:	69 f4       	brne	.+26     	; 0x699a <vidLED_Task+0x96>
		{
			vidLED_On(LED_1);
    6980:	89 e0       	ldi	r24, 0x09	; 9
    6982:	90 e0       	ldi	r25, 0x00	; 0
    6984:	0e 94 45 33 	call	0x668a	; 0x668a <vidLED_On>
			xEventGroupClearBits(g_xPush_Button_Flags , ( LED_PushButton2) );
    6988:	80 91 6a 07 	lds	r24, 0x076A
    698c:	90 91 6b 07 	lds	r25, 0x076B
    6990:	62 e0       	ldi	r22, 0x02	; 2
    6992:	70 e0       	ldi	r23, 0x00	; 0
    6994:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
    6998:	13 c0       	rjmp	.+38     	; 0x69c0 <vidLED_Task+0xbc>
		}
		/*****************Check if there is no Push Buttons Pressed flag
		 * to Turn Led on So turn Led off*********************************/

		else if(PushButtonOffLED==LOC_LED_EventBits_Value)
    699a:	80 91 68 07 	lds	r24, 0x0768
    699e:	90 91 69 07 	lds	r25, 0x0769
    69a2:	80 31       	cpi	r24, 0x10	; 16
    69a4:	91 05       	cpc	r25, r1
    69a6:	61 f4       	brne	.+24     	; 0x69c0 <vidLED_Task+0xbc>
		{
			vidLED_off(LED_1);
    69a8:	89 e0       	ldi	r24, 0x09	; 9
    69aa:	90 e0       	ldi	r25, 0x00	; 0
    69ac:	0e 94 53 33 	call	0x66a6	; 0x66a6 <vidLED_off>
			xEventGroupClearBits(g_xPush_Button_Flags , ( PushButtonOffLED ) );
    69b0:	80 91 6a 07 	lds	r24, 0x076A
    69b4:	90 91 6b 07 	lds	r25, 0x076B
    69b8:	60 e1       	ldi	r22, 0x10	; 16
    69ba:	70 e0       	ldi	r23, 0x00	; 0
    69bc:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
		else
		{

		}

		vTaskDelay(50);
    69c0:	82 e3       	ldi	r24, 0x32	; 50
    69c2:	90 e0       	ldi	r25, 0x00	; 0
    69c4:	0e 94 99 19 	call	0x3332	; 0x3332 <vTaskDelay>
    69c8:	a6 cf       	rjmp	.-180    	; 0x6916 <vidLED_Task+0x12>

000069ca <vidLCD_Task>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/
/*********LCD Task with user definition of periodicity *****************/
void vidLCD_Task(void * COPY_User_Periodicity)
{
    69ca:	0f 93       	push	r16
    69cc:	1f 93       	push	r17
    69ce:	df 93       	push	r29
    69d0:	cf 93       	push	r28
    69d2:	00 d0       	rcall	.+0      	; 0x69d4 <vidLCD_Task+0xa>
    69d4:	00 d0       	rcall	.+0      	; 0x69d6 <vidLCD_Task+0xc>
    69d6:	0f 92       	push	r0
    69d8:	cd b7       	in	r28, 0x3d	; 61
    69da:	de b7       	in	r29, 0x3e	; 62
    69dc:	9d 83       	std	Y+5, r25	; 0x05
    69de:	8c 83       	std	Y+4, r24	; 0x04

	EventBits_t  LOC_LCD_EventBits_Value = 0;
    69e0:	1b 82       	std	Y+3, r1	; 0x03
    69e2:	1a 82       	std	Y+2, r1	; 0x02
	Enum_LCDState LOC_LCD_StatusFlag = LCD_Pending;
    69e4:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		/***************Check on a Event Flags which let LCD Know which Button
		 *Caused LED Turned on to monitoring the status of LED and push Buttons */
		LOC_LCD_EventBits_Value =  xEventGroupWaitBits(g_xPush_Button_Flags , (LCD_PushButton1 | LCD_PushButton2 | PushButtonOffLCD) , pdFALSE , pdFALSE , portMAX_DELAY);
    69e6:	80 91 6a 07 	lds	r24, 0x076A
    69ea:	90 91 6b 07 	lds	r25, 0x076B
    69ee:	6c e2       	ldi	r22, 0x2C	; 44
    69f0:	70 e0       	ldi	r23, 0x00	; 0
    69f2:	40 e0       	ldi	r20, 0x00	; 0
    69f4:	20 e0       	ldi	r18, 0x00	; 0
    69f6:	0f ef       	ldi	r16, 0xFF	; 255
    69f8:	1f ef       	ldi	r17, 0xFF	; 255
    69fa:	0e 94 21 01 	call	0x242	; 0x242 <xEventGroupWaitBits>
    69fe:	9b 83       	std	Y+3, r25	; 0x03
    6a00:	8a 83       	std	Y+2, r24	; 0x02
		LOC_LCD_EventBits_Value &= ( (LCD_PushButton1) | (LCD_PushButton2) | (PushButtonOffLCD) );
    6a02:	8a 81       	ldd	r24, Y+2	; 0x02
    6a04:	9b 81       	ldd	r25, Y+3	; 0x03
    6a06:	8c 72       	andi	r24, 0x2C	; 44
    6a08:	90 70       	andi	r25, 0x00	; 0
    6a0a:	9b 83       	std	Y+3, r25	; 0x03
    6a0c:	8a 83       	std	Y+2, r24	; 0x02

		/************First Condition if the First push Button was responsible for
		 * turned LED on Display  "LED ON by PB 1" and clear this flag to another check */
		if(LCD_PushButton1==LOC_LCD_EventBits_Value)
    6a0e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a10:	9b 81       	ldd	r25, Y+3	; 0x03
    6a12:	84 30       	cpi	r24, 0x04	; 4
    6a14:	91 05       	cpc	r25, r1
    6a16:	99 f4       	brne	.+38     	; 0x6a3e <vidLCD_Task+0x74>
		{
			LOC_LCD_StatusFlag = LCD_displayStringRowColumn("LED ON by PB 1" , 0,0);
    6a18:	85 e6       	ldi	r24, 0x65	; 101
    6a1a:	90 e0       	ldi	r25, 0x00	; 0
    6a1c:	60 e0       	ldi	r22, 0x00	; 0
    6a1e:	40 e0       	ldi	r20, 0x00	; 0
    6a20:	0e 94 0b 31 	call	0x6216	; 0x6216 <LCD_displayStringRowColumn>
    6a24:	89 83       	std	Y+1, r24	; 0x01
			if (LOC_LCD_StatusFlag == LCD_Finished)
    6a26:	89 81       	ldd	r24, Y+1	; 0x01
    6a28:	81 30       	cpi	r24, 0x01	; 1
    6a2a:	c1 f5       	brne	.+112    	; 0x6a9c <vidLCD_Task+0xd2>
			{
				xEventGroupClearBits(g_xPush_Button_Flags , ( LCD_PushButton1 ) );
    6a2c:	80 91 6a 07 	lds	r24, 0x076A
    6a30:	90 91 6b 07 	lds	r25, 0x076B
    6a34:	64 e0       	ldi	r22, 0x04	; 4
    6a36:	70 e0       	ldi	r23, 0x00	; 0
    6a38:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
    6a3c:	2f c0       	rjmp	.+94     	; 0x6a9c <vidLCD_Task+0xd2>

			}
		}
		/************Second Condition if the second push Button was responsible for
		 * turned LED on Display  "LED ON by PB 2" and clear this flag to another check */
		else if(LCD_PushButton2==LOC_LCD_EventBits_Value)
    6a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a40:	9b 81       	ldd	r25, Y+3	; 0x03
    6a42:	88 30       	cpi	r24, 0x08	; 8
    6a44:	91 05       	cpc	r25, r1
    6a46:	99 f4       	brne	.+38     	; 0x6a6e <vidLCD_Task+0xa4>
		{
			LOC_LCD_StatusFlag = LCD_displayStringRowColumn("LED ON by PB 2" , 0,0);
    6a48:	84 e7       	ldi	r24, 0x74	; 116
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	60 e0       	ldi	r22, 0x00	; 0
    6a4e:	40 e0       	ldi	r20, 0x00	; 0
    6a50:	0e 94 0b 31 	call	0x6216	; 0x6216 <LCD_displayStringRowColumn>
    6a54:	89 83       	std	Y+1, r24	; 0x01
			if (LOC_LCD_StatusFlag == LCD_Finished)
    6a56:	89 81       	ldd	r24, Y+1	; 0x01
    6a58:	81 30       	cpi	r24, 0x01	; 1
    6a5a:	01 f5       	brne	.+64     	; 0x6a9c <vidLCD_Task+0xd2>
			{
				xEventGroupClearBits(g_xPush_Button_Flags , ( LCD_PushButton2 ) );
    6a5c:	80 91 6a 07 	lds	r24, 0x076A
    6a60:	90 91 6b 07 	lds	r25, 0x076B
    6a64:	68 e0       	ldi	r22, 0x08	; 8
    6a66:	70 e0       	ldi	r23, 0x00	; 0
    6a68:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
    6a6c:	17 c0       	rjmp	.+46     	; 0x6a9c <vidLCD_Task+0xd2>
			}
		}
		/************third Condition if there is no push Button was responsible for
		 * turned LED on so LED Turned off and LCD
		 *  Display  "LED turned off" and clear this flag to another check */
		else if(PushButtonOffLCD==LOC_LCD_EventBits_Value)
    6a6e:	8a 81       	ldd	r24, Y+2	; 0x02
    6a70:	9b 81       	ldd	r25, Y+3	; 0x03
    6a72:	80 32       	cpi	r24, 0x20	; 32
    6a74:	91 05       	cpc	r25, r1
    6a76:	91 f4       	brne	.+36     	; 0x6a9c <vidLCD_Task+0xd2>
		{
			LOC_LCD_StatusFlag = LCD_displayStringRowColumn("LED turned off       " , 0,0);
    6a78:	83 e8       	ldi	r24, 0x83	; 131
    6a7a:	90 e0       	ldi	r25, 0x00	; 0
    6a7c:	60 e0       	ldi	r22, 0x00	; 0
    6a7e:	40 e0       	ldi	r20, 0x00	; 0
    6a80:	0e 94 0b 31 	call	0x6216	; 0x6216 <LCD_displayStringRowColumn>
    6a84:	89 83       	std	Y+1, r24	; 0x01
			if (LOC_LCD_StatusFlag == LCD_Finished)
    6a86:	89 81       	ldd	r24, Y+1	; 0x01
    6a88:	81 30       	cpi	r24, 0x01	; 1
    6a8a:	41 f4       	brne	.+16     	; 0x6a9c <vidLCD_Task+0xd2>
			{
				xEventGroupClearBits(g_xPush_Button_Flags , ( PushButtonOffLCD ) );
    6a8c:	80 91 6a 07 	lds	r24, 0x076A
    6a90:	90 91 6b 07 	lds	r25, 0x076B
    6a94:	60 e2       	ldi	r22, 0x20	; 32
    6a96:	70 e0       	ldi	r23, 0x00	; 0
    6a98:	0e 94 e7 01 	call	0x3ce	; 0x3ce <xEventGroupClearBits>
		}
		else
		{

		}
		vTaskDelay(2);
    6a9c:	82 e0       	ldi	r24, 0x02	; 2
    6a9e:	90 e0       	ldi	r25, 0x00	; 0
    6aa0:	0e 94 99 19 	call	0x3332	; 0x3332 <vTaskDelay>
    6aa4:	a0 cf       	rjmp	.-192    	; 0x69e6 <vidLCD_Task+0x1c>

00006aa6 <vidCreateAllMutex>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/
/*********Function to create Global mutex *****************/
void vidCreateAllMutex(void)
{
    6aa6:	df 93       	push	r29
    6aa8:	cf 93       	push	r28
    6aaa:	cd b7       	in	r28, 0x3d	; 61
    6aac:	de b7       	in	r29, 0x3e	; 62
	g_xPush_Botton_Mutex = xSemaphoreCreateMutex();
    6aae:	81 e0       	ldi	r24, 0x01	; 1
    6ab0:	0e 94 4a 09 	call	0x1294	; 0x1294 <xQueueCreateMutex>
    6ab4:	90 93 6d 07 	sts	0x076D, r25
    6ab8:	80 93 6c 07 	sts	0x076C, r24
}
    6abc:	cf 91       	pop	r28
    6abe:	df 91       	pop	r29
    6ac0:	08 95       	ret

00006ac2 <vidCreatAllEvents>:
 * o/p:    NULL
 * i-o/p:  NULL
 * return: NULL:*/
/*********Function to create Global mutex *****************/
void vidCreatAllEvents(void)
{
    6ac2:	df 93       	push	r29
    6ac4:	cf 93       	push	r28
    6ac6:	cd b7       	in	r28, 0x3d	; 61
    6ac8:	de b7       	in	r29, 0x3e	; 62
	g_xPush_Button_Flags = xEventGroupCreate();
    6aca:	0e 94 49 00 	call	0x92	; 0x92 <xEventGroupCreate>
    6ace:	90 93 6b 07 	sts	0x076B, r25
    6ad2:	80 93 6a 07 	sts	0x076A, r24
}
    6ad6:	cf 91       	pop	r28
    6ad8:	df 91       	pop	r29
    6ada:	08 95       	ret

00006adc <main>:


#include "Sprint2_Story2.h"

void main(void)
{
    6adc:	ef 92       	push	r14
    6ade:	ff 92       	push	r15
    6ae0:	0f 93       	push	r16
    6ae2:	df 93       	push	r29
    6ae4:	cf 93       	push	r28
    6ae6:	cd b7       	in	r28, 0x3d	; 61
    6ae8:	de b7       	in	r29, 0x3e	; 62



	/********************Event group Creation***************/
	vidCreatAllEvents();
    6aea:	0e 94 61 35 	call	0x6ac2	; 0x6ac2 <vidCreatAllEvents>
	/********************Mutex Creation*********************/
	vidCreateAllMutex();
    6aee:	0e 94 53 35 	call	0x6aa6	; 0x6aa6 <vidCreateAllMutex>
	/*******************Task Creation************************/

	xTaskCreate(vidINIT_Task,"init",85,NULL,4,NULL);
    6af2:	81 e6       	ldi	r24, 0x61	; 97
    6af4:	93 e3       	ldi	r25, 0x33	; 51
    6af6:	29 e9       	ldi	r18, 0x99	; 153
    6af8:	30 e0       	ldi	r19, 0x00	; 0
    6afa:	b9 01       	movw	r22, r18
    6afc:	45 e5       	ldi	r20, 0x55	; 85
    6afe:	50 e0       	ldi	r21, 0x00	; 0
    6b00:	20 e0       	ldi	r18, 0x00	; 0
    6b02:	30 e0       	ldi	r19, 0x00	; 0
    6b04:	04 e0       	ldi	r16, 0x04	; 4
    6b06:	ee 24       	eor	r14, r14
    6b08:	ff 24       	eor	r15, r15
    6b0a:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>

	xTaskCreate(vidPB1_Task,"Push_Button1",85,NULL,3,NULL);
    6b0e:	8e e8       	ldi	r24, 0x8E	; 142
    6b10:	93 e3       	ldi	r25, 0x33	; 51
    6b12:	2e e9       	ldi	r18, 0x9E	; 158
    6b14:	30 e0       	ldi	r19, 0x00	; 0
    6b16:	b9 01       	movw	r22, r18
    6b18:	45 e5       	ldi	r20, 0x55	; 85
    6b1a:	50 e0       	ldi	r21, 0x00	; 0
    6b1c:	20 e0       	ldi	r18, 0x00	; 0
    6b1e:	30 e0       	ldi	r19, 0x00	; 0
    6b20:	03 e0       	ldi	r16, 0x03	; 3
    6b22:	ee 24       	eor	r14, r14
    6b24:	ff 24       	eor	r15, r15
    6b26:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>

	xTaskCreate(vidPB2_Task,"Push_Button2",200,NULL,3,NULL);
    6b2a:	88 e0       	ldi	r24, 0x08	; 8
    6b2c:	94 e3       	ldi	r25, 0x34	; 52
    6b2e:	2b ea       	ldi	r18, 0xAB	; 171
    6b30:	30 e0       	ldi	r19, 0x00	; 0
    6b32:	b9 01       	movw	r22, r18
    6b34:	48 ec       	ldi	r20, 0xC8	; 200
    6b36:	50 e0       	ldi	r21, 0x00	; 0
    6b38:	20 e0       	ldi	r18, 0x00	; 0
    6b3a:	30 e0       	ldi	r19, 0x00	; 0
    6b3c:	03 e0       	ldi	r16, 0x03	; 3
    6b3e:	ee 24       	eor	r14, r14
    6b40:	ff 24       	eor	r15, r15
    6b42:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>

	xTaskCreate(vidLED_Task,"LED_State",85,NULL,3,NULL);
    6b46:	82 e8       	ldi	r24, 0x82	; 130
    6b48:	94 e3       	ldi	r25, 0x34	; 52
    6b4a:	28 eb       	ldi	r18, 0xB8	; 184
    6b4c:	30 e0       	ldi	r19, 0x00	; 0
    6b4e:	b9 01       	movw	r22, r18
    6b50:	45 e5       	ldi	r20, 0x55	; 85
    6b52:	50 e0       	ldi	r21, 0x00	; 0
    6b54:	20 e0       	ldi	r18, 0x00	; 0
    6b56:	30 e0       	ldi	r19, 0x00	; 0
    6b58:	03 e0       	ldi	r16, 0x03	; 3
    6b5a:	ee 24       	eor	r14, r14
    6b5c:	ff 24       	eor	r15, r15
    6b5e:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>

	xTaskCreate(vidLCD_Task,"LCD",100,NULL,1,NULL);
    6b62:	85 ee       	ldi	r24, 0xE5	; 229
    6b64:	94 e3       	ldi	r25, 0x34	; 52
    6b66:	22 ec       	ldi	r18, 0xC2	; 194
    6b68:	30 e0       	ldi	r19, 0x00	; 0
    6b6a:	b9 01       	movw	r22, r18
    6b6c:	44 e6       	ldi	r20, 0x64	; 100
    6b6e:	50 e0       	ldi	r21, 0x00	; 0
    6b70:	20 e0       	ldi	r18, 0x00	; 0
    6b72:	30 e0       	ldi	r19, 0x00	; 0
    6b74:	01 e0       	ldi	r16, 0x01	; 1
    6b76:	ee 24       	eor	r14, r14
    6b78:	ff 24       	eor	r15, r15
    6b7a:	0e 94 74 17 	call	0x2ee8	; 0x2ee8 <xTaskCreate>

	/*******************************************/


	/* Start Scheduler */
	vTaskStartScheduler();
    6b7e:	0e 94 28 1b 	call	0x3650	; 0x3650 <vTaskStartScheduler>
    6b82:	ff cf       	rjmp	.-2      	; 0x6b82 <main+0xa6>

00006b84 <memcpy>:
    6b84:	fb 01       	movw	r30, r22
    6b86:	dc 01       	movw	r26, r24
    6b88:	02 c0       	rjmp	.+4      	; 0x6b8e <memcpy+0xa>
    6b8a:	01 90       	ld	r0, Z+
    6b8c:	0d 92       	st	X+, r0
    6b8e:	41 50       	subi	r20, 0x01	; 1
    6b90:	50 40       	sbci	r21, 0x00	; 0
    6b92:	d8 f7       	brcc	.-10     	; 0x6b8a <memcpy+0x6>
    6b94:	08 95       	ret

00006b96 <memset>:
    6b96:	dc 01       	movw	r26, r24
    6b98:	01 c0       	rjmp	.+2      	; 0x6b9c <memset+0x6>
    6b9a:	6d 93       	st	X+, r22
    6b9c:	41 50       	subi	r20, 0x01	; 1
    6b9e:	50 40       	sbci	r21, 0x00	; 0
    6ba0:	e0 f7       	brcc	.-8      	; 0x6b9a <memset+0x4>
    6ba2:	08 95       	ret

00006ba4 <_exit>:
    6ba4:	f8 94       	cli

00006ba6 <__stop_program>:
    6ba6:	ff cf       	rjmp	.-2      	; 0x6ba6 <__stop_program>
